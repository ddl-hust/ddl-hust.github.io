<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DDL&#39;s homepage</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-29T00:57:40.361Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ddl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>许知远-罗翔访谈记录</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-12-29T00:54:46.199Z</published>
    <updated>2020-12-29T00:57:40.361Z</updated>
    
    <content type="html"><![CDATA[<p>《十三邀》中许对罗翔的访谈，这其中看到了B站张三老师另外的一面</p><a id="more"></a><blockquote><p>在人类所有美德中，勇敢是最稀缺的</p></blockquote><p>罗上学时候结巴，后来为了养活自己讲课， 写逐字稿，慢慢就不结巴了。</p><p><img src="https://raw.githubusercontent.com/ddl-hust/imagebed/master/20201228153612.png" alt=""></p><p>巧了我的启蒙也是赵借我看的这一套书，现在还在启蒙，永不过时。</p><p>北京万圣书店</p><p><a href="https://zh.m.wikisource.org/zh-hans/%E4%BF%A0%E5%AE%A2%E8%A1%8C_(%E6%9D%8E%E7%99%BD)" target="_blank" rel="noopener">李白-侠客行</a>   武侠小说中对结果正义的最求，话说罗能够完整背诵侠客行还是挺让我意外的。</p><p><a href="https://book.douban.com/subject/2009914/" target="_blank" rel="noopener">为权力而斗争</a></p><blockquote><p>罗: 人最大的痛楚在于，无法跨越知道和做到的鸿沟</p></blockquote><p>罗对技术主义的转变，这里比较含糊，</p><p>罗说要警惕<a href="https://www.wikiwand.com/zh-hans/%E7%9B%B8%E5%B0%8D%E4%B8%BB%E7%BE%A9" target="_blank" rel="noopener">相对主义</a></p><p>罗推崇节制<a href="https://baike.baidu.com/item/%E5%BE%B7%E5%B0%94%E6%96%90%E7%A5%9E%E8%B0%95" target="_blank" rel="noopener">德尔菲神谕  </a>  ““认识你自己”、“凡事勿过度”、“承诺带来痛苦””</p><p>整个访谈<strong>最精彩的部分</strong>  </p><p>许: 法律学家在20世纪没有参与到整个社会的思想辩论中，如何看待？</p><p>罗:专业人士的自我封闭化，害怕专业变味，法学家的技术主义，上学时以技术主义为荣，觉得没白学</p><p>许: 什么时候这种观点发生了变化？</p><p>罗: 高傲的观点与老百姓内心常识相抵触时候，技术主义在逻辑论证没有问题，但其实是在抵触人内心的良知。人生的经历使得自己<strong>接受人生的有限性</strong></p><blockquote><p>承认自己是有限的，承认你的逻辑是有限的，承认你的理性是有有限的，承认自己的阅读是有限的，承认自己的偏见，一生就是在走出偏见</p></blockquote><p>许: 变化的契机?</p><p>罗：一些不可抗拒的力量，有些话也不好说，经历了亲人的生离死别。人最大的痛苦就是无法跨越知道和做到的鸿沟。笛卡尔说的“我思故我在”给人一种幻想-就是我思考到了，我就能做到，但其实不是这样。</p><p>2010年之前教课很受学生喜欢，有强烈的骄傲，但是内心有一种冲突，自己所教的，自己做不到，骗别人，在自我欺骗，陷入一种虚无</p><p>许: 如何应对那一次危机?</p><p>罗: 虚伪是肯定的，做到行动在言语之前多那么一步，摆脱虚伪的自我控诉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《十三邀》中许对罗翔的访谈，这其中看到了B站张三老师另外的一面&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>多抓鱼采访</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-12-28T14:42:09.949Z</published>
    <updated>2020-12-28T14:42:09.949Z</updated>
    
    <content type="html"><![CDATA[<ul><li>多抓鱼和咸鱼区别？</li></ul><p>咸鱼更像是一个平台，一个流量入口，对于商品的质量没有过多的把控，当然这也是一种商业模式，通过动态调整容错率，用户的信用来优化。 但是多抓鱼是负责品控的，对于什么书卖不卖有自己的逻辑，同时也会对回收的书做消毒等后期处理，提升整个交易的体验感。</p><p>“可能因为多抓鱼是做书的，所以大家对我们经常有一种误解，觉得我们是一家卖情怀的公司，但事实上真不是这样的，我们是一家正经的商业公司。虽然我们的员工都很喜欢看书，也非常喜欢逛二手店，但是我们觉得，想要把一件事情做好，就一定要有一个良好的商业模式在背后支撑，这样才可以走得比较长远，而不是用爱来发电。”</p><p><strong>为什么做多抓鱼</strong>？</p><ul><li><p>猫助自己大学期间对文化产品需求很高，同时没什么钱，于是在毕业季做起了摆摊。</p></li><li><p>解决交易信用，解决交易摩擦；用定价系统解决了交易效率的问题，用翻新的技术解决了交易信用的问题</p></li><li><p>因为我们的员工非常相信一句话：一家书店的气质是由它不卖什么书决定的</p></li><li><p>二手物品往往有它自己的故事，它都带着上一个主人的回忆，这也是多抓鱼名字的来源，是一个法语单词，déjà vu</p></li><li><p>安全感不会是你的年薪带给你的，就像曾经的我那样。安全感其实是通过你的创造带给你的</p></li><li><p>猫助的职业路径从搜狐-&gt;知乎-&gt;阿里，合伙创始人陈托前知乎商业产品负责人、豆瓣社区开发负责人</p></li></ul><blockquote><p>“当时的打工让我感受到很多虚无的光环，大公司的title、夸张的年薪，这些跟「你是谁」「你想在世界上做什么」完全没有关系的世俗定位让我很迷失，我很害怕失去这种定位带来的安全感。”</p></blockquote><p><strong>多抓鱼的定价策略</strong></p><p><img src="https://raw.githubusercontent.com/ddl-hust/imagebed/master/20201228114008.png" alt=""></p><ul><li>确定几类书不收</li><li>一开始人工判断书收不收，慢慢积累数据集，通过人工智能来判断。</li><li>定价通过多抓鱼内部数据，根据市场供求关系动态变化</li></ul><p><strong>shownotes</strong></p><p><a href="https://www.yixi.tv/h5/speech/667/" target="_blank" rel="noopener">一席采访多抓鱼CEO猫助</a></p><p><a href="https://www.listennotes.com/zh-hans/podcasts/%E4%B8%89%E4%BA%94%E7%8E%AF/no26-%E8%B7%9F%E5%A4%9A%E6%8A%93%E9%B1%BC%E7%9A%84%E7%8C%AB%E5%8A%A9%E8%81%8A%E8%81%8A%E4%BA%8C%E6%89%8B%E7%94%9F%E6%84%8F%E5%92%8C%E5%88%9B%E4%B8%9A%E6%80%81%E5%BA%A6-VlHYyDs2f1p/" target="_blank" rel="noopener">三五环</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;多抓鱼和咸鱼区别？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;咸鱼更像是一个平台，一个流量入口，对于商品的质量没有过多的把控，当然这也是一种商业模式，通过动态调整容错率，用户的信用来优化。 但是多抓鱼是负责品控的，对于什么书卖不卖有自己的逻辑，同时也会对回收的书做消毒等后期处
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>适合反复看的技术入门教程</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-12-23T11:55:39.000Z</published>
    <updated>2020-12-23T12:16:53.303Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ol><li><a href="https://zhuanlan.zhihu.com/p/339008746?utm_source=org.telegram.messenger&utm_medium=social&utm_oi=966460230863925248" target="_blank" rel="noopener">Kubernetes 入门&amp;进阶实战</a>  腾讯CSIG工程师写的，估计是内部k吧开源出来的</li></ol><blockquote><p>笔者今年（公元 2020 年）9 月从端侧开发转到后台开发，第一个系统开发任务就强依赖了 K8S，加之项目任务重、排期紧，必须马上对 K8S 有概念上的了解。然而，很多所谓“K8S 入门\概念”的文章看的一头雾水，对于大部分新手来说并不友好。经历了几天痛苦地学习之后，回顾来看，<strong>K8S 根本不复杂。</strong>于是，决心有了这一系列的文章：一方面希望对新手同学有帮助；另一方面，以文会友，希望能够有机会交流讨论技术。</p></blockquote><ol start="2"><li><a href="https://kingsamchen.github.io/2020/02/08/how-to-learn-cmake-as-the-beginner/" target="_blank" rel="noopener">CMake 入门指南</a>  这位大哥是B站后端工程师，最早是在饭否看到他的技术分享觉得很棒，然后顺藤摸瓜找到了他的个人博客，可以看出来他对C++理解还是很深，虽然我之后可能不怎么会接触C++开发了，但是很多好的概念还是值得学习的。</li></ol><h4 id="0x00-起手式"><a href="#0x00-起手式" class="headerlink" title="0x00 起手式"></a>0x00 起手式</h4><p>这里假设题主以及其他想入门 CMake 的人像我一样，下面是我个人总结的比较适合的学习路径。</p><p>首先默念三遍并记住口诀：</p><ol><li>Declare a target</li><li>Declare target’s traits</li><li>It’s all about targets</li></ol><p>然后 clone <a href="https://github.com/ttroy50/cmake-examples" target="_blank" rel="noopener">https://github.com/ttroy50/cmake-examples</a> 这个项目到本地，把里面的</p><ul><li>01-basic（跳过E-installing，因为和依赖有关，后面会说）</li><li>02-sub-projects</li></ul><p>两个目录认真的学习一遍，最好自己能够动手跟着做一遍。</p><p>每学习完一个小节，把前面的三句口诀复习一下</p><p>每遇到一个不认识的命令，在 <a href="https://link.zhihu.com/?target=https%3A//gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">Effective Modern CMake</a> 这个页面里搜索一下，看看这个命令是否取代了某个老命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/339008746?utm_source=org.telegram.messenger&amp;utm_medium=social&amp;utm_oi=96646
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Peter Thiel&#39;s Religion — David Perell</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-12-17T06:36:29.081Z</published>
    <updated>2020-12-23T12:53:18.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读《Peter-Thiel’s-Religion-—-David-Perell》有感"><a href="#读《Peter-Thiel’s-Religion-—-David-Perell》有感" class="headerlink" title="读《Peter Thiel’s Religion — David Perell》有感"></a>读《Peter Thiel’s Religion — David Perell》有感</h2><p>转载的一篇文章，分析皮特泰勒的思想，泰勒原来就是PayPal的创始人之一，《0到1》的作者，原文很长，其中有些思想让我印象深刻，比如“模仿学习”的天性，</p><blockquote><ol><li>Don’t copy your neighbors</li><li>Time moves forward</li><li>The future will be different from the present</li></ol></blockquote><p>以及为什么这样模仿他人创业不会成功，为什么在高强度竞争不会得到高效率产出。</p><a id="more"></a><blockquote><p>“Our Mimetic nature is simultaneously our biggest strength and biggest weakness. When it goes right, imitation is a shortcut to learning. But when it spirals out of control, Mimetic imitation leads to envy, violence, and bitter, ever-escalating violence. “</p></blockquote><p>人类模仿的天性既是我们的最大优点也是我们最大的缺点，用对了，模仿是学习的捷径。但是一旦模仿失去了控制，模仿将导致人与人之间的嫉妒，暴力。</p><blockquote><p>“As Peter Thiel recounted:</p><p>“When I left after seven months and three days, one of the lawyers down the hall from me said, ‘You know, I had no idea it was possible to escape from Alcatraz.’ Of course that was not literally true, since all you had to do was go out the front door and not come back. But psychologically this was not what people were capable of. Because their identity was defined by competing so intensely with other people, they could not imagine leaving… <strong>On the outside, everybody wanted to get in. On the inside, everybody wanted to get out</strong>.”” </p></blockquote><p>项飙对内卷有类似表述，<a href="https://m.thepaper.cn/newsDetail_forward_9648585" target="_blank" rel="noopener">人类学家项飙谈内卷：一种不允许失败和退出的竞争</a>。 项飙最开始通过十三邀认识的，温州人，人类学博士，瘦瘦的，穿一件白衬衫。属于年少成名，大学期间发表了《浙江村》属于社区田野调查，我翻了下并没有多大兴趣。。。反倒是最近的一本 <a href="https://book.douban.com/subject/35092383/" target="_blank" rel="noopener">《把自己作为方法》</a> 一口气读完了，单读的主编吴琦(以前一直以为是女的。。。)采访项飙的一些文章集合，读起来没什么压力，有一处印象很深，“我调查时也有这个问题，我不太放松，不太能够调笑戏谑，比较欠缺跟大家打成一片的能力，也是我自己不太满意的地方。这个当然跟我小时候的成长有关系，我老跟我外公在一起，不太跟同龄人玩。我外公不让我跟同龄人玩，因为同龄人都是拉板车的子弟。我记得邻居如果给我东西吃，他表面上会很客气地接受，转身就让我不要吃，觉得不卫生。他也是有两面性的，对外非常客气，内心又可能有一种鄙视，其实对我也有影响，一方面把我变得比较理智，另外一方面使我不太放松。”  这让我想到我的外公。</p><p>下面的一些表述也让我产生强烈的感触，但是知道和有勇气去做还是很不一样的，路还很远。</p><blockquote><p>“真正的英雄不是改变世界，而是改变自己生活的每一天。很遗憾，在现代性之下，“边缘”和“中心”变成一组对立关系，中国人又有那么强的中心情结，觉得边缘的生活不值得过，造成极大的焦虑。”</p></blockquote><blockquote><p>我们在国内写报告，好像就是要高于生活，要写得很拽很正式，脱离生活，如果把吃喝拉撒睡都写进去，好像很不正常。</p><p>把自己作为方法：与项飙谈话【牛津大学社会人类学教授项飙，从个人经历切入，回应当下年轻人的精神困境，追索80年代、阶层流动、大学教育、民族与民粹、中国意识等社会议题的新答案】 (项飙)</p><p>您在位置 #1013-1014的标注 | 添加于 2020年10月4日星期日 上午12:27:50</p></blockquote><blockquote><p>不要怕边缘，或者知识不够，把自己的不够、天真真实地体现出来，就会很可爱，不要装腔作势</p></blockquote><blockquote><p>Thiel’s companies are governed by Girard’s wisdom. Girard observed that all desires come from other people. When two people want the same scarce object, they fight. In response, as CEO of PayPal, Thiel set up the company structure to eliminate competition between employees. PayPal overhauled the organization chart every three months. By repositioning people, the company avoided most conflicts before they even started. Employees were evaluated on one single criterion, and no two employees had the same one. They were responsible for one job, one metric, and one part of the business. </p></blockquote><p>这样花大力气调整组织架构来避免内部人员的竞争，值得考虑，但是每一个公司创世的企业文化可能差别很大，不过这种观念以及措施之前真的没有听说过，大开眼界。</p><blockquote><p>Girard observed that even when you put a group of kids together in a room full of toys, they’ll inevitably desire the same toy instead of finding their own toy to play with. A rivalry will emerge. Human see, human want. </p><p>Our capacity for imitation leads to envy. Babies’ interest in a particular toy has less to do with the toy itself and more to do with the fact that the other babies desire the toy. As soon as one child desires the toy, so do the others. Eventually, even though there are many toys available to play with, all the children want the same toy. </p></blockquote><p>#好故事 人类模仿的天性导致嫉妒</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;读《Peter-Thiel’s-Religion-—-David-Perell》有感&quot;&gt;&lt;a href=&quot;#读《Peter-Thiel’s-Religion-—-David-Perell》有感&quot; class=&quot;headerlink&quot; title=&quot;读《Peter Thiel’s Religion — David Perell》有感&quot;&gt;&lt;/a&gt;读《Peter Thiel’s Religion — David Perell》有感&lt;/h2&gt;&lt;p&gt;转载的一篇文章，分析皮特泰勒的思想，泰勒原来就是PayPal的创始人之一，《0到1》的作者，原文很长，其中有些思想让我印象深刻，比如“模仿学习”的天性，&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Don’t copy your neighbors&lt;/li&gt;
&lt;li&gt;Time moves forward&lt;/li&gt;
&lt;li&gt;The future will be different from the present&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;以及为什么这样模仿他人创业不会成功，为什么在高强度竞争不会得到高效率产出。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>bash学习</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-12-10T08:38:24.000Z</published>
    <updated>2020-12-10T08:55:44.560Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="学习bash"><a href="#学习bash" class="headerlink" title="学习bash"></a>学习bash</h3><p> <a href="https://github.com/bobbyiliev/introduction-to-bash-scripting" target="_blank" rel="noopener">introduction-to-bash-scripting</a>的学习笔记 配合 <a href="https://repl.it/languages/bash" target="_blank" rel="noopener">线上bash解释器</a></p><p>bash 脚本开头一行 都有 <code>#!/bin/bash</code> 指此脚本使用<strong>/bin/sh</strong>来解释执行，<strong>#!</strong>是特殊的表示符，其后面根的是此解释此脚本的shell的路径, python脚本在开头也有类似的语句， <code>#!/bin/python2</code> or <code>#!/bin/python3</code></p><p>创建完一个bash脚本之后，需要通过<code>chmod +x XXX.sh</code> 赋予bash脚本执行权限， 文件的权限可以通过<code>ls -l</code> 查看详细， 用户组，其他，用户都具有自己对文件的权限。</p><p>bash 脚本执行可以 通过<code>./XXX.sh</code> 也可以直接指明<code>bash xxx.sh</code>  其中前者指定了sh 文件的路径，<a href="https://unix.stackexchange.com/questions/114300/whats-the-meaning-of-a-dot-before-a-command-in-shell" target="_blank" rel="noopener">参考</a></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>bash 变量不需要指定类型，直接赋值，解释器动态解释。</p><p><strong>变量定义</strong>:</p><p><code>name=&quot;DevDojo&quot;</code>  note： 赋值号左右不能又空格，如果平时编码习惯和这个不一样，需要注意下。</p><p><strong>变量使用</strong></p><p><code>echo ${name}</code> 括号增加可读性。同时变量也可以在表达式中使用，语法与直接使用一样。</p><p>bash 语句不像c++需要显式<code>;</code>表示语句结束</p><p><strong>用户输入</strong></p><p>从命令行读取用户输入</p><p><code>read variable</code></p><p><strong>外部参数</strong></p><p>bash 脚本在运行时候,可以跟可变多的参数,在脚本内部用$1, $2来指代,如下面例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Argument one is <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Argument two is <span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Argument three is <span class="variable">$3</span>"</span></span><br><span class="line"><span class="comment"># excute</span></span><br><span class="line">./arguments.sh dog cat bird</span><br></pre></td></tr></table></figure><p>也可以很方便的用 <code>$@</code> 来引用所有的外部参数.</p><p>$0表示脚本文件名,一个用处就是在执行完脚本之后,可以用$0获取脚本名,然后做自删除.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The name of the file is: <span class="variable">$0</span> and it is going to be self-</span></span><br><span class="line"><span class="string">deleted."</span></span><br><span class="line">rm -f <span class="variable">$0</span></span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><p>语法:<code>my_array=(&quot;value 1&quot; &quot;value 2&quot; &quot;value 3&quot; &quot;value 4&quot;)</code>  元素之间用空格隔开</p><p>数组引用类似C,  <code>echo ${my_array[1]}</code>  元素起始下标为0</p><p>数组长度获取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=(1 2 3 4)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#list[@]&#125;</span>  <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><ul><li>算数表达  语法类似, 用英文字母的缩写来表示比较属性, eg. lt(less than) ,eq(equal) …..<ul><li>[[ ${arg1} -eq ${arg2} ]]    equal  如果两个变量相同返回true</li></ul></li><li>字符串<ul><li>[[ -v ${varname} ]] 变量如果被赋值返回true</li><li>[[ -z ${string} ]] 字符串长度为0 为true</li><li>[[ -n ${string} ]] 字符串长度不为0</li></ul></li><li>文件表达式 在linux 下面一切都是文件,文件具有不同的类型 比如块文件,字符设备,目录等<ul><li>[[ -d ${file} ]]    是否为目录</li><li>[[ -x ${file} ]]  文件是否可执行</li><li>[[ -L ${file} ]]  文件是否为符号链接</li></ul></li></ul><p>有了条件表达式,自然引出了条件语句</p><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p><strong>if-else</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ some_test ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span> &lt;commands&gt;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>swith 语句</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$some_variable</span> <span class="keyword">in</span></span><br><span class="line">  pattern_1)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">  pattern_2| pattern_3)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    default commands</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>注意点</p><ol><li>case 语句用关键字<strong>case</strong>开始,引用变量,然后加关键字<strong>in</strong></li><li>匹配模式用) 结束</li><li>All clauses have to be terminated by adding ;; at the end</li><li>默认模式用*匹配</li><li>case 语句结束用esac关键字</li></ol><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><strong>while</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ your_condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    your_conditions</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>条件表达式都用[] 或者[[]]括起来, <a href="https://stackoverflow.com/questions/3427872/whats-the-difference-between-and-in-bash" target="_blank" rel="noopener">区别</a></p><p><strong>until</strong></p><p>含义是当条件不为真时候一直运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ your_condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    your_commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h3 id=&quot;学习bash&quot;&gt;&lt;a href=&quot;#学习bash&quot; class=&quot;headerlink&quot; title=&quot;学习bash&quot;&gt;&lt;/a&gt;学习bash&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;https://github.com/bobbyi
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>谁想看清尘世就应当同它保持必要的距离</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-11-20T13:07:07.000Z</published>
    <updated>2020-12-09T08:22:14.066Z</updated>
    
    <content type="html"><![CDATA[<p>《树上的男爵》是一本小册子，200来页，很快就能读完。</p><p>书中探讨了关于自我和集体，自我和爱情，以及为了追求一个完整的自我，所作的取舍。要有不少句子都充满哲理，引人深思。</p><blockquote><p>他懂得这个道理：集体会使人更强大，能突出每个人的长处，使人得到替自己办事时极难以获得的那种快乐，会为看到那么多正直、勇敢而能干的人而喜悦，为了他们值得去争取美好的东西（而在为自己而生活时，经常出现的是相反的情形，看到的是人们的另一副面孔，使你必须永远用手握住剑柄）。 这个火灾的夏季因此而成为一个不错的季节：在大家的心中有一个需要解决的共同问题，每个人都把它放在其他个人利益之前，而且从其他许多优秀人物的赞同和敬佩中得到了满足与报偿。 后来，柯希莫不得不明白，当那个共同的问题不存在之后，集体就不再像从前那么好了，做一个孤独的人更好一些，而不要当首领。</p></blockquote><blockquote><p>真事使人回忆起许多属于过去的时光、细腻的感情、烦扰、幸福、疑惑、光荣和对自己的厌恶，而故事中砍掉了主要的东西，一切显得轻而易举。但变来变去，最后发觉自己在回头去讲自己经历过的真实生活中体验过或发生过的事情。</p></blockquote><blockquote><p>如果不感到自身充满力量，就不可能有爱情。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《树上的男爵》是一本小册子，200来页，很快就能读完。&lt;/p&gt;
&lt;p&gt;书中探讨了关于自我和集体，自我和爱情，以及为了追求一个完整的自我，所作的取舍。要有不少句子都充满哲理，引人深思。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;他懂得这个道理：集体会使人更强大，能突出每个人的长
      
    
    </summary>
    
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>套接字选项小结</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-08-24T09:41:40.000Z</published>
    <updated>2020-08-24T09:44:00.509Z</updated>
    
    <content type="html"><![CDATA[<p>总结影响网络收发包的一些套接字选项，对一些概念可能理解不对，希望大家多多指教。后面会持续更新ing。</p><a id="more"></a><p>[TOC]</p><h3 id="套接字属性设置"><a href="#套接字属性设置" class="headerlink" title="套接字属性设置"></a><strong>套接字属性设置</strong></h3><hr><p>通过setsockopt我们可以设置套接字的一些属性，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val,<span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>level</code> 参数设定的套接字属性使用范围，<code>SOL_SOCKET</code>表示用于通用套接字，<code>IPPROTO_TCP</code> 用于tcp协议，<code>IPPROTO_IP</code> 用于IP协议。</p><p>下表是《APUE》中给出的一些通用套接字设置选项</p><p><img src="https://s1.ax1x.com/2020/08/07/ahtjHI.png" alt="ahtjHI.png"></p><h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><blockquote><p>为什么需要保活?</p></blockquote><p>在tcp连接双方，建立连接之后，很长时间没有交换数据，在这种长时间没有数据交换情况下，双方不知道对方状态，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些TCP连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用TCP的保活报文来实现。</p><ol><li>探测连接的对端是否存活</li></ol><p>在应用交互的过程中，可能存在以下几种情况：</p><ol><li><p>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来 2小时再复位。</p></li><li><p>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP没有响应。服务器将不能够收到对探查的响应，并在<strong>75s</strong>后超时。服务器总共发送<strong>10个</strong>这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</p></li><li><p><strong>客户主机崩溃并已经重新启动</strong>。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</p></li><li><p>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。</p></li></ol><p>​     利用保活探测功能，可以探知这种对端的意外情况，从而保证在意外发生时，可以释放半打开的TCP连接。</p><ol start="2"><li><p><strong>防止中间设备因超时删除连接相关的连接表</strong></p><p>中间设备如防火墙等，会为经过它的数据报文建立相关的连接信息表，并为其设置一个超时时间的定时器，如果超出预定时间，某连接无任何报文交互的中间设备会将该连接信息从表中删除，在删除后，再有应用报文过来时，中间设备将丢弃该报文，从而导致应用出现异常，这个交互的过程大致如下图所示：</p></li></ol><p>默认情况下tcp的保活是关闭的,需要我们自己打开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optval = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, optlen);</span><br></pre></td></tr></table></figure><p><strong>全局修改探测活参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">600</span> &gt; /proc/sys/net/ipv4/tcp_keepalive_time <span class="comment">//超时时间</span></span><br><span class="line">echo <span class="number">60</span> &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl <span class="comment">//探测报文发送间隔</span></span><br><span class="line">echo <span class="number">20</span> &gt; /proc/sys/net/ipv4/tcp_keepalive_probes <span class="comment">//探测报文发送次数</span></span><br></pre></td></tr></table></figure><p><strong>通过系统调用对单个进程修改</strong></p><p>对应到的几个套接字选项如下</p><p><strong>TCP_KEEPCNT</strong>: 对应到探测报文发送次数；</p><p><strong>TCP_KEEPINTVL</strong>: 探测报文发送间隔</p><p><strong>TCP_KEEPIDLE</strong>: 超时时间</p><blockquote><p>TCP层的保活和应用层保活对比</p></blockquote><p><code>KeepAlive</code>通过定时发送探测包来探测连接的对端是否存活， 但通常也会许多在业务层面处理的，他们之间的特点：</p><ul><li>TCP自带的<code>KeepAlive</code>使用简单，发送的数据包相比应用层心跳检测包更小，仅提供检测连接功能</li><li>应用层心跳包不依赖于传输层协议，无论传输层协议是TCP还是UDP都可以用</li><li>应用层心跳包可以定制，可以应对更复杂的情况或传输一些额外信息</li><li><code>KeepAlive</code>仅代表连接保持着，而心跳包往往还代表客户端可正常工作</li></ul><h3 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a><strong>SO_LINGER</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>对应的<code>val</code>是一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">　　<span class="keyword">int</span> l_onoff; <span class="comment">//开关 0:关闭</span></span><br><span class="line">　　<span class="keyword">int</span> l_linger;<span class="comment">//延迟关闭时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个简单的使用例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">lin</span>&#123;</span><span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">setsockopt(fd,SOL_SOCKET,SO_SOCKET,&amp;lin);</span><br></pre></td></tr></table></figure><p>linger打开与否，以及不同时间的设置，可能导致不同的关闭结果。</p><p>三种断开方式：</p><ol><li>l_onoff = 0; l_linger忽略</li></ol><p>close()立刻返回，底层会将未发送完的数据发送完成后再释放资源，即优雅退出。</p><ol start="2"><li>l_onoff != 0; l_linger = 0;</li></ol><p>close()立刻返回，但不会发送未发送完成的数据，而是通过一个RST包强制的关闭socket描述符，即强制退出。</p><ol start="3"><li>l_onoff != 0; l_linger &gt; 0;</li></ol><p>close()不会立刻返回，内核会延迟一段时间，这个时间就由l_linger的值来决定。如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，close()会返回正确，socket描述符优雅性退出。否则，close()会直接返回错误值，未发送数据丢失，socket描述符被强制性退出</p><h4 id="SO-LINGER实现原理"><a href="#SO-LINGER实现原理" class="headerlink" title="SO_LINGER实现原理"></a>SO_LINGER实现原理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SO_LINGER:</span><br><span class="line"><span class="keyword">if</span>(optlen&lt;<span class="keyword">sizeof</span>(ling)) &#123;</span><br><span class="line">ret = -EINVAL;<span class="comment">/* 1003.1g */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!ling.l_onoff)<span class="comment">//没有打开linger</span></span><br><span class="line">sock_reset_flag(sk, SOCK_LINGER);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> (BITS_PER_LONG == <span class="number">32</span>)</span><br><span class="line"><span class="keyword">if</span> (ling.l_linger &gt;= MAX_SCHEDULE_TIMEOUT/HZ)</span><br><span class="line">sk-&gt;sk_lingertime = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">sk-&gt;sk_lingertime = ling.l_linger * HZ;<span class="comment">//设置linger时间</span></span><br><span class="line">sock_set_flag(sk, SOCK_LINGER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>程序调用函数close()关闭套接口时，与此相关的函数调用路径如下：<code>sys_close() -&gt; filp_close() -&gt; fput() -&gt; __fput() -&gt; sock_close() -&gt; sock_release() -&gt; inet_release() -&gt; tcp_close()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_release</span><span class="params">(struct socket *sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk) &#123;</span><br><span class="line"><span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Applications forget to leave groups before exiting */</span></span><br><span class="line">ip_mc_drop_socket(sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If linger is set, we don't return until the close</span></span><br><span class="line"><span class="comment"> * is complete.  Otherwise we return immediately. The</span></span><br><span class="line"><span class="comment"> * actually closing is done the same either way.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the close is due to the process exiting, we never</span></span><br><span class="line"><span class="comment"> * linger..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timeout = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp;</span><br><span class="line">    !(current-&gt;flags &amp; PF_EXITING))</span><br><span class="line">timeout = sk-&gt;sk_lingertime;</span><br><span class="line">sock-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">sk-&gt;sk_prot-&gt;<span class="built_in">close</span>(sk, timeout);<span class="comment">//对应到tcp_close</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcp-close"><a href="#tcp-close" class="headerlink" title="tcp_close()"></a><code>tcp_close()</code></h4><p>当一个套接口正在或已经被关闭，如果在其接收队列有未读数据（不管是在关闭前就已收到的，或者还是在关闭后新到达的），那么此时就需给对端发送一个RST数据包,对应到下面一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data_was_unread) &#123;<span class="comment">//接受区还有数据没有被读完</span></span><br><span class="line"><span class="comment">/* Unread data was tossed, zap the connection. */</span></span><br><span class="line">NET_INC_STATS_USER(LINUX_MIB_TCPABORTONCLOSE);</span><br><span class="line">tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">tcp_send_active_reset(sk, GFP_KERNEL);<span class="comment">//发送RST</span></span><br></pre></td></tr></table></figure><p>如果linger结构体的字段<code>l_onoff</code>为1,而<code>l_linger</code>为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp; !sk-&gt;sk_lingertime) &#123;</span><br><span class="line"><span class="comment">/* Check zero linger _after_ checking for unread data. */</span></span><br><span class="line">sk-&gt;sk_prot-&gt;<span class="built_in">disconnect</span>(sk, <span class="number">0</span>); <span class="comment">//直接丢掉所有接收数据并且直接断开连接，具体也就是发送RST数据包，清空相关接收队列</span></span><br><span class="line">NET_INC_STATS_USER(LINUX_MIB_TCPABORTONDATA);</span><br></pre></td></tr></table></figure><p>下面就是对应正常四次挥手关闭流程，</p><p>先调用函数<code>tcp_close_state()</code>切换状态，判断是否需要发送FIN数据包（eg.如果当前还处于<code>TCP_SYN_SENT</code>状态，连接尚未完全建立，自然就不用发送FIN数据包），如果需要发送FIN数据包则调用<code>tcp_send_fin()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....... </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tcp_close_state(sk)) &#123;</span><br><span class="line">tcp_send_fin(sk);</span><br><span class="line">&#125;</span><br><span class="line"> sk_stream_wait_close(sk, timeout);</span><br></pre></td></tr></table></figure><h4 id="tcp-send-fin"><a href="#tcp-send-fin" class="headerlink" title="tcp_send_fin"></a><strong>tcp_send_fin</strong></h4><p>深入到发送fin内部来看，</p><p>如果发送队列还有数据，那么直接将取出末尾数据包，设置FIN。否则分配一个新的skb,最后调用函数<code>__tcp_push_pending_frames() -&gt; tcp_write_xmit()</code>发送数据包。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_send_fin</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = <span class="title">skb_peek_tail</span>(&amp;<span class="title">sk</span>-&gt;<span class="title">sk_write_queue</span>);</span> <span class="comment">//取出末尾数据包</span></span><br><span class="line"><span class="keyword">int</span> mss_now;</span><br><span class="line"></span><br><span class="line">mss_now = tcp_current_mss(sk, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_send_head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">TCP_SKB_CB(skb)-&gt;flags |= TCPCB_FLAG_FIN;<span class="comment">//</span></span><br><span class="line">TCP_SKB_CB(skb)-&gt;end_seq++;</span><br><span class="line">tp-&gt;write_seq++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Socket is locked, keep trying until memory is available. */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">skb = alloc_skb(MAX_TCP_HEADER, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (skb)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reserve space for headers and prepare control bits. */</span></span><br><span class="line">skb_reserve(skb, MAX_TCP_HEADER);</span><br><span class="line">skb-&gt;csum = <span class="number">0</span>;</span><br><span class="line">TCP_SKB_CB(skb)-&gt;flags = (TCPCB_FLAG_ACK | TCPCB_FLAG_FIN);</span><br><span class="line">TCP_SKB_CB(skb)-&gt;sacked = <span class="number">0</span>;</span><br><span class="line">skb_shinfo(skb)-&gt;tso_segs = <span class="number">1</span>;</span><br><span class="line">skb_shinfo(skb)-&gt;tso_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */</span></span><br><span class="line">TCP_SKB_CB(skb)-&gt;seq = tp-&gt;write_seq;</span><br><span class="line">TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + <span class="number">1</span>;</span><br><span class="line">tcp_queue_skb(sk, skb);</span><br><span class="line">&#125;</span><br><span class="line">__tcp_push_pending_frames(sk, tp, mss_now, TCP_NAGLE_OFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sk-stream-wait-close"><a href="#sk-stream-wait-close" class="headerlink" title="sk_stream_wait_close"></a><strong>sk_stream_wait_close</strong></h4><p>这是一个阻塞等待函数，参数timeout指示了等待的时间（单位为时钟滴答）。</p><p>while循环的退出点有两处</p><ul><li><p>当前进程收到信号或时间超时（timeout）</p></li><li><p>sk_wait_event()</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sk_stream_wait_close</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">DEFINE_WAIT(wait);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">prepare_to_wait(sk-&gt;sk_sleep, &amp;wait,</span><br><span class="line">TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (sk_wait_event(sk, &amp;timeout, !sk_stream_closing(sk)))<span class="comment">// 退出点1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (!signal_pending(current) &amp;&amp; timeout); <span class="comment">//退出点2</span></span><br><span class="line">finish_wait(sk-&gt;sk_sleep, &amp;wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们结合源码大致搞清楚了SO_LINGER选项的设置对TCP连接关闭的影响。</p><h3 id="SO-REUSEPORT-amp-amp-SO-REUSEADDR"><a href="#SO-REUSEPORT-amp-amp-SO-REUSEADDR" class="headerlink" title="SO_REUSEPORT&amp;&amp;SO_REUSEADDR"></a>SO_REUSEPORT&amp;&amp;SO_REUSEADDR</h3><p>SO_REUSEADDR和SO_REUSEPORT主要是影响socket绑定ip和port的成功与否。有几点绑定规则主要注意下<br> <strong>规则1</strong>：socket可以指定绑定到一个特定的ip和port，例如绑定到192.168.0.11:9000上；<br> <strong>规则2</strong>：同时也支持通配绑定方式，即绑定到本地”any address”（例如一个socket绑定为 0.0.0.0:21，那么它同时绑定了所有的本地地址）；<br> <strong>规则3</strong>：默认情况下，任意两个socket都无法绑定到相同的源IP地址和源端口</p><h4 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a><strong>SO_REUSEADDR</strong></h4><p><strong>1、改变了通配绑定时处理源地址冲突的处理方式</strong></p><p>so_reuseaddr作用在于允许一个socket 绑定了统配地址+port， 另外一个套接字绑定具体地址+相同端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SO_REUSEADDR       socketA        socketB       Result</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">  ON&#x2F;OFF       192.168.0.1:21   192.168.0.1:21    Error (EADDRINUSE)</span><br><span class="line">  ON&#x2F;OFF       192.168.0.1:21      10.0.0.1:21    OK</span><br><span class="line">  ON&#x2F;OFF          10.0.0.1:21   192.168.0.1:21    OK</span><br><span class="line">   OFF             0.0.0.0:21   192.168.1.0:21    Error (EADDRINUSE)</span><br><span class="line">   OFF         192.168.1.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br><span class="line">   ON              0.0.0.0:21   192.168.1.0:21    OK</span><br><span class="line">   ON          192.168.1.0:21       0.0.0.0:21    OK</span><br><span class="line">  ON&#x2F;OFF           0.0.0.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br></pre></td></tr></table></figure><p><strong>2、改变了系统对处于TIME_WAIT状态的socket绑定地址的处理</strong></p><p>处于time-wait 状态下的套接字需要等待2msl 才能重新使用其绑定的端口与地址，设置了so_reuseaddr没有此限制</p><h4 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a><strong>SO_REUSEPORT</strong></h4><ol><li>允许将多个socket绑定到相同的地址和端口，前提每个socket绑定前都需设置</li><li>linux内核在处理SO_REUSEPORT socket的集合时，进行了简单的负载均衡操作，即对于UDP socket，内核尝试平均的转发数据报，对于TCP监听socket，内核尝试将新的客户连接请求(由accept返回)平均的交给共享同一地址和端口的socket(监听socket)。</li></ol><p>通过设置套接字的SO_REUSEPORT能够用来解决epoll_wait存在的惊群问题，把监听描述符添加到epoll监听事件，多个子进程都epoll_wait阻塞等待，由内核来做负载均衡，这样就避免了当实践发生时同时惊醒多个工作进程，添加了SO_REUSEPORT的模型如下:</p><img src="https://s1.ax1x.com/2020/08/13/azw6DU.png" alt="azw6DU.png" style="zoom:80%;" /><h3 id="TCP-CORK"><a href="#TCP-CORK" class="headerlink" title="TCP_CORK"></a>TCP_CORK</h3><p>tcp_cork与tcp_nodelay 以及nagle 容易搞混，这里我们结合他们的应用场景以及代码来理清楚。</p><p><strong>nagle算法</strong></p><p>大致思想：</p><p>为了提高网络吞吐量，如果发送小数据包，那么20字节包头的负担太大，于是通过将小数据包累积到一个MSS长度再发出来。</p><p>同样影响小包发送的套接字选项:<strong>TCP_NODELAY，TCP_CORK</strong></p><p>Nagle算法的<strong>基本定义</strong>是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</p><p>Nagle算法的规则（tcp_output.c文件里tcp_nagle_check函数注释）：</p><p>（1）如果包长度达到MSS，则允许发送；</p><p>（2）如果该包含有FIN，则允许发送；</p><p>（3）设置了TCP_NODELAY选项，则允许发送；</p><p>（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；</p><p>（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。</p><p><code>TCP_NODELAY</code>是禁用Nagle算法，即数据包立即发送出去，而选项TCP_CORK与此相反，可以认为它是Nagle算法的进一步增强，即阻塞数据包发送，具体点说就是：TCP_CORK选项的功能类似于在发送数据管道出口处插入一个“塞子”，使得发送数据全部被阻塞，直到取消TCP_CORK选项（即拔去塞子）或被阻塞数据长度已超过MSS才将其发送出去。举个对比示例，比如收到接收端的ACK确认后，Nagle算法可以让当前待发送数据包发送出去，即便它的当前长度仍然不够一个MSS，但选项TCP_CORK则会要求继续等待。</p><h4 id="TCP-CORK的应用场景"><a href="#TCP-CORK的应用场景" class="headerlink" title="TCP_CORK的应用场景"></a>TCP_CORK的应用场景</h4><p>TCP_CORK选项的作用主要是阻塞小数据发送，服务器处理一个客户端请求，发送的响应数据包括响应头和响应体两部分，利用TCP_CORK选项就能让这两部分数据一起发送。</p><p>按照之前的分析，设置了CORK之后，有几种可能数据会被发送</p><ul><li>通过setoptsock关闭TCP_CORK这个选项。</li><li>socket阻塞的数据大于MSS。</li><li>自从堵上塞子写入第一个字节开始，已经经过200ms。</li><li>socket被关闭。</li></ul><p>一旦满足上面的任何一个条件，TCP就会将数据发送出去。对于Server来说，发送HTTP响应既要发送尽量少的segment，同时又要保证低延迟，那么需要在写完数据后显式取消设置<code>TCP_CORK</code>选项，让数据立即发送出去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, &amp;state, <span class="keyword">sizeof</span>(state)); <span class="comment">//开启cork</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(http_resp_header);</span><br><span class="line">sendfile(sockfd, fd, &amp;off, len); <span class="comment">//阻塞</span></span><br><span class="line"></span><br><span class="line">state = <span class="number">0</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, &amp;state, <span class="keyword">sizeof</span>(state)); <span class="comment">//关闭cork</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.lenky.info/archives/2013/02/2220" target="_blank" rel="noopener">Socket选项系列之SO_LINGER</a></p><p><a href="http://senlinzhan.github.io/2017/02/10/Linux的TCP-CORK/" target="_blank" rel="noopener">Nagle 算法与 TCP socket 选项 TCP_CORK</a></p><p><a href="https://juejin.im/post/6844903878819840008" target="_blank" rel="noopener">https://juejin.im/post/6844903878819840008</a></p><p><a href="https://blog.biezhi.me/2017/08/talk-tcp-keepalive.html" target="_blank" rel="noopener">https://blog.biezhi.me/2017/08/talk-tcp-keepalive.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结影响网络收发包的一些套接字选项，对一些概念可能理解不对，希望大家多多指教。后面会持续更新ing。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡大量TW分析</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-08-23T06:59:02.000Z</published>
    <updated>2020-08-23T07:03:47.004Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>背景</p><p>LB集群使用了LVS做负载均衡，使用的是NAT模式对tcp 80端口进行负载均衡。因为服务器访问量比较大，所以负载均衡后面的web服务器上出现了大量的 timewait 状态连接。</p><p>分析思路</p><ul><li>打开tcp_tw_recycle；load balancer作为中间代理应该需要开启tcp_tw_recyvle 同时需要开启tcp_timestamps</li><li>设置SO_LINGER ; 只有正常的四次挥手过程才会出现time-wait。 打开so-linger同时将延时设为0，服务器发起关闭时，发送RST直接断开连接</li><li>调整tcp_max_tw_buckets</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;背景&lt;/p&gt;
&lt;p&gt;LB集群使用了LVS做负载均衡，使用的是NAT模式对tcp 80端口进行负载均衡。因为服务器访问量比较大，所以负载均衡后面的web服务器上出现了大量的 timewait 状态连接。&lt;/p&gt;
&lt;p&gt;分析思路&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>tcp40ms延迟问题分析</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-08-23T06:53:50.000Z</published>
    <updated>2020-08-23T07:07:00.659Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>背景</strong></p><p>tcp抓包发现服务端回复ack存在40ms左右延迟</p><p><img src="https://s1.ax1x.com/2020/08/17/dmqEqK.png" alt="dmqEqK.png"></p><p><strong>问题排查过程</strong></p><p>通过查阅资料发现tcp40ms延迟不是一个偶然的现象。先给出结论：<strong>客户端开启nagle算法+服务端延迟ack</strong>，延迟ack的超时时间为40ms。</p><p>先介绍下重要的概念</p><p><strong>delay ack</strong></p><p>在TCP建立连接之后，最开始的数据交互是处于quick ack mode,顾名思义就是当对端收到数据立马就会回复ack。在接下来的数据交互过程中，服务端仍然执行快速ack,服务端然后往对端发送交互数据，此时系统探测到了这样一种交互行为，于是开启ping pong mode。服务端开启了ping pong mode之后，收到数据不会立马回复对端ack,而是在回复响应数据时候带上ack,这样减少了网络中的包量。但是如果服务端在延时ack时间都没有响应客户端的请求就可能出现短暂的响应延迟。</p><p><img src="https://s1.ax1x.com/2020/08/17/dmqAr6.png" alt="dmqAr6.png"></p><p><strong>nagle算法</strong></p><p>Nagle算法的<strong>基本定义</strong>是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</p><p>Nagle算法的规则（tcp_output.c文件里tcp_nagle_check函数注释）：</p><p>（1）如果包长度达到MSS，则允许发送；</p><p>（2）如果该包含有FIN，则允许发送；</p><p>（3）设置了TCP_NODELAY选项，则允许发送；</p><p>（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；</p><p>（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。</p><p>有了上面的知识铺垫，我们具体分析下客户端开启nagle,服务端处于delay ack 状态下，客户端不同大小数据请求下延时情况。</p><ol><li>当客户端请求数据小于mss大小</li></ol><p>假设客户端之前的数据已经全部被ack了，此时发送一个新的数据请求，小于mss,对端服务器在收到数据之后，不会立马回复ack,但是在delay ack超时之前能够回复响应数据，顺带就把ack发过去了，所以不会出现我们说的40ms延迟。</p><ol start="2"><li>客户端请求数据大于mss</li></ol><p>由于请求数据大于mss,一个包装不下这么多数据，tcp会将数据分成小包发送，在发送第一个小包之后，服务端延迟ack,同时由于数据不全，服务端不能立即响应，于是就在等待延迟ack超时，同时客户端这边开启了nagle，之前发送的数据包还没有被ack,待发送的数据包小于mss，于是也进入等待，这样一来双方都处于等待，进入了短暂的”死锁“。</p><p><strong>解决方案</strong></p><p>有了上面的分析，我们可以从两个方向来考虑如何解决40ms延迟。</p><ol><li><p>服务端关闭延迟ack ；<code>echo 1 &gt; /proc/sys/net/ipv4/tcp_no_delay_ack</code></p></li><li><p>客户端关闭nagle；通过设置<code>TCP_NODELAY</code>来实现</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tcp抓包发现服务端回复ack存在40ms左右延迟&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/17/dmqEqK.png&quot; alt=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>socket从创建到连接过程小结</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-08-08T02:40:45.000Z</published>
    <updated>2020-08-08T02:44:29.819Z</updated>
    
    <content type="html"><![CDATA[<p>分析了套接字创建到连接过程中，一些关键的函数调用以及数据结构，同时分析了connect()过程中tcp三次握手状态变化。</p><a id="more"></a><h3 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h3><h4 id="系统调用流程图"><a href="#系统调用流程图" class="headerlink" title="系统调用流程图"></a>系统调用流程图</h4><p><img src="https://s1.ax1x.com/2020/08/07/aW8ts0.png" alt="aW8ts0.png"></p><h4 id="sock-create"><a href="#sock-create" class="headerlink" title="sock_create()"></a>sock_create()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock_create(family, type, protocol, &amp;sock)</span><br></pre></td></tr></table></figure><p><strong>family</strong> </p><p>指定了协议族，比较常用的ipv4协议族对应AF_INET，PF_INET。</p><p>AF_INET 表示address_family, PF_INET 表示protocol family ，这两者的宏定义是相同的，对于BSD,是<strong>AF</strong>,对于POSIX是<strong>PF</strong>。</p><table><thead><tr><th>名称</th><th>含义</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>PF_UNIX,PF_LOCAL</td><td>本地通信</td><td>PF_X25</td><td>ITU-T X25 / ISO-8208协议</td></tr><tr><td>AF_INET,PF_INET</td><td>IPv4 Internet协议</td><td>PF_AX25</td><td>Amateur radio AX.25</td></tr><tr><td>PF_INET6</td><td>IPv6 Internet协议</td><td>PF_ATMPVC</td><td>原始ATM PVC访问</td></tr><tr><td>PF_IPX</td><td>IPX-Novell协议</td><td>PF_APPLETALK</td><td>Appletalk</td></tr><tr><td>PF_NETLINK</td><td>内核用户界面设备</td><td></td><td></td></tr></tbody></table><p><strong>type</strong></p><p>用于设置套接字通信的类型，主要有SOCKET_STREAM（流式套接字）、SOCK_DGRAM（数据包套接字）等。</p><p><strong>protocol</strong></p><p>protocol用于制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0。</p><p>因此对于一个面向对象的连接，创建一个套接字如下</p><p><code>int lfd=socket(AF_INET,SOCK_STREAM,0)</code>;</p><p>sock 类型是<code>struct socket</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">    socket_state        state;<span class="comment">//枚举类型 标识了当前socket的状态 eg. SS_CONNECTED, SS_DISCONNECTED</span></span><br><span class="line">    kmemcheck_bitfield_begin(type);</span><br><span class="line">    short           type;<span class="comment">//标识套接字类型 eg.SOCK_STREAM,SOCK_DGRAM</span></span><br><span class="line">    kmemcheck_bitfield_end(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> __<span class="title">rcu</span>  *<span class="title">wq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>     *<span class="title">file</span>;</span><span class="comment">//与套接字对应的文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     *<span class="title">sk</span>;</span><span class="comment">//指向代表下层协议(network layer)数据的sock结构</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>  *<span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="sock-alloc"><a href="#sock-alloc" class="headerlink" title="sock_alloc()"></a>sock_alloc()</h4><p>先分配socket<code>struct socket *sock_alloc(void)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *sock_alloc-allocate a socket</span></span><br><span class="line"><span class="comment"> *分配inode，socket 这两者是一一对应的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct socket *<span class="title">sock_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> * <span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">inode = new_inode(sock_mnt-&gt;mnt_sb);<span class="comment">//分配inode</span></span><br><span class="line">sock = SOCKET_I(inode);<span class="comment">//通过inode得到socket</span></span><br><span class="line"></span><br><span class="line">inode-&gt;i_mode = S_IFSOCK|S_IRWXUGO;</span><br><span class="line">inode-&gt;i_sock = <span class="number">1</span>;</span><br><span class="line">inode-&gt;i_uid = current-&gt;fsuid;</span><br><span class="line">inode-&gt;i_gid = current-&gt;fsgid;</span><br><span class="line"></span><br><span class="line">get_cpu_var(sockets_in_use)++;</span><br><span class="line">put_cpu_var(sockets_in_use);</span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="net-families-gt-create"><a href="#net-families-gt-create" class="headerlink" title="net_families-&gt;create()"></a>net_families-&gt;create()</h4><p>从全局net_families数组中根据下标<code>family</code>取到对应的<code>struct net_proto_family</code>结构pf,然后调用<code>create()</code>  对于ipv4协议而言，对应到<code>net/ipv4/Af_inet.c</code>的<code>inet_create()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((err = net_families[family]-&gt;create(sock, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_module_put;</span><br></pre></td></tr></table></figure><p><code>struct net_proto_family</code>定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> = &#123;</span></span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    .create = inet_create,</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>inet_create</strong></p><ol><li><p>先将struct socket的state设为SS_UNCONNECTED;</p></li><li><p>根据struct socket的type(eg.SOCK_STREAM), 遍历inetsw[type], 找到对应到protocol的结构体</p><p><code>struct inet_protosw</code>定义如下</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is used to register socket interfaces for IP protocols.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two fields form the lookup key.  */</span></span><br><span class="line"><span class="keyword">unsigned</span> short type;   <span class="comment">/* This is the 2nd argument to socket(2). */</span></span><br><span class="line"><span class="keyword">int</span> protocol; <span class="comment">/* This is the L4 protocol number.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">prot</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span>              capability; <span class="comment">/* Which (if any) capability do</span></span><br><span class="line"><span class="comment">      * we need to use this socket</span></span><br><span class="line"><span class="comment">      * interface?</span></span><br><span class="line"><span class="comment">                                      */</span></span><br><span class="line"><span class="keyword">char</span>             no_check;   <span class="comment">/* checksum on rcv/xmit/none? */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flags;      <span class="comment">/* See INET_PROTOSW_* below.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_create</span><span class="params">(struct socket *sock, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">    sock-&gt;state = SS_UNCONNECTED;<span class="comment">//1.</span></span><br><span class="line">    <span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">list_for_each_rcu(p, &amp;inetsw[sock-&gt;type]) &#123; <span class="comment">//2.inetsw是一个链表数组, key为SOCK_STREAM, SOCK_DGRAM, SOCK_RAW等等.</span></span><br><span class="line">answer = list_entry(p, struct inet_protosw, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;<span class="comment">//3.</span></span><br><span class="line">    sk = sk_alloc(PF_INET, GFP_KERNEL,answer_prot-&gt;slab_obj_size, answer_prot-&gt;slab);<span class="comment">//4.</span></span><br><span class="line">    inet = inet_sk(sk);<span class="comment">//5.</span></span><br><span class="line">    sock_init_data(sock, sk);<span class="comment">//6.</span></span><br><span class="line">   <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;init) &#123;</span><br><span class="line">err = sk-&gt;sk_prot-&gt;init(sk);<span class="comment">//7.</span></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">sk_common_release(sk);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>将”对应到protocol的结构体”的ops赋给struct socket结构的ops. <code>sock-&gt;ops = answer-&gt;ops;</code></p></li><li><p>调用sk_alloc, 分配网络子系统核心(net/core)的数据结构struct sock ( 记录family, protocol到sk_family, sk_prot成员 )</p></li><li><p>将struct sock强转为struct inet_sk(调用inet_sk)</p></li><li><p>调用sock_init_data(struct socket, struct sock)，用scoket 来初始化sock。</p></li><li><p>调用sk-&gt;sk_prot-&gt;init, 例如对于TCP, 指向net/ipv4/Tcp_ipv4.c的全局结构体struct proto tcp_port中的tcp_v4_init_sock, 此方法完成该socket在内核网络子系统TCP层的初始化:</p></li></ol><h4 id="sock-map-fd"><a href="#sock-map-fd" class="headerlink" title="sock_map_fd"></a>sock_map_fd</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/socket.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_map_fd</span><span class="params">(struct socket *sock, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fd = get_unused_fd_flags(flags);<span class="comment">//1.</span></span><br><span class="line">  ...</span><br><span class="line">  newfile = sock_alloc_file(sock, flags, <span class="literal">NULL</span>);<span class="comment">//2.</span></span><br><span class="line">  <span class="keyword">if</span> (likely(!IS_ERR(newfile))) &#123;</span><br><span class="line">    fd_install(fd, newfile);<span class="comment">//3.</span></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  sock_map_fd()主要用于对socket的<em>file指针初始化，经过sock_map_fd()操作后，socket就通过其</em>file指针与VFS管理的文件进行了关联，便可以进行文件的各种操作，如read、write、lseek。</p><p>sock_map_fd流程如下</p><ol><li><p>找到一个未使用的文件描述符fd。</p></li><li><p>为socket分配一个struct file实例。</p></li><li><p>建立fd到socket file的映射关系，并返回fd给上层。</p></li></ol><p>将struct socket的file设为struct file，struct file的private_data设为struct socket;这样struct socket和struct file便互相关联起来了.</p><p><img src="https://s1.ax1x.com/2020/08/07/aW8YMq.png" alt="aW8YMq.png"></p><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p><img src="C:%5CUsers%5Cdiliangdeng%5CPictures%5Cimage-20200807150150809.png" alt="image-20200807150150809"></p><p>bind()作用是给创建的套接字绑定地址，函数原型以及包含的头文件如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sockaddr 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">               <span class="keyword">sa_family_t</span> sa_family;<span class="comment">// 地址协议族</span></span><br><span class="line">               <span class="keyword">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//sockaddr_in </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    short            sin_family;       <span class="comment">// 2 bytes e.g. AF_INET, AF_INET6</span></span><br><span class="line">    <span class="keyword">unsigned</span> short   sin_port;    <span class="comment">// 2 bytes e.g. htons(3490)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">sin_addr</span>;</span>     <span class="comment">// 4 bytes see struct in_addr, below</span></span><br><span class="line">    <span class="keyword">char</span>             sin_zero[<span class="number">8</span>];     <span class="comment">// 8 bytes zero this if you want to</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bind()中的第二个参数addr类型为struct sockaddr,在实际的socket编程中，我们一般都是将特定类型地址转化为sockaddr，比如将ipv4中绑定地址一般如下操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">//地址格式描述</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">   servaddr.sin_family = AF_INET;  <span class="comment">//IPV4</span></span><br><span class="line">   servaddr.sin_port = htons(<span class="number">123</span>); <span class="comment">//端口号</span></span><br><span class="line">   servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//INADDR_ANY一般为0，内核选择IP地址</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(struct sockaddr_in)) == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"bind socket addr failed!\n"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>既有sockaddr,又有sockaddr_in，然后还要转化，看起来多此一举，其实不然，不同的协议族地址可能不一样(eg.ipv6就和ipv4不一样），sockaddr提供了一个统一的地址接口。</p><h4 id="sys-bind"><a href="#sys-bind" class="headerlink" title="sys_bind"></a>sys_bind</h4><p>与socket()一样，bind通过系统调用统一接口到了sys_bind</p><h4 id="sockfd-lookup-light"><a href="#sockfd-lookup-light" class="headerlink" title="sockfd_lookup_light"></a>sockfd_lookup_light</h4><p>sockfd_lookup_light通过fd来查找sock</p><ol><li>在当前进程的描述符中通过fd 找到struct file</li><li>通过<code>file-&gt;f_dentry-&gt;d_inode</code> 得到inode</li><li>通过 <code>SOCKET_I(inode)</code>得到sock</li></ol><p>这里具体看下如何通过inode得到sock。</p><p>SOCKET_I通过调用<code>container_of(inode, struct socket_alloc, vfs_inode)-&gt;socket</code>, vfs_inode类型为inode,作为socket_alloc的数据成员。</p><p>container_of的作用就是通过传入inode地址，inode地址作为socket_alloc的第二个数据成员，通过计算相对socket_alloc首地址的偏移，既可以获得socket_alloc地址，即socket地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">define <span class="title">container_of</span><span class="params">(ptr, type, member)</span> <span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> typeof( ((type *)<span class="number">0</span>)-&gt;member ) *__mptr = (ptr);</span></span></span><br><span class="line"><span class="function"><span class="params">        (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> struct socket_alloc </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>move_addr_to_kernel 将地址拷贝到内核空间</li><li>ops-&gt;bind; 这个是sys_bind最为重要的一步调用，在创建套接字时候，我们将sock-&gt;ops设定为了与协议类型相关的函数操作集，这里我们具体分析tcp,在TCP协议情况下inet_stream_ops中bind成员函数为inet_bind。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bind, <span class="keyword">int</span>, fd, struct sockaddr __user *, umyaddr, <span class="keyword">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (sock) &#123;</span><br><span class="line">err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</span><br><span class="line"><span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">err = security_socket_bind(sock,</span><br><span class="line">   (struct sockaddr *)&amp;address,</span><br><span class="line">   addrlen);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">      (struct sockaddr *)</span><br><span class="line">      &amp;address, addrlen);<span class="comment">//inet_bind</span></span><br><span class="line">&#125;</span><br><span class="line">fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="inet-bind"><a href="#inet-bind" class="headerlink" title="inet_bind"></a>inet_bind</h4><ol><li>做了一些检查，比如绑定地址的长度，协议族类型。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*地址长度检验*/</span></span><br><span class="line"><span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(struct sockaddr_in))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">/*bind地址中协议检查，必须是下面两种情况</span></span><br><span class="line"><span class="comment">* 1.绑定的地址协议为AF_INET</span></span><br><span class="line"><span class="comment">* 2.绑定协议为0（AF_UNSPEC）同时地址也为0</span></span><br><span class="line"><span class="comment">* 否则直接退出inet_bind ,返回地址不支持错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (addr-&gt;sin_family != AF_INET) &#123;</span><br><span class="line"><span class="comment">/* Compatibility games : accept AF_UNSPEC (mapped to AF_INET)</span></span><br><span class="line"><span class="comment"> * only if s_addr is INADDR_ANY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = -EAFNOSUPPORT;</span><br><span class="line"><span class="keyword">if</span> (addr-&gt;sin_family != AF_UNSPEC ||</span><br><span class="line">    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>inet_addr_type(net, addr-&gt;sin_addr.s_addr); 做了地址类型检查， 地址类型必须是本机，多播，组播中的一个，否则直接返回错误码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取根据IP地址得出地址类型</span></span><br><span class="line"><span class="comment">RTN_LOCAL 本机地址</span></span><br><span class="line"><span class="comment">RTN_MULTICAST 多播</span></span><br><span class="line"><span class="comment">RTN_BROADCAST 广播</span></span><br><span class="line"><span class="comment">RTN_UNICAST</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">chk_addr_ret = inet_addr_type(net, addr-&gt;sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">err = -EADDRNOTAVAIL;</span><br><span class="line"><span class="keyword">if</span> (!net-&gt;ipv4_sysctl_ip_nonlocal_bind &amp;&amp;</span><br><span class="line">    !(inet-&gt;freebind || inet-&gt;transparent) &amp;&amp;</span><br><span class="line">    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY) &amp;&amp;</span><br><span class="line">    chk_addr_ret != RTN_LOCAL &amp;&amp;</span><br><span class="line">    chk_addr_ret != RTN_MULTICAST &amp;&amp;</span><br><span class="line">    chk_addr_ret != RTN_BROADCAST)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure><ol start="3"><li>获取端口号，并且对保留端口做访问权限检查。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">err = -EACCES;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3.要绑定的端口小于1024时候，要求运行该应用程序的为超级权限</span></span><br><span class="line"><span class="comment">* 否则返回并报权限不运行的错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp;</span><br><span class="line">    !ns_capable(net-&gt;user_ns, CAP_NET_BIND_SERVICE))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure><ol start="4"><li>bind动作发生在TCP三次握手之前，此时TCP状态应该是CLOSE且没有绑定过其他端口</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;inet_num)</span><br><span class="line"><span class="keyword">goto</span> out_release_sock;</span><br></pre></td></tr></table></figure><ol start="5"><li>端口号能否被绑定检查,端口没有被使用返回0，否则返回非0。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">err = -EADDRINUSE;</span><br><span class="line"><span class="keyword">goto</span> out_release_sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>更新<code>sk_userlocks</code>标记，表明本地地址和端口已经绑定</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line"><span class="keyword">if</span> (inet-&gt;inet_rcv_saddr)</span><br><span class="line">sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;</span><br><span class="line"><span class="keyword">if</span> (snum)</span><br><span class="line">sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;</span><br><span class="line">inet-&gt;inet_sport = htons(inet-&gt;inet_num);<span class="comment">//端口绑定</span></span><br></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>客户端主动发起连接，调用connect</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>connect最后调用系统调用sys_connect</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_connect</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr __user *uservaddr, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="keyword">char</span> address[MAX_SOCK_ADDR];</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">sock = sockfd_lookup(fd, &amp;err);</span><br><span class="line"><span class="keyword">if</span> (!sock)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">err = move_addr_to_kernel(uservaddr, addrlen, address);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">err = sock-&gt;ops-&gt;<span class="built_in">connect</span>(sock, (struct sockaddr *) address, addrlen,</span><br><span class="line"> sock-&gt;file-&gt;f_flags);</span><br><span class="line">out_put:</span><br><span class="line">sockfd_put(sock);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找sock,将地址从用户空间拷贝内核空间，这些操作与bind()分析一样， 这里不再赘述，主要看下 <code>sock-&gt;ops-&gt;connect</code></p><p>对于ipv4这个family来说,type为<code>SOCK_STREAM，</code>sock-&gt;ops指向inet_stream_ops，sock-&gt;ops-&gt;connect指向inet_stream_ops的connect, 即<code>inet_stream_connect</code>.</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://s1.ax1x.com/2020/08/07/ahrMnO.png" alt="ahrMnO.png"></p><ol><li>调用ip_route_connect进行寻路, 取得struct rtable，目的是为了确定下一跳目的地址</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tmp = ip_route_connect(&amp;rt, nexthop, inet-&gt;saddr,</span><br><span class="line">       RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,</span><br><span class="line">       IPPROTO_TCP,</span><br><span class="line">       inet-&gt;sport, usin-&gt;sin_port, sk);</span><br><span class="line"><span class="keyword">if</span> (!inet-&gt;opt || !inet-&gt;opt-&gt;srr)</span><br><span class="line">daddr = rt-&gt;rt_dst;</span><br></pre></td></tr></table></figure><ol><li>设置套接字状态为SYN_SENT</li><li>调用<code>tcp_v4_hash_connect(sk)</code></li></ol><p>这一步的目的是绑定端口，并且将套接字插入到bind链表，哈希链表以port为关键字，将地址相同的串在一个链表上(哈希冲突)。</p><p>这一步之前source port可能还为0(对于client端调用socket后直接调用connect不经过bind的情况, source port为0).所以该方法会生成一个随机的source port, 赋给struct inet_sk的inet_sport成员</p><ol><li><code>ip_route_newports</code> 分配完端口后，再查一次路由</li><li>生成初始序列号ISN</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secure_tcp_sequence_number(inet-&gt;saddr,inet-&gt;daddr,inet-&gt;sport,usin-&gt;sin_port);</span><br></pre></td></tr></table></figure><ol><li><code>tcp_connect()</code>构造SYN，将连接数据包发送出去</li></ol><ul><li><code>buff = alloc_skb(MAX_TCP_HEADER + 15, sk-&gt;sk_allocation);</code> 分配skb</li><li><code>TCP_SKB_CB(buff)-&gt;flags = TCPCB_FLAG_SYN;</code>设置syn 标志</li><li><code>__skb_queue_tail(&amp;sk-&gt;sk_write_queue, buff);</code> 将构建好的skb添加到套接字对应的写队列</li><li><code>tcp_transmit_skb(sk, skb_clone(buff, GFP_KERNEL));</code>  tcp层实际的处理和传输过程</li><li><code>tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp-&gt;rto);</code>   设定syn超时重传</li></ul><blockquote><p>我们说connect() 调用时候发送SYN, 在返回之前回复对方ACK ,在代码中体现?</p></blockquote><p>客户端发送syn之后，阻塞在<code>inet_wait_for_connect()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">inet_wait_for_connect</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DEFINE_WAIT(wait);</span><br><span class="line"></span><br><span class="line">prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Basic assumption: if someone sets sk-&gt;sk_err, he _must_</span></span><br><span class="line"><span class="comment"> * change state of the socket from TCP_SYN_*.</span></span><br><span class="line"><span class="comment"> * Connect() does not allow to get error notifications</span></span><br><span class="line"><span class="comment"> * without closing the socket.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//循环检查状态变化</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">release_sock(sk);</span><br><span class="line">timeo = schedule_timeout(timeo);</span><br><span class="line">lock_sock(sk);</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current) || !timeo)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br><span class="line">finish_wait(sk-&gt;sk_sleep, &amp;wait);</span><br><span class="line"><span class="keyword">return</span> timeo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端在收到SYN+ACK之后，调用流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp_v4_rcv→tcp_v4_do_rcv→tcp_rcv_state_process→tcp_rcv_synsent_state_process</span><br></pre></td></tr></table></figure><p>在函数tcp_rcv_state_process中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TCP_SYN_SENT:</span><br><span class="line">        tp-&gt;rx_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">        tcp_mstamp_refresh(tp);</span><br><span class="line">        <span class="comment">//进入tcp_rcv_synsent_state_process处理</span></span><br><span class="line">        queued = tcp_rcv_synsent_state_process(sk, skb, th);</span><br><span class="line">        <span class="keyword">if</span> (queued &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> queued;</span><br><span class="line">        <span class="comment">/* Do step6 onward by hand. */</span></span><br><span class="line">        tcp_urg(sk, skb, th);</span><br><span class="line">        __kfree_skb(skb);</span><br><span class="line">        tcp_data_snd_check(sk);</span><br><span class="line">        retur</span><br></pre></td></tr></table></figure><p>在tcp_rcv_synsent_state_process中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查ACK的有效性</span></span><br><span class="line">tcp_ack(sk, skb, FLAG_SLOWPATH);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果ack有效,则完成连接，将状态兄TCP_SYN_SENT-&gt;TCP_ESTABLISHED</span></span><br><span class="line">tcp_finish_connect(sk, skb);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//发送ack</span></span><br><span class="line"> tcp_send_ack(sk);</span><br></pre></td></tr></table></figure><p>tcp_finish_connect将连接状态设为TCP_ESTABLISHED，然后唤醒之前阻塞在<code>inet_wait_for_connect()</code>  的进程，至此connet()完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_finish_connect</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    tcp_set_state(sk, TCP_ESTABLISHED); <span class="comment">/* 在这里设置为连接已建立的状态 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (! sock_flag(sk, SOCK_DEAD)) &#123;</span><br><span class="line">        sk-&gt;sk_state_change(sk); <span class="comment">/* 指向sock_def_wakeup，会唤醒调用connect()的进程，完成连接的建立 */</span></span><br><span class="line">        sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT); <span class="comment">/* 如果使用了异步通知，则发送SIGIO通知进程可写 */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/18609397/whats-the-difference-between-sockaddr-sockaddr-in-and-sockaddr-in6" target="_blank" rel="noopener"><a href="https://stackoverflow.com/questions/18609397/whats-the-difference-between-sockaddr-sockaddr-in-and-sockaddr-in6" target="_blank" rel="noopener">What’s the difference between sockaddr, sockaddr_in, and sockaddr_in6?</a></a></p><p><a href="https://vcpu.me/bind/" target="_blank" rel="noopener">bind</a></p><p><a href="https://johnhx.github.io/2017/05/11/LinuxKernel-Connect-flow/" target="_blank" rel="noopener">Linux内核网络子系统源码分析(2) – connect系统调用</a></p><p><a href="https://blog.csdn.net/zhangskd/article/details/45508569" target="_blank" rel="noopener">Socket层实现系列 - connect()的实现_zhangskd的专栏-CSDN博客_inet_csk_wait_for_connect</a></p><p><a href="https://e-mailky.github.io/2017-01-14-tcp-connect" target="_blank" rel="noopener">socket建立连接 sys_connect</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析了套接字创建到连接过程中，一些关键的函数调用以及数据结构，同时分析了connect()过程中tcp三次握手状态变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>网络协议栈收包过程小结</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-08-05T13:19:25.000Z</published>
    <updated>2020-08-08T02:47:57.119Z</updated>
    
    <content type="html"><![CDATA[<p>linux网络协议栈学习小结</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>下面的包分析基于下面的TCP/IP四层协议栈，内核代码基于2.6版本。</p><p><img src="https://s1.ax1x.com/2020/08/08/a42rFO.png" alt="a42rFO.png"></p><h3 id="发包过程"><a href="#发包过程" class="headerlink" title="发包过程"></a>发包过程</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层是数据包发送起始点， 应用进程通过套接字API发起写系统调用。对套接字做读写操作，和对普通文件做读写操作相似，在linux中万物皆是文件。</p><p>常用的写套接字API如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>send</code>,<code>write</code>,<code>writev</code>只能用于面向连接的套接字(SO_STREAM)。</p><p><code>writev()</code>可以指定一系列的缓冲区，收集要写的数据，使可以安排数据保存在多个缓冲区中，然后同时写出去，从而避免出现Nagle和延迟ACK算法的相互影响，起到类似”gather write”的效果。 </p><p><strong>struct iovec</strong>结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *iov_base; <span class="comment">/*基本地址指针，指向缓冲区*/</span></span><br><span class="line"><span class="keyword">size_t</span> iov_len; <span class="comment">/*指定缓冲区长度*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述的套接字API接口处理流程相似</p><ul><li>输入参数都是描述符，我们需要将<code>fd-&gt; struct sock</code>。</li><li>创建消息头部，套接字控制信息(uid,pid,…)</li></ul><p>无论我们通过<code>write</code>还是<code>sendmsg</code>等写操作，最后都会到<code>sock_senmsg()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">iocb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> <span class="title">siocb</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">init_sync_kiocb(&amp;iocb, <span class="literal">NULL</span>);</span><br><span class="line">iocb.<span class="keyword">private</span> = &amp;siocb;</span><br><span class="line">ret = __sock_sendmsg(&amp;iocb, sock, msg, <span class="built_in">size</span>);</span><br><span class="line"><span class="keyword">if</span> (-EIOCBQUEUED == ret)</span><br><span class="line">ret = wait_on_sync_kiocb(&amp;iocb);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__sock_sendmsg()做了一些安全检查之后，会调用协议相关的消息发送函数<code>sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size)</code>，协议相关的 操作集在套接字创建过程通过type,family初始化。举个例子，如果是一个TCP套接字，那么实际将调用tcp_sendmsg,如果是一个UDP套接字，将调用udp_sendmsg。</p><h4 id="套接字接口层"><a href="#套接字接口层" class="headerlink" title="套接字接口层"></a>套接字接口层</h4><p>我们在实际做网络通信过程中，一般需要经过这几个步骤</p><ul><li>通过<code>socket()</code>创建套接字</li><li><code>bind()</code>绑定套接字</li><li><code>listen()</code>监听套接字</li></ul><p>这里详细参考我的这篇文章   <a href="https://hustddl.com/2020/08/08/socket%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%B0%8F%E7%BB%93/#more" target="_blank" rel="noopener">socket从创建到连接过程小结</a></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>TCP 栈简要过程：</p><ol><li><p>tcp_sendmsg 函数会首先检查已经建立的 TCP connection 的状态，然后获取该连接的 MSS，开始 segement 发送流程。</p></li><li><p>构造 TCP 段的 playload：它在内核空间中创建该 packet 的 sk_buffer 数据结构的实例 skb，从 userspace buffer 中拷贝 packet 的数据到 skb 的 buffer。</p></li><li><p>构造 TCP header。</p></li><li><p>计算 TCP 校验和（checksum）和 顺序号 （sequence number）。 </p><p>TCP 校验和是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现 TCP 首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则 TCP 段会被直接丢弃。TCP 校验和覆盖 TCP 首部和 TCP 数据。</p></li><li><p>发到 IP 层处理：调用 IP handler 句柄 ip_queue_xmit，将 skb 传入 IP 处理流程。</p></li></ol><hr><p>具体到一些细节</p><p><strong>tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,size_t size)</strong></p><p>按照之前的分析，<strong>sock_sendmsg</strong>最终调用<strong>tcp_sendmsg</strong>,我们知道TCP是一个面向连接的协议，因此在发送数据之前，内核会检查TCP的连接状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wait for a connection to finish. */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT))</span><br><span class="line"><span class="keyword">if</span> ((err = sk_stream_wait_connect(sk, &amp;timeo)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br></pre></td></tr></table></figure><p>从上面的代码可以发现，如果连接尚未建立，不处于<strong>ESTABLISHED</strong>或者<strong>CLOSE_WAIT</strong>状态，那么进程进行睡眠，等待三次握手的完成。被动关闭方收到FIN,处于CLOSE_WAIT状态，此时处于半关闭状态，仍然可以发数据(不要错看成TIME-WAIT)了。</p><h5 id="tcp建立连接"><a href="#tcp建立连接" class="headerlink" title="tcp建立连接"></a>tcp建立连接</h5><p>在传输数据之前，tcp作为面向连接的协议，需要先通过三次握手来建立连接。篇文章是很好的 <a href="http://www.leviathan.vip/2018/08/09/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-TCP%E5%8D%8F%E8%AE%AE-1/" target="_blank" rel="noopener">参考</a></p><p><img src="http://www.leviathan.vip/2018/08/09/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-TCP%E5%8D%8F%E8%AE%AE-1/tcp_3.png" alt="Imgur"></p><h5 id="tcp-senmsg"><a href="#tcp-senmsg" class="headerlink" title="tcp_senmsg"></a>tcp_senmsg</h5><p>一旦连接建立好，<code>tcp_sendmsg()</code>先做了发包之前的准备工作，比如获取<code>mss(maxium segment size)</code>,mss规定了一次发送的最大数据大小，mss的值一般为1460byte,因为数据链路层的MTU一般为1500byte,mss加上tcp，ip头部即得到MTU。</p><p>具体到发送数据，这里<strong>第一次涉及到用户空间数据到内核空间的拷贝</strong>， 内核先分配<code>struct sk_buff</code>。 如果skb的线性数据区还有剩余空间，就复制用户进程数据到线性数据区中,如果线性区域使用完，就使用分页区域， 通过<code>skb copy to page</code>拷贝用户空间的数据到skb的分页中，同时计算校验和。</p><h5 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h5><p>这里看下sk_buff中线性区域和非线性区域具体细节。</p><p>有四个指针，标识线性区域，（head,end)表示分配的缓存范围，(data,tail)表示实际数据的范围。head指针和end指针指向的位置一直都不变，对于数据的变化和协议信息的添加都是通过data指针和tail指针的改变来表现的。</p><p>sk_buff中有几个长度很容易搞混，这里梳理一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sk_buff-&gt;data_len ;分片中数据的长度，即是分片结构体中page指向的数据区长度</span><br><span class="line">sk_buff-&gt;len;当前缓冲区中数据块的大小的总长度,即线性缓存长度+data_len</span><br><span class="line">sk_buff-&gt;truelen;  缓冲区的总长度，包括sk_buff结构和数据部分 即 sk_buff-&gt;len+sizeof(sk_buff)</span><br></pre></td></tr></table></figure><p>下面的图大致描述了sk_buff结构</p><p><img src="https://s1.ax1x.com/2020/07/13/UYKpCt.png" alt="UYKpCt.png"></p><h5 id="tcp-transmit-skbs"><a href="#tcp-transmit-skbs" class="headerlink" title="tcp_transmit_skbs"></a><strong>tcp_transmit_skbs</strong></h5><p><strong>tcp_sendmsg</strong>最终通过调用<code>tcp_transmit_skb</code> 将数据包传到IP层。这里面主要做了这几件事情。首先，sk_buff是没有头部信息的，我们需要自己构造TCP头部，包含了源端口，目的端口，序列号等。与头部相关的数据结构为<code>struct scphdr</code>,定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line">__u16source;</span><br><span class="line">__u16dest;</span><br><span class="line">__u32seq;</span><br><span class="line">__u32ack_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LITTLE_ENDIAN_BITFIELD)</span></span><br><span class="line">__u16res1:<span class="number">4</span>,</span><br><span class="line">doff:<span class="number">4</span>,</span><br><span class="line">fin:<span class="number">1</span>,</span><br><span class="line">syn:<span class="number">1</span>,</span><br><span class="line">rst:<span class="number">1</span>,</span><br><span class="line">psh:<span class="number">1</span>,</span><br><span class="line">ack:<span class="number">1</span>,</span><br><span class="line">urg:<span class="number">1</span>,</span><br><span class="line">ece:<span class="number">1</span>,</span><br><span class="line">cwr:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__BIG_ENDIAN_BITFIELD)</span></span><br><span class="line">__u16doff:<span class="number">4</span>,</span><br><span class="line">res1:<span class="number">4</span>,</span><br><span class="line">cwr:<span class="number">1</span>,</span><br><span class="line">ece:<span class="number">1</span>,</span><br><span class="line">urg:<span class="number">1</span>,</span><br><span class="line">ack:<span class="number">1</span>,</span><br><span class="line">psh:<span class="number">1</span>,</span><br><span class="line">rst:<span class="number">1</span>,</span><br><span class="line">syn:<span class="number">1</span>,</span><br><span class="line">fin:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span><span class="meta-string">"Adjust your &lt;asm/byteorder.h&gt; defines"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__u16window;</span><br><span class="line">__u16check;</span><br><span class="line">__u16urg_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现结构体的布局和大小端是有关系的，但是只涉及到标志位。</p><h5 id="字节序和比特序"><a href="#字节序和比特序" class="headerlink" title="字节序和比特序"></a>字节序和比特序</h5><p>先问自己一个问题</p><blockquote><p> 上述代码如果不添加条件编译语句，为什么不具有移植性?</p></blockquote><p>字节序的最小单位是1个字节，位域的最小单位是一个位域字段。</p><p>位域，也就是变量后面跟上冒号接数字表示这个变量占几个比特位的这种字段，比如：__u16    res1:4这表示ihl只占用了4个比特位。由于位域并不固定几个比特位，所以系统没法提供基于位域的大小端转换函数(htons,htonl.etc)。</p><p>之所以offset以及FIN等标志位要按照大端，小端字节序判断，就是为了使得主机无论是大端还是小端，offset相对fin标志位总是处于内存低地址处。</p><p><a href="https://yizhi.ren/2016/11/14/bitorder/" target="_blank" rel="noopener">位域</a></p><p>在<code>tcp_transmit_skb</code> 中实际填充tcp头部的过程如下，将seq,ack_seq做了主机字节序到网络字节序的转化。计算tcp头部检验和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">th-&gt;source= inet-&gt;sport;</span><br><span class="line">th-&gt;dest= inet-&gt;dport;</span><br><span class="line">th-&gt;seq= htonl(tcb-&gt;seq);</span><br><span class="line">th-&gt;ack_seq= htonl(tp-&gt;rcv_nxt);</span><br><span class="line">th-&gt;check= <span class="number">0</span>;</span><br><span class="line">th-&gt;urg_ptr= <span class="number">0</span>;</span><br><span class="line">tp-&gt;af_specific-&gt;send_check(sk, th, skb-&gt;len, skb);<span class="comment">// 计算tcp头部校验和</span></span><br></pre></td></tr></table></figure><p>具体看下检验和是如何计算的，发现除了用到tcp头部的信息，还有用到发送端，接收端的ip地址，这么做的目的是因为TCP头部不包含这些信息，为了提高检验能力，我们在计算checksum时，人为的加上一个”伪首部”，伪首部并不会在网络中传输。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_v4_send_check</span><span class="params">(struct sock *sk, struct tcphdr *th, <span class="keyword">int</span> len,struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_HW) &#123;</span><br><span class="line">th-&gt;check = ~tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr, <span class="number">0</span>);</span><br><span class="line">skb-&gt;csum = offsetof(struct tcphdr, check);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">th-&gt;check = tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr,</span><br><span class="line"> csum_partial((<span class="keyword">char</span> *)th,</span><br><span class="line">      th-&gt;doff &lt;&lt; <span class="number">2</span>,</span><br><span class="line">      skb-&gt;csum));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过调用<code>queue_xmit</code>将待发送数据添加到待发送队列。 发送队列的具体位置如下图</p><img src="https://user-gold-cdn.xitu.io/2019/4/19/16a35787afe2efd7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="消息发送" style="zoom:80%;" /><h4 id="IP层"><a href="#IP层" class="headerlink" title="IP层"></a>IP层</h4><p>对于单播发包，函数调用的流程图如下：</p><p><img src="https://s1.ax1x.com/2020/08/05/ayf6uF.png" alt="ayf6uF.png"></p><p>上图可以看到，当 L4 层有数据包待发送时，对于TCP包它将调用<code>ip_queue_xmit</code>它们将这些包交由<code>NETFILTER（ LOLACL_OUT）</code>处理后，然后交给 dst_output，这会根据是多播或单播选择合适的发送函数。如果是单播，它会调用 ip_output()，然后是 <code>ip_finish_output()</code>，这个函数主要是检查待发送的数据包大小是否超过 MTU，如果是，则要首先调用 <code>ip_fragment()</code>将其分片，然后再传给 <code>ip_finish_output2()</code>,由它交给链路层处理了。  </p><p>IP层在TCP数据包的基础上，主要做下面几件事情</p><ul><li>构建IP头部</li><li>路由查询以及维护TTL(time to live)</li><li>包分片</li><li>Netfilter与iptabels做防火墙过滤</li></ul><p>如果数据包发送的目的端是本机应用程序，那么数据包将不经过底层协议栈，直接到接收方的TCP层。</p><h5 id="分片细节"><a href="#分片细节" class="headerlink" title="分片细节"></a><strong>分片细节</strong></h5><p>总的思路就是当L4层传过来的包大于MTU,通过循环，每次分配一个skb，然后将原来skb里面的IP头部部分数据拷贝到新分配的skb中，不同分片的标识号是一样的，不同之处在分片中起始数据相对原始报文的偏移，以及<code>MF(more fregment)</code>等一些标志位。</p><p>这里主要关注不同分片IP头部中offset如何设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-2.6.11\net\ipv4\ip_output.c*/</span></span><br><span class="line"><span class="comment">//ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff*)) slow_path:</span></span><br><span class="line">left = skb-&gt;len - hlen;<span class="comment">//待分片长度</span></span><br><span class="line">offset = (ntohs(iph-&gt;frag_off) &amp; IP_OFFSET) &lt;&lt; <span class="number">3</span>;<span class="comment">//从待分片报文提取offset</span></span><br><span class="line"><span class="comment">//循环分片</span></span><br><span class="line"><span class="keyword">while</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    len=left;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; mtu) len = mtu;</span><br><span class="line">    <span class="comment">//分配skb结构体,以及做一些填充工作</span></span><br><span class="line">    skb2 = alloc_skb(len+hlen+ll_rs, GFP_ATOMIC)</span><br><span class="line">    iph = skb2-&gt;nh.iph;</span><br><span class="line">    iph-&gt;frag_off = htons((offset &gt;&gt; <span class="number">3</span>));<span class="comment">//设置offset</span></span><br><span class="line">    offset += len;<span class="comment">//更新offset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ip_queue_xmit</strong></p><p>tcp层最中通过<code>tp-&gt;af_specific-&gt;queue_xmit(skb, 0);</code>将数据包传到了IP层，具体到TCP协议，就是调用<code>ip_queue_xmit</code></p><ul><li>调用<code>__sk_dst_check</code>对路由信息做检查</li><li>调用<code>ip_route_output_flow</code> ,这里是实际做路由计算的点，调用<code>__ip_route_output_key</code>来查找一条路径，使用<code>struct flowi</code>来记录路由查询信息，首先从缓存中查找，如果没找到就从FIB里面找(Forwarding Information Base)</li></ul><p>在做路由的过程中，可能会有下面几种可能</p><ul><li>包继续forwarded,  到ip_forward</li><li>包路由失败，不能解析，到ip_output </li><li>包路由解析成功，到dev_queue_xmit</li></ul><p>假设我们成功做了路由解析，找到了一条到目的端路径，那么就通过<code>dev_queue_xmit</code>到了数据链路层。</p><h5 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a><strong>Netfilter</strong></h5><p>在数据流中什么位置(过滤点)对数据包做什么操作(规则)。</p><ol><li>过滤点(chain)，输入，输出，转发，路由前，路由后</li><li>过滤规则: <ul><li>filter</li><li>nat</li><li>magle </li></ul></li></ol><p><img src="https://img2018.cnblogs.com/i-beta/729011/202002/729011-20200206184522753-754025474.png" alt=""></p><ol><li>当数据包从物理层和数据链路层传输过来，如果数据包是访问Linux主机本身。则经过PRE_ROUTING和LOCAL_IN钩子函数，到达传输层和应用层。</li><li>当数据包从物理层和数据链路层传输过来，如果数据包需要转发，则经过PRE_ROUTING、FORWARD和POST_ROUTING三个钩子函数。</li><li>当数据包从Linux主机本身向外发送数据包，要经过LOCAL_OUT和POST_ROUTING钩子函数。</li></ol><p>以发数据为例，本地产生的数据经过HOOK函数<code>NF_IP_LOCAL_OUT</code> 处理后，进行路由选择处理，然后经过<code>NF_IP_POST_ROUTING</code>处理后发送出去。</p><h5 id="hook原理"><a href="#hook原理" class="headerlink" title="hook原理"></a>hook原理</h5><p>所有的回调函数都注册在二维数组全局变量<code>struct list_head nf_hooks[NFPROTO_NUMPROTO][NF_MAX_HOOKS] __read_mostly;</code>中。。数组的第一个维度是注册回调函数的协议族，第二个维度是注册回调函数的hook点，也就是每一个协议族的每一个hook点都是一个双向链表连接的一组回调函数。</p><p>当代码执行到HOOK点根据协议类型， HOOK点编号，来遍历执行对应链表所有注册的回调函数，hook点回调函数处理完毕并允许下一步逻辑执行时,<code>okfn</code>被执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NF_HOOK(pf, hook, skb, indev, outdev, okfn)</span><br></pre></td></tr></table></figure><p><a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">深入理解 iptables 和 netfilter 架构</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-ntflt/index.html" target="_blank" rel="noopener">Linux Netfilter实现机制和扩展技术</a></p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层负责将ip层的数据加上包头，发送给网卡。</p><p><strong>dev_queue_xmit</strong></p><p>在这个函数中，一开始通过屏蔽所有的软中断(buttom-half)来获得设备的队列锁，接着调用<code>qdisc_run()</code>检查设备是否数据包需要传输，如果设备忙，那么该函数将再次在软中断中被调用。<code>qdisc_restart</code>获取设备的<code>xmit</code>锁，如果成功就调用<code>dev-&gt;hard_start_xmit</code>来完成最终的数据包传输，这个调用是和具体的设备有关系。一旦网卡完成报文发送，将产生中断通知 CPU，然后驱动层中的中断处理程序就可以删除保存的 skb 了。</p><h5 id="网卡中断收发包机制"><a href="#网卡中断收发包机制" class="headerlink" title="网卡中断收发包机制"></a>网卡中断收发包机制</h5><p>一般的当网卡有数据到来，通过产生一个硬件中断来通知CPU处理，在运行中断服务历程(ISR)时候，将屏蔽所有中断，也就意味着在执行硬件中断服务时候，不能被抢占，如果中断服务处理的任务比较轻，比如响应键盘等，这个是没有问题的。但是，网卡的中断需要处理的任务是很重的，比如说分配缓存结构体<code>sk_buff</code>,将接收数据拷贝到<code>sk_buff</code>等等，中断服务在处理这些任务时候占用了大量的CPU时间，导致不能及时相应其他的中断。</p><p>为了解决上述的问题，linux将中断的处理分为两个步骤top-half,buttom-half。其主要区别就在于上半部分执行的时候禁止一些或者全部中断，下半部分执行期间中断是打开的，可以响应所有中断。上半部分一定运行在中断上下文中，下半部分有很多种实现方式，根据不同的实现方式可能运行在中断上下文中，也可能运行在任务(process)上下文中。上半部分实际响应<code>request_irq()</code>，下半部分推迟实现，以软中断为例，在上半部分硬件中断返回后标记，然后触发软中断。(这一块具体可以参考《内核设计与实现》第八章)</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>下图总结了数据从用户态拷贝到内核，然后经过内核协议栈到最后网卡发送的整个流程。</p><p><img src="http://www.uml.org.cn/embeded/images/201604141011.png" alt="img"></p><h4 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h4><p><code>struct inet_sock</code>是INET域专用的一个socket表示，它是在struct sock的基础上进行的扩展，在基本socket的属性已具备的基础上，struct inet_sock提供了INET域专有的一些属性，比如TTL，组播列表，IP地址，端口等。</p><h5 id="网卡多队列"><a href="#网卡多队列" class="headerlink" title="网卡多队列"></a>网卡多队列</h5><p>概念：一张网卡具有多个接收队列</p><p>解决问题</p><p>每个cpu有一个软中断线程对应网卡收包，当网卡流量特别大情况下，就会导致cpu负载高，性能存在瓶颈；</p><p>工作原理</p><p>网卡多任务队列将收到的包根据四元组信息做哈希运算，然后放到多队列其中一个，之后该连接所有的包都将经过相同队列，每个队列对应不同cpu的软中断，这样就实现了网卡收包的负载均衡，避免了某些cpu负载特别高。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/aiwz/p/6333235.html" target="_blank" rel="noopener">tcp_sendmsg</a></p><p><a href="https://wiki.linuxfoundation.org/networking/kernel_flow#transmission_path" target="_blank" rel="noopener">transmission_path</a></p><p><a href="https://www.slideshare.net/hugolu/the-linux-networking-architecture" target="_blank" rel="noopener">linux网络架构</a></p><p>《understading linux kernel internals》</p><p><a href="http://www.uml.org.cn/embeded/2016041410.asp?artid=17878" target="_blank" rel="noopener"> <strong>Linux 网络栈</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux网络协议栈学习小结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>并发</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-08-05T13:17:21.000Z</published>
    <updated>2020-08-08T02:17:12.819Z</updated>
    
    <content type="html"><![CDATA[<p>《OSTEP》线程并发小结</p><a id="more"></a><h4 id="理解多线程为什么会有竞争状态问题"><a href="#理解多线程为什么会有竞争状态问题" class="headerlink" title="理解多线程为什么会有竞争状态问题"></a>理解多线程为什么会有竞争状态问题</h4><p>多线程对共享资源访问，可能不是原子操作，导致不确定结果。</p><h4 id="条件量使用"><a href="#条件量使用" class="headerlink" title="条件量使用"></a>条件量使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>wait 操作传入参数除了条件变量还有锁，这样做的目的是为了把进程休眠同时释放锁。否则其他线程就没法获得锁，唤醒休眠线程。</p><p>下面代码做线程之间同步存在什么问题</p><ol><li>spin 忙等待浪费cpu</li></ol><p>但是这个能够实现线程之间同步操作么?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局标志变量</span></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//thread A</span></span><br><span class="line"><span class="keyword">while</span>(flag==<span class="number">0</span>); <span class="comment">//spin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//thread B singal</span></span><br><span class="line">flag=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="锁的设计"><a href="#锁的设计" class="headerlink" title="锁的设计"></a>锁的设计</h4><p>在设计锁之前，有几个指标能够来衡量设计方案的好坏。</p><ol><li><p>能否实现互斥</p></li><li><p>公平性(防止饥饿）</p></li><li><p>实现锁带来的额外负担</p></li></ol><p>最直接的想法是通过关闭中断来实现互斥，竞态条件下执行结果的不稳定，就是因为线程执行过程中被打断，调度。我们通过关闭中断，就能够实现对资源的互斥访问，但是这个在实际情况不太可能实现(多CPU,以及关闭中断带来的巨大风险)。</p><h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p>通过硬件支持的同步原语来实现互斥，首先我们看一个没有原子操作的互斥锁方案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span> <span class="keyword">int</span> flag; &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">mutex-&gt;flag = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>);<span class="comment">// TEST the flag spin-wait (do nothing)</span></span><br><span class="line">mutex-&gt;flag = <span class="number">1</span>;<span class="comment">// now SET it!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>上述方案的问题在于检查flag和设置flag不是原子操作，可能存在一种情况线程A执行完while()然后被调度，导致两个线程都获得锁。</p><p>改进方案如下</p><p>CAS（compare and swap）一种原子操作，</p><p>bool CAS(V, A,B) // 检查现有V 是否与A== 如果== 将V设置为B 同时返回true</p><p><strong>自旋锁伪码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CAS（compare <span class="keyword">and</span> swap）一种原子操作，</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAS</span><span class="params">(V, A,B)</span> <span class="comment">// 检查现有V 是否与A== 如果==  将V设置为B 同时返回true</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">自旋锁伪码实现</span><br><span class="line"><span class="keyword">bool</span> flag =<span class="literal">false</span>; <span class="comment">//锁为true 表示被占用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!CAS(flag,<span class="literal">false</span>,<span class="literal">true</span>));</span><br><span class="line"><span class="comment">//do-something</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//release lock</span></span><br><span class="line">flag=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>自旋锁虽然能够实现对临界区的互斥访问，但是带来了性能问题，spin通过忙等待形式去获取锁，导致了CPU资源的浪费。</p><p>比如场景：单核cpu运行多个线程</p><p>线程1获得lock进入临界区,然后被打断，线程2被调度，一直自旋等待锁被释放。</p><h5 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h5><p>针对上述问题，一种解决方法是通过主动放弃CPU，当线程发现锁被占用，主动将自己的状态由RUNNING-&gt;READY， 避免了自旋等待占用CPU。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!CAS(flag,<span class="literal">false</span>,<span class="literal">true</span>)) <span class="built_in">yield</span>();</span><br></pre></td></tr></table></figure><p>yield 带来的问题</p><ol><li><p>大量的上下文切换操作</p></li><li><p>仍然没有解决饥饿问题</p></li></ol><h5 id="sleep队列"><a href="#sleep队列" class="headerlink" title="sleep队列"></a>sleep队列</h5><p>无论自旋，还是yield， 调度器的选择很多，导致了资源的浪费。如果线程发现自己暂时不能获取锁，将自己休眠，就带来了效率提升。</p><p>下面实现代码还是很巧妙的</p><ul><li>guard作用: 用于自旋等待变量</li></ul><p>相比于自旋等待整个临界区，gaurd的获取和释放间隔很短；eg.多核CPU, 当一个进程A拿到gaurd,然后另一个进程B被调度，此时B就拿不到gaurd，自旋等待，但是由于A临界区代码很短，很快A就会释放gaurd.</p><ul><li>unlock()中， 唤醒线程之后，没有将flag设置为0</li></ul><p>这么做的原因是线程被唤醒之后，可以看作是从park（）返回，此时线程没有拿到guard,锁没有释放就直接传递给了被唤醒线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">int</span> guard;</span><br><span class="line"><span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">m-&gt;flag= <span class="number">0</span>;</span><br><span class="line">m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line"><span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired</span></span><br><span class="line">m-&gt;guard = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">queue_add(m-&gt;q, gettid());</span><br><span class="line">m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">park(); <span class="comment">//线程休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line"><span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock (for next thread!)</span></span><br><span class="line">m-&gt;guard = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="基于锁的数据结构"><a href="#基于锁的数据结构" class="headerlink" title="基于锁的数据结构"></a>基于锁的数据结构</h4><h5 id="并发链表设计"><a href="#并发链表设计" class="headerlink" title="并发链表设计"></a>并发链表设计</h5><p>关键在于数据结构的定义，节点如何定义(int, node*) ，链表怎么定义(锁+链表头)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic node structure</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basic list structure (one used per list)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">node_t</span> * head;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Init</span><span class="params">(<span class="keyword">list_t</span> * L)</span> </span>&#123;</span><br><span class="line">    L-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_init(&amp;L-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> * L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> * <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>)); <span class="comment">//先分配节点，只有在更新全局资源时候加锁，而不是一上来就全部加锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"malloc"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// fail</span></span><br><span class="line">    &#125;</span><br><span class="line">pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">    L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表查找需要加锁么? 不涉及到全局变量的修改，但是如果不加锁，一个线程在修改正在查找的链表，也会导致race condition</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Lookup</span><span class="params">(<span class="keyword">list_t</span> * L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">node_t</span> * curr = L-&gt;head;</span><br><span class="line">    <span class="keyword">int</span> rv=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line">            rv=<span class="number">0</span>;<span class="comment">//返回0 表示找到</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rv;  <span class="comment">// faulure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="并发哈希表"><a href="#并发哈希表" class="headerlink" title="并发哈希表"></a>并发哈希表</h5><p>有了这个基础，设计并发哈希表就很简单，通过拉链方法来避免哈希冲突</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUCKETS (101)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hash_Init</span><span class="params">(<span class="keyword">hash_t</span> * H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUCKETS; i++) &#123;</span><br><span class="line">        List_Init(&amp;H-&gt;lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Insert</span><span class="params">(<span class="keyword">hash_t</span> * H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Lookup</span><span class="params">(<span class="keyword">hash_t</span> * H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Lookup(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><blockquote><p>什么是信号量?</p><p>信号量和条件变量区别</p></blockquote><p>信号量用来做lock,也能够用来做条件变量，关键在于信号量的初始化。</p><p>信号量=变量+操作</p><p><strong>信号量操作伪码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *s)</span> </span>&#123;</span><br><span class="line">decrement the value of semaphore s by one</span><br><span class="line">wait <span class="keyword">if</span> value of semaphore s is negative</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *s)</span> </span>&#123;</span><br><span class="line">increment the value of semaphore s by one</span><br><span class="line"><span class="keyword">if</span> there are one <span class="keyword">or</span> more threads waiting, wake one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号量做二元锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> m;</span><br><span class="line">sem_init(&amp;m, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// initialize semaphore to 1</span></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line"><span class="comment">// critical section here</span></span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure><p><strong>信号量做条件变量</strong></p><p>下面代码目的是同步父子进程，父进程等待子进程结束。</p><p>注意条件变量被初始化为0，分两个情况考虑，如果子进程被创建之后先执行，sem_post将信号量+1,父进程执行sem_wait正常返回；如果父进程先执行，sem-1小于0，父进程被挂起，子进程执行，将sem+1，然后唤醒父进程。 所以符合我们预定执行顺序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">sem_post(&amp;s); <span class="comment">// signal here: child is done</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> c;</span><br><span class="line">Pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">sem_wait(&amp;s); <span class="comment">// wait here for child</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>允许多个读，一个写，第一个读者自动获得写锁，最后一个读锁释放，写锁也释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">sem_t</span> lock;</span><br><span class="line">    <span class="keyword">sem_t</span> <span class="built_in">write</span>;</span><br><span class="line">    <span class="keyword">int</span> readers;</span><br><span class="line">&#125; rw_lock;</span><br><span class="line"></span><br><span class="line">init(rw_lock*m)&#123;</span><br><span class="line">    sem_init(m-&gt;lock,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    sem_init(m-&gt;<span class="built_in">write</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    m-&gt;readers=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_acquire_read</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_wait(m-&gt;lock);</span><br><span class="line">    m-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span>(m-&gt;readers==<span class="number">1</span>) sem_wait(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">    sem_post(m-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_release_read</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_wait(m-&gt;lock);</span><br><span class="line">    m-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span>(m-&gt;readers==<span class="number">0</span>) sem_post(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">    sem_post(m-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_acquire_write</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_wait(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_acquire_write</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_post(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OSTEP》线程并发小结&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OSTEP" scheme="http://yoursite.com/tags/OSTEP/"/>
    
  </entry>
  
  <entry>
    <title>内存虚拟化</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-08-01T01:55:22.000Z</published>
    <updated>2020-08-03T15:49:09.669Z</updated>
    
    <content type="html"><![CDATA[<p>《OSTEP》 内存虚拟化部分小结</p><a id="more"></a><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><blockquote><p>为什么引入了虚拟地址?</p></blockquote><ul><li>使得编程简单，每个应用进程有自己很大一片的地址空间，不用担心代码,变量存放到哪里</li><li>提供了进程之间的保护和隔离；如果我们直接操控物理内存，那么很可能由于进程一个不小心override导致其他进程崩溃</li></ul><p>举个例子两个进程A,B 都有自己的地址空间，eg. 对0x100访问，由于虚拟地址的映射他们对应的物理地址不同。</p><blockquote><p>设计一套虚拟内存需要满足满足那些目标?</p></blockquote><ol><li><p>透明； 对于编程者而言，我们应该是感知不到虚拟地址到物理地址之间的转化，操作系统和硬件在后面帮我们做了地址转化的这些工作</p></li><li><p>高效； 引入虚拟内存，空间角度上来看使用额外很多的内存来存储辅助数据结构，时间上不能导致程序运行变慢</p></li><li><p><strong>保护/隔离</strong>；这个我觉得是最为重要的，程序装载到内存中不能够影响到其他进程。</p><p>具体来看，虚拟内存实现机制，分段，分页下如何做进程间保护?</p></li></ol><h4 id="简单地址翻译"><a href="#简单地址翻译" class="headerlink" title="简单地址翻译"></a>简单地址翻译</h4><p>作者先做了一些假设，对虚拟内存系统设计做了一些简化，然后慢慢放宽条件，逐渐模拟一个真实场景下的虚拟内存系统。这样能够让读者循序渐进体会到系统设计面临的问题，然后慢慢引入新的方案来改进。</p><p> 一开始作者假设</p><ol><li>虚拟地址空间连续存放到物理内存</li><li>地址空间大小不超过物理内存&amp;&amp;每个进程地址空间相同</li></ol><h5 id="硬件支持地址翻译"><a href="#硬件支持地址翻译" class="headerlink" title="硬件支持地址翻译"></a>硬件支持地址翻译</h5><p>在上述假设下，有了基于硬件支持的动态重定位来做地址翻译通过硬件寄存器支持 base+limit </p><p>地址转化： <code>physical address = virtual address + base</code></p><p>limit用来做权限保护，如果虚拟地址超出了limit，程序将终止。</p><p>之前经常听到的MMU,用来做地址转化的硬件单元，这里提到的base,limit寄存器就是MMU的一部分，当然后面为了做更加复杂的地址翻译，MMU还有一些其他硬件的支持。</p><p>从操作系统角度，基于上述虚拟内存的实现方案，有几个问题要解决</p><ul><li>进程创建时，分配与地址空间对应的物理内存</li><li>当进程结束时，回收内存</li><li>进程切换，上下文保存；这里只需要保存一对base-limit寄存器</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>base+bound 的地址转化方案</p><p><strong>优点</strong></p><ul><li><p>在硬件支持下起来很高效快速</p></li><li><p>提供了进程间的保护隔离</p></li></ul><p><strong>缺点</strong></p><p>- 进程空间的整个映射到内存导致了内部碎片(heap,stack)</p><h4 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h4><p>基于单个base-limit寄存器将整个地址空间存到了内存造成了内存的浪费，我们分析主要的原因在于，stack,和heap的不确定，基于此，我们为什么不能够在单对寄存器的基础上，对code,data,stack,heap 都分配一对寄存器</p><p><img src="https://s1.ax1x.com/2020/07/31/a1UDsg.png" alt="a1UDsg.png"></p><p>我们经常见到的段错误(segment fault)就是访问非法地址，超出了bound的范围。</p><p>段表的引入带来了一个问题，如何确定访问哪一个段对应的寄存器?</p><p>显示的做法时用虚拟地址前几个bit来标识，如下图</p><p><img src="https://s1.ax1x.com/2020/07/31/a1Uwz8.png" alt="a1Uwz8.png"></p><p>分段机制下地址转化伪码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get top 2 bits of 14-bit VA</span></span><br><span class="line"><span class="comment">//Bounds[] 段表</span></span><br><span class="line">Segment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT <span class="comment">//确定是哪一个段</span></span><br><span class="line"><span class="comment">// now get offset</span></span><br><span class="line">Offset= VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"><span class="keyword">if</span> (Offset &gt;= Bounds[Segment])<span class="comment">//边界检查</span></span><br><span class="line">RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PhysAddr = Base[Segment] + Offset</span><br><span class="line">Register = AccessMemory(PhysAddr)</span><br></pre></td></tr></table></figure><p>按段加载还有一个好处使得段共享成为可能，比如将代码段设为只读，进程仍然认为访问的是私有地址空间，这样也不会破坏进程间的隔离。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>好处：</p><ul><li><p>减少了内部碎片,内存浪费</p></li><li><p>代码段等可以共享</p></li></ul><p>问题：</p><ul><li><p>大小不一的段可能导致外部碎片</p></li><li><p>内存不能做到按需分配</p></li></ul><p>产生外部碎片的原因在于，之前按照整个地址空间加载，并且进程地址空间大小一致，这样就可以将内存看作是一个大的数组，每次分配都是一个slot单位，现在按照段分配，虽然避免了内部碎片产生，但是由于每个段大小不一样，在内存的频繁分配与释放，就可能产生外部碎片，一些小的内存块就不能够得到利用。</p><h4 id="空闲物理内存管理"><a href="#空闲物理内存管理" class="headerlink" title="空闲物理内存管理"></a>空闲物理内存管理</h4><p>我们在C中分配释放内存如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>会发现当我们释放内存时候，只是给了起始地址，没有指定大小，那么系统怎么知道要释放多少了?</p></blockquote><p>分配器用额外的头部信息来记录分配内存的大小，魔数用来做完整性检查。因此当我们申请N字节大小内存，实际分配了N+sizeof(header)</p><p><img src="https://s1.ax1x.com/2020/07/31/a1UBQS.png" alt="a1UBQS.png"></p><h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><blockquote><p> free memory is first conceptually thought of as one big space of size 2N. When a request for memory is made, the search for free space recursively divides free space by two until a block that is big enough to accommodate the request is found (and a further split into two would result in a space that is too small).</p></blockquote><h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>我们说分段导致了外部碎片产生，根本原因在于段的大小不一，分页机制通过将地址空间划分为固定大小的地址单元(eg.4k)来解决这个问题。</p><p>每个进程有自己的一个页表，记录了虚拟页号和物理页号的对应关系。常见的地址映射如下</p><p>​                                               <img src="https://s1.ax1x.com/2020/07/31/a1UzOe.png" alt="a1UzOe.png"></p><p>实现页机制有几个问题</p><blockquote><p>1.页表存在哪里?</p><p>2.每一个页表项具体有什么内容?</p></blockquote><p>对于32bit地址空间，假设一个页表项4byte, 整个地址空间页表需要4M，每个进程有自己的页表，因为页表很大，不可能像段机制那样通过CPU的寄存器来存，因此我们的页表是直接存到内存里面的，刚刚分析一个页表就是4M,这个很恐怖，如果有上百个进程，光是页表就消耗了几百兆内存，因此这一部分后面是需要优化的。</p><p>X86下一个页表项的内容如下，有几个flag需要注意下</p><ul><li>P：存在位。为1表示页表或者页位于内存中。否则，表示不在内存中，必须先予以创建或者从磁盘调入内存后方可使用。</li><li>R/W：读写标志。为1表示页面可以被读写，为0表示只读。当处理器运行在0、1、2特权级时，此位不起作用。页目录中的这个位对其所映射的所有页面起作用。</li><li>U/S：用户/超级用户标志。为1时，允许所有特权级别的程序访问；为0时，仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用。</li></ul><p><img src="https://s1.ax1x.com/2020/07/31/a1UxyD.png" alt="a1UxyD.png"></p><p>由于页表位于内存，带来的后果就是我们对于一条指令的执行将额外增加一次内存访问(地址翻译)，伪码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"></span><br><span class="line"><span class="comment">// Form the address of the page-table entry (PTE)</span></span><br><span class="line">PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE)) <span class="comment">//ptbr 页表起始地址 存在寄存器里面</span></span><br><span class="line"><span class="comment">// Fetch the PTE</span></span><br><span class="line">PTE = AccessMemory(PTEAddr)v<span class="comment">//一次内存访问得到物理地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if process can access the page</span></span><br><span class="line"><span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">RaiseException(SEGMENTATION_FAULT)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// Access is OK: form physical address and fetch it</span></span><br><span class="line">offset= VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset</span><br><span class="line">Register = AccessMemory(PhysAddr) <span class="comment">//二次内存访问</span></span><br></pre></td></tr></table></figure><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>好处：</p><ul><li><p>固定大小内存单元，避免外部碎片</p></li><li><p>相对分段内存使用灵活</p></li></ul><p>缺点</p><ul><li><p>页表占用内存过大</p></li><li><p>访问太慢(相比直接内存访问，多一次内存访问)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OSTEP》 内存虚拟化部分小结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="OSTEP" scheme="http://yoursite.com/tags/OSTEP/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>文件系统的持久化</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-06-11T01:54:53.000Z</published>
    <updated>2020-06-11T02:51:28.763Z</updated>
    
    <content type="html"><![CDATA[<p>《OSTEP》文件持久化部分阅读笔记</p><a id="more"></a><h3 id="什么是crash-consistency-problem"><a href="#什么是crash-consistency-problem" class="headerlink" title="什么是crash-consistency problem?"></a>什么是crash-consistency problem?</h3><p>在两次write()之间，系统可能出现异常的断电，崩溃等情况，导致磁盘文件被部分更新。</p><p>在系统重启时，文件系统被再次装载，如何解决之前异常崩溃带来的on-disk image inconsistent state 是接下来要讨论的重点</p><p>具体来看下磁盘出现不一致的情况</p><p>当我们append new data block 到一个文件，至少需要更新3个数据结构:<code>inode,data block,data bitmap</code>在更新这三个数据结构的过程中，系统都可能崩溃，在不同的阶段崩溃造成的后果不一样。</p><p><img src="https://s1.ax1x.com/2020/06/11/tHFAQx.png" alt="tHFAQx.png"></p><p>假设只有一次更新成功</p><ul><li>data block is updated  不会造成一致性问题，因为没有inode指向更新的data block</li><li>inode  造成一致性问题，与bitmap 冲突，同时由于data block没有更新，会读取脏数据。</li><li>data bitmap 同上带来一致性问题，同时带来空间泄漏，因为bitmap更新之后，指向的空间不会被系统分配</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-file-system-checker"><a href="#1-file-system-checker" class="headerlink" title="1.file system checker"></a>1.file system checker</h4><p>基本思路是让不一致发生，然后修复它。</p><p>但是存在一些问题比如,即使inode 与data bitmap 一致，仍然可能存在读取脏数据<br>其次这种做法最大的问题就是速度太慢！ 需要扫描整个磁盘来检查所有相关的数据结构。</p><ol start="2"><li><h4 id="日志-write-ahead-logging"><a href="#日志-write-ahead-logging" class="headerlink" title="日志(write-ahead logging)"></a>日志(write-ahead logging)</h4></li></ol><p>在更新磁盘之前，先将当前操作(trananactions) 记录下来，当系统崩溃时候，能够replay。这样做的好处就是能够精准定位崩溃问题，不需要扫描整个磁盘。</p><p>具体如何实现</p><h5 id="data-log"><a href="#data-log" class="headerlink" title="data log"></a>data log</h5><ol><li>Journal write: Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.</li><li>Checkpoint: Write the pending metadata and data updates to their final locations in the file system.</li></ol><p>问题<br>在写日志的时候可能崩溃</p><p>改进<br>将写日志操作拆分为两步</p><ul><li>写日志开始标志+data+inode+bitmap</li><li>写日志结束标志</li></ul><p>这样做的好处在于磁盘能够保证对单个区块(512byte)的原子操作，进而保证对单条日志记录要么成功要么失败。</p><p>日志的空间大小有限，一旦日志空间满，之后的transactions 将不能被记录。<br>具体解决方法通过循环日志(类似循环队列) 一旦一个transaction 被check了，系统就释放对应的日志空间</p><p>经过上述几个改进，我们现在的做法如下</p><ol><li><p>Journal write: Write the contents of the transaction (containing TxBand the contents of the update) to the log; wait for these writes to<br> complete.</p></li><li><p>Journal commit: Write the transaction commit block (containingTxE) to the log; wait for the write to complete; the transaction is now committed.</p></li><li><p>Checkpoint: Write the contents of the update to their final locations within the file system.</p></li><li><p>Free: Some time later, mark the transaction free in the journal by updating the journal superblock.</p></li></ol><p>上述解决方案还能进一步优化: 我们将data block 两次写到了磁盘</p><h5 id="metadata-log"><a href="#metadata-log" class="headerlink" title="metadata log"></a>metadata log</h5><p>基本操作与之前一样，只是没有将data 写到日志中。</p><ol><li>Data write: Write data to final location; wait for completion(the wait is optional; see below for details).</li><li>Journal metadata write: Write the begin block and metadata to thelog; wait for writes to complete.</li><li>Journal commit: Write the transaction commit block (containingTxE) to the log; wait for the write to complete; the transaction (including data) is now committed.</li><li>Checkpoint metadata: Write the contents of the metadata updateto their final locations within the file system.</li><li>Free: Later, mark the transaction free in journal superblock.</li></ol><p>先写data 是为了避免脏读，如果先写meta，然后系统崩溃，就会导致读取旧的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OSTEP》文件持久化部分阅读笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口小结</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-06-11T01:45:39.000Z</published>
    <updated>2020-06-11T01:51:51.825Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口可以用来优化一些暴力求解问题，将时间复杂度降低到线性。</p><a id="more"></a><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h4><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>思路</p><ul><li>先扫描一遍T，把对应的字符及其出现的次数存到 HashMap 中。</li><li>然后开始遍历S，就把遍历到的字母对应的 HashMap 中的 value 减一，如果减1后仍大于等于0，cnt 自增1。</li><li>如果 cnt 等于T串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是T串中不可缺少的字母(hash表中对应value&gt;0)，那么 cnt 自减1，表示此时T串并没有完全匹配。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t) <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">int</span> len=t.size();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,cnt=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--<span class="built_in">map</span>[s[i]]&gt;=<span class="number">0</span>) cnt++;</span><br><span class="line">            <span class="keyword">while</span>(cnt==len)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.empty()||res.size()&gt;i-j+<span class="number">1</span>) res=s.substr(j,i-j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(++<span class="built_in">map</span>[s[j++]]&gt;<span class="number">0</span>) cnt--;<span class="comment">//移动左边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>进一步理解</strong><br>本来我们是可以开两个哈希表，这里为了节省空间，将其合并，遍历S字符串的时候，哈希表中字符出现的次数可以理解还缺多少个，就可以满足和T字符串匹配。这样一来就能很好理解在移动左边界的判断条件<code>++hash[s[j++]]&gt;0</code> 表示左边界指针移动之后，缺的个数大于0.</p><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p><strong>滑动窗口</strong>  思路非常类似上一题76.最小覆盖子串</p><p>这个题目的滑动窗口大小固定，因此需要先调整大小，然后添加满足条件的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> c:p) <span class="built_in">map</span>[c]++;</span><br><span class="line">       <span class="keyword">int</span> total=p.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,cnt=<span class="number">0</span>;j&lt;s.size();j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(--<span class="built_in">map</span>[s[j]]&gt;=<span class="number">0</span>) cnt++; <span class="comment">//移动右指针</span></span><br><span class="line">           <span class="comment">//移动左指针 维护窗口大小为p.size</span></span><br><span class="line">           <span class="keyword">while</span>(j-i+<span class="number">1</span>&gt;total)&#123;</span><br><span class="line">               <span class="keyword">if</span>(++<span class="built_in">map</span>[s[i++]]&gt;<span class="number">0</span>) cnt--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(cnt==total) res.push_back(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;滑动窗口可以用来优化一些暴力求解问题，将时间复杂度降低到线性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据流算法题目小结</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-06-09T00:09:21.000Z</published>
    <updated>2020-06-09T05:08:24.019Z</updated>
    
    <content type="html"><![CDATA[<p>由于数据是动态的，按照一般的做法，比如遍历，当新数据的加入，处理单个操作的时间复杂度为<code>O(n)</code>,这样往往造成TLE</p><p>通过使用合理的数据结构来存储，比如堆，能够将时间复杂度降低到 <code>logn</code></p><a id="more"></a><h4 id="703-数据流中的第K大元素"><a href="#703-数据流中的第K大元素" class="headerlink" title="703. 数据流中的第K大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">703. 数据流中的第K大元素</a></h4><p>这个本质的思想就是通过小根堆来求第K大元素，通过限制堆大小为k,以及判断堆顶元素与新加入元素val大小关系，将时间复杂度降低到logn.</p><p>有一点需要注意的就是做<code>pop()</code> 一定要检查堆是否为空。</p><h4 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></h4><p>通过使用两个堆，一个小根堆存放序列中较大的一部分元素，大根堆存放较小的一部分元素，可以形象的把这个结构想象成一个沙漏</p><p>通过堆顶元素就能够很方便的得到数据流的中位数。</p><p>当新元素val加入如何维护堆?</p><ol><li>val 先添加到大根堆maxq,  如果maxq.top&gt;minq.top 需要交换两个堆定元素</li><li>始终保持maxq.size()&lt;=minq.size()+1 这样才能通过堆顶来求中位数</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于数据是动态的，按照一般的做法，比如遍历，当新数据的加入，处理单个操作的时间复杂度为&lt;code&gt;O(n)&lt;/code&gt;,这样往往造成TLE&lt;/p&gt;
&lt;p&gt;通过使用合理的数据结构来存储，比如堆，能够将时间复杂度降低到 &lt;code&gt;logn&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>shared_from_this解决了什么问题</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-06-02T05:39:07.000Z</published>
    <updated>2020-06-07T23:57:22.596Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>enable_shared_from_this 含义<br>如果一个T类型的对象t,是被std::shared_ptr管理的，且类型T继承自<code>std::enable_shared_from_this</code>，那么T就有个<code>shared_from_this</code>成员函数，这个函数返回一个新的<code>std::shared_ptr</code>的对象，也指向对象t</p><p>如果不这么做, 会出现什么问题，看下面一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obj</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">get_shr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">ret</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">smart_ptr</span><span class="params">(<span class="keyword">new</span> obj)</span></span>;</span><br><span class="line">    obj&amp; a=*smart_ptr;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;obj&gt; b=a.get_shr(); <span class="comment">//两个智能指针管理的是同一个对象，造成对象两次释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述场景是 对象希望获得管理自己的智能指针，但是直接通过成员函数返回一个<code>shared_ptr</code>,造成了被管理对象的重复删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;enable_shared_from_this 含义&lt;br&gt;如果一个T类型的对象t,是被std::shared_ptr管理的，且类型T继承自&lt;code&gt;std::enable_shared_from_this&lt;/code&gt;，那么T就有个
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>系统调用open(),read(),write()具体发了什么?</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-06-01T04:12:25.000Z</published>
    <updated>2020-06-01T12:25:18.707Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要想探究的是我们平时说的IO系统调用与<code>inode</code>，文件系统等之间的交互，或者说，在做文件IO时候，有那些底层的数据结构参与进来。</p><a id="more"></a><p>在讲具体的系统调用之前，先要简单了解几个概念</p><p><strong>文件系统</strong></p><p>文件系统可以简单的理解为数据结构+方法</p><p>数据结构：文件系统以一种怎样的结构来组织其存储的数据</p><p>方法:open(),read()等调用如何与数据结构打交道</p><p>一个简单的文件系统一般有这几部分</p><ul><li>inode table记录文件的metadata,主要有文件的权限，用户，创建时间，文件所对应blocks</li><li>data block 存储实际问文件内容</li><li>inode bitmap 记录inode table 分配情况位图用0/1来表示对应项是否分配</li><li>data bitmap 记录data blocks 分配情况</li><li>superblock 记录了整个文件系统的一些信息，比如inode个数，data blocks个数，inode table 起始地址。当文件系统<code>mount()</code> superblock被加载到内存。</li></ul><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>以<code>/foo/bar</code> 为例，假设文件大小为4kb</p><p>首先<code>open(&quot;/foo/bar&quot;,O_RDONLY)</code> 需要找到文件bar对应的inode,具体的做法是按照文件路径遍历，通过目录中存储的文件名-&gt;inode-number来找到文件<code>bar</code>对应的inode。</p><p>将文件对应的inode加载到内存，做权限检查，比如文件读写属性。每个进程中都有一个open-file-table,系统为打开的文件分配文件描述符。</p><p>一旦文件打开之后，read()按照顺序从第一个block开始读取，具体来看需要读取inode来获取区块位置信息，更新inode中last-access-time。更新open-file-table中的file offset。</p><p>打开一个文件所涉及到的IO操作与文件路径长度成正比。每次通过父目录中的data-block来获取inode-number，用来在inode table查找对应的inode，通过inode来查找data-block位置。 因此每多添加一层目录就会有额外的两次IO.</p><p>下面的图直观的说明这一过程</p><p><img src="https://s1.ax1x.com/2020/06/01/tJimWt.png" alt="tJimWt.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要想探究的是我们平时说的IO系统调用与&lt;code&gt;inode&lt;/code&gt;，文件系统等之间的交互，或者说，在做文件IO时候，有那些底层的数据结构参与进来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>最长上升子序列</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-05-26T16:00:48.000Z</published>
    <updated>2020-05-30T11:58:29.789Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><a id="more"></a><h3 id="解法1-动态规划"><a href="#解法1-动态规划" class="headerlink" title="解法1.动态规划"></a>解法1.动态规划</h3><p><strong>时间复杂度O($n^2$)</strong></p><p><strong>思路</strong></p><p><code>f[i]</code>表示以ith字符结尾的最长上升子序列长度</p><p>这道题难在状态转移的求解<br><code>f[i]=max(f[i-1],f[i-2],......)+1</code>  前提条件是 f[j]&lt;f[i] 才能构成上升子序列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            f[i]=<span class="number">1</span>; <span class="comment">//表示只含当前字符的序列长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i]) f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:f) res=<span class="built_in">max</span>(res,c);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="解法2-直接构造最长上升子序列"><a href="#解法2-直接构造最长上升子序列" class="headerlink" title="解法2  直接构造最长上升子序列"></a>解法2  直接构造最长上升子序列</h3><p>时间复杂度 $O(nlogn)$</p><p>开一个辅助数组 <code>f[i]</code> 表示最长上升子序列长度为<code>i+1</code> 中最小结尾值</p><p>eg. [1,2,4] ,[1,2,3]两个子序列长度都为3， 但是第一个子序列结尾值3&lt;4 ，于是 f[2]=3;</p><p>这里面的思路背景是 在dp解法中  f[i]=max(f[j]+1)  nums[j] 越小 那么对nums[i]限制就越小</p><p>两个最长上升子序列长度相同 那么子序列尾部值越小 越有可能构建成更加长的子序列</p><p>由于构造的辅助数组一定单调上升，因此可以通过二分查找来做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size(),len=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> p=lower_bound(f.begin(),f.end(),c)-f.begin(); </span><br><span class="line">            <span class="keyword">if</span>(p==f.size()) f.push_back(c);<span class="comment">//查找元素比辅助数组最大值还要大</span></span><br><span class="line">            <span class="keyword">else</span> f[p]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最好是通过一个 toy example 来给给面试官讲这个思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>排序二叉树转化为双向链表</title>
    <link href="http://yoursite.com/p/undefined.html"/>
    <id>http://yoursite.com/p/undefined.html</id>
    <published>2020-05-24T13:51:08.000Z</published>
    <updated>2020-05-24T13:53:12.405Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>这道题目注意审题，注意双向链表的表头和表尾部是否连接，如果连接就是一个循环双向链表。</p><a id="more"></a><h3 id="循环双向链表-递归"><a href="#循环双向链表-递归" class="headerlink" title="循环双向链表+递归"></a>循环双向链表+递归</h3><p>思路上很直接，在二叉搜索树的中序遍历基础上，改变当前节点<code>root</code>指针指向，因为我们需要将<code>root-&gt;left</code> 指向前一个顺序遍历的节点，我们用一个指针<code>pre</code>表示当前节点的前一个节点。</p><p>解法一<br>递归返回头节点和尾节点，注意递归传递的参数应该是引用类型(<del>不然debug搞死你。。。)</del></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        Node*head=<span class="literal">nullptr</span>,*pre=<span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root,head,pre);</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node*root,Node*&amp;head,Node*&amp;pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left,head,pre);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;root-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            head=root;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;right=root;</span><br><span class="line">            root-&gt;left=pre;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;right,head,pre);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p>大体和上面一样递归，但是递归的时候没有保存头节点,而是在把节点指针顺序改变好之后(实际上这个时候双链表已经建好了）通过链表的反向遍历找到头节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Node*pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">auto</span> head=pre;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;left) head=head-&gt;left;</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        root-&gt;left=pre;</span><br><span class="line">        <span class="keyword">if</span>(pre) pre-&gt;right=root;</span><br><span class="line">        pre=root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="解法3-利用栈非递归中序遍历"><a href="#解法3-利用栈非递归中序遍历" class="headerlink" title="解法3  利用栈非递归中序遍历"></a>解法3  利用栈非递归中序遍历</h3><p>二叉搜索树的中序遍历后结果是一个有序数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; stk;</span><br><span class="line">        Node*pre=<span class="literal">NULL</span>,*head=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(root||stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            root-&gt;left=pre;</span><br><span class="line">            <span class="keyword">if</span>(pre) pre-&gt;right=root;</span><br><span class="line">            pre=root;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        head=pre;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;left) head=head-&gt;left;</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：&lt;br&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p&gt;
&lt;p&gt;这道题目注意审题，注意双向链表的表头和表尾部是否连接，如果连接就是一个循环双向链表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
