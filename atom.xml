<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DDL&#39;s homepage</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-23T12:16:53.303Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ddl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>适合反复看的技术入门教程</title>
    <link href="http://yoursite.com/2020/12/23/%E9%80%82%E5%90%88%E5%8F%8D%E5%A4%8D%E7%9C%8B%E7%9A%84%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/12/23/%E9%80%82%E5%90%88%E5%8F%8D%E5%A4%8D%E7%9C%8B%E7%9A%84%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</id>
    <published>2020-12-23T11:55:39.000Z</published>
    <updated>2020-12-23T12:16:53.303Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ol><li><a href="https://zhuanlan.zhihu.com/p/339008746?utm_source=org.telegram.messenger&utm_medium=social&utm_oi=966460230863925248" target="_blank" rel="noopener">Kubernetes 入门&amp;进阶实战</a>  腾讯CSIG工程师写的，估计是内部k吧开源出来的</li></ol><blockquote><p>笔者今年（公元 2020 年）9 月从端侧开发转到后台开发，第一个系统开发任务就强依赖了 K8S，加之项目任务重、排期紧，必须马上对 K8S 有概念上的了解。然而，很多所谓“K8S 入门\概念”的文章看的一头雾水，对于大部分新手来说并不友好。经历了几天痛苦地学习之后，回顾来看，<strong>K8S 根本不复杂。</strong>于是，决心有了这一系列的文章：一方面希望对新手同学有帮助；另一方面，以文会友，希望能够有机会交流讨论技术。</p></blockquote><ol start="2"><li><a href="https://kingsamchen.github.io/2020/02/08/how-to-learn-cmake-as-the-beginner/" target="_blank" rel="noopener">CMake 入门指南</a>  这位大哥是B站后端工程师，最早是在饭否看到他的技术分享觉得很棒，然后顺藤摸瓜找到了他的个人博客，可以看出来他对C++理解还是很深，虽然我之后可能不怎么会接触C++开发了，但是很多好的概念还是值得学习的。</li></ol><h4 id="0x00-起手式"><a href="#0x00-起手式" class="headerlink" title="0x00 起手式"></a>0x00 起手式</h4><p>这里假设题主以及其他想入门 CMake 的人像我一样，下面是我个人总结的比较适合的学习路径。</p><p>首先默念三遍并记住口诀：</p><ol><li>Declare a target</li><li>Declare target’s traits</li><li>It’s all about targets</li></ol><p>然后 clone <a href="https://github.com/ttroy50/cmake-examples" target="_blank" rel="noopener">https://github.com/ttroy50/cmake-examples</a> 这个项目到本地，把里面的</p><ul><li>01-basic（跳过E-installing，因为和依赖有关，后面会说）</li><li>02-sub-projects</li></ul><p>两个目录认真的学习一遍，最好自己能够动手跟着做一遍。</p><p>每学习完一个小节，把前面的三句口诀复习一下</p><p>每遇到一个不认识的命令，在 <a href="https://link.zhihu.com/?target=https%3A//gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">Effective Modern CMake</a> 这个页面里搜索一下，看看这个命令是否取代了某个老命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/339008746?utm_source=org.telegram.messenger&amp;utm_medium=social&amp;utm_oi=96646
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>20201221一周小结</title>
    <link href="http://yoursite.com/2020/12/21/20201221%E4%B8%80%E5%91%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/12/21/20201221%E4%B8%80%E5%91%A8%E5%B0%8F%E7%BB%93/</id>
    <published>2020-12-21T02:06:42.984Z</published>
    <updated>2020-12-21T02:15:03.786Z</updated>
    
    <content type="html"><![CDATA[<p>一周小结</p><p>看完了进击的巨人，第三季结尾曲尤其打动我，里面对于是非善恶的哲学探讨，让人深思。 但是思考之后，我便陷入虚无，不同的观点在脑海里面互相冲击，不能够很好的协调共处，我深知没有一套理论能够解释所有的一切，但是摆脱了二元是非观之后，脑子里面剩下的就是混沌，没有什么是绝对，同时也没有什么值得100%相信。</p><p>在这个阶段我充满了痛苦，对很多事情的目的性没有那么明确了。但我也知道不能再向以前一样逃避，为了避免思考而简化问题。今天我把它记录下来，虽然我还没有完全想清楚怎么处理现在的困境，但我希望能够一直记住这个状态，并且努力去寻求答案。</p><p>这一周我察觉到自己信息又一次过载了，于是昨天卸载了手机上的即刻。最近没有很多外在的压力，于是我让自己放松开来，变的敏感起来，听了很多的播客。但是这种新鲜感已经没有之前强烈了，过多的输入给你一种错觉-突然懂了很多，但是并没有内化和自己的知识体系联系起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一周小结&lt;/p&gt;
&lt;p&gt;看完了进击的巨人，第三季结尾曲尤其打动我，里面对于是非善恶的哲学探讨，让人深思。 但是思考之后，我便陷入虚无，不同的观点在脑海里面互相冲击，不能够很好的协调共处，我深知没有一套理论能够解释所有的一切，但是摆脱了二元是非观之后，脑子里面剩下的就是混沌，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Peter Thiel&#39;s Religion — David Perell</title>
    <link href="http://yoursite.com/2020/12/17/Peter%20Thiel&#39;s%20Religion%20%E2%80%94%20David%20Perell/"/>
    <id>http://yoursite.com/2020/12/17/Peter%20Thiel&#39;s%20Religion%20%E2%80%94%20David%20Perell/</id>
    <published>2020-12-17T06:36:29.081Z</published>
    <updated>2020-12-17T06:36:48.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Peter-Thiel’s-Religion-—-David-Perell"><a href="#Peter-Thiel’s-Religion-—-David-Perell" class="headerlink" title="Peter Thiel’s Religion — David Perell"></a>Peter Thiel’s Religion — David Perell</h2><p>*”I am the Lord your God.” — 1st Commandment*</p><p>Human culture began with a murder. That culture was fueled by rage and rivalry, which led to violence. Managing that violence is the secret reason for all religious and political institutions.</p><p>In <em>The Bible</em>, The Cain and Abel story is the first act of life after the Garden of Eden. Cain is a farmer and the older brother to Abel, who is a shepherd. Initially, Cain admires Abel. But eventually, when Cain turns envious of his younger and more successful brother, he kills him. The two brothers represent two halves of the human psyche: Abel represents the part that looks up towards the transcendent, where Cain represents the other that looks down towards death and destruction.</p><p>Depending on who you ask, the significance of the Cain and Abel story ranges from nothing to everything. For some, the Christian cross is too strange to be taken seriously. It’s archaic and stuck inside a biblical world that can no longer speak to the challenges of life with iPhones, Tinder, and $12 avocado toast. But to others, religion is the foundation of human culture. Without it, peace cannot be maintained and violence will erupt like an angry volcano. </p><p><em>What does Peter Thiel think? Is religion a superfluous add-on or the origin of everything?</em></p><p>In this essay, we’ll explore the significance of religion and the Cain and Abel story. We’ll learn why the story is an archetype for human relationships, even in the Western world where people stiff-arm religion like it’s the Heisman trophy.</p><p>We’ll study religion through the lens of Peter Thiel. He’s an investor who found wealth in PayPal, a student who found wisdom in Libertarian ideals, and a philosopher who found faith in the resurrection of Jesus Christ. Thiel was raised as an Evangelical and inherited the Christianity of his parents. But his beliefs are “somewhat heterodox.” In a profile in the <em>New Yorker</em>, Thiel said: “I believe Christianity to be true. I don’t feel a compelling need to convince other people of that.”</p><p>Three simple statements will lead us towards our ultimate answer about the importance of religion: </p><ol><li>Don’t copy your neighbors</li><li>Time moves forward</li><li>The future will be different from the present</li></ol><p>Rather than focusing on Thiel’s actions, I’ve chosen to focus on his ideas. First, we’ll explore the principles of Peter Thiel’s worldview. We’ll begin by explaining Thiel’s connection to a French philosopher named Rene Girard. We’ll return to old books like <em>The Bible</em>, old ideas like sacrifice, and old writers like Shakespeare, and see why this ancient wisdom holds clues for modern life. Then, we’ll return to the tenets of the Christian story. We’ll cover the shift from cyclical time to linear time, which was spurred by technological development and human progress. We’ll see why the last book in <em>The Bible,The Book of Revelation,</em> is a core pillar of Thiel’s philosophy. Then, we’ll close with Thiel’s advice and wisdom almost as old as Cain and Abel: the Ten Commandments.</p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564974225418-GB7XFUE053HHP7B4OEQY/ke17ZwdGBToddI8pDm48kKhu5DRdO8CQ8VunLbJ8z8oUqsxRUqqbr1mOJYKfIPR7LoDQ9mXPOjoJoqy81S2I8N_N4V1vUb5AoIIIbLZhVYy7Mythp_T-mtop-vrsUOmeInPi9iDjx9w8K4ZfjXt2dmagIiNnX8UuIj-JaVGyG1_9ZXDh8vza2Frin8PDZdropC969RuPXvt2ZwyzUXQf7Q/IMG_DB41477003EB-2.jpeg" alt="img"></p><p>Some disclaimers: I’ve never met Peter Thiel. The contents of this essay are based on public information and my own intuition. Hopefully, some of it is interesting. Inevitably, some of it is wrong. I am not a Christian and only have a basic understanding of Christian theology. If you agree with everything in this essay, I haven’t challenged you enough. I’ve also chosen an interpretation of the Bible, and especially <em>The Book of Revelation</em> that aligns with Thiel’s philosophy. Thiel fanatics will say I’ve only scratched the surface. Others will say I’ve gone too deep. And both might complain I’ve focused too much on his relationship with Christianity. </p><p>I don’t agree with all of Thiel’s conclusions, but I admire his rigorous and independent thought. By the time you finish reading this essay, you will too. </p><p>I wrote this essay because I’m fascinated by Christianity and impressed with Thiel. I’ve spent the past decade as an agnostic, just like everybody around me. But after a recent change of heart, I’m on a quest to develop my own conclusions about religion. </p><p>This essay is an introduction to his ideas, but it’s not just about Thiel. It’s about modern society, human behavior, and the philosophy of religion. </p><p>Let’s begin.</p><h3 id="Thiel’s-Intellectual-Background"><a href="#Thiel’s-Intellectual-Background" class="headerlink" title="Thiel’s Intellectual Background"></a><strong>Thiel’s Intellectual Background</strong></h3><p>To understand Thiel’s ideas, we need to begin with the person who influenced Peter Thiel more than any other writer: Rene Girard. </p><p>Rene Girard was a French historian and literary critic. He’s famous for <em>Mimetic Theory</em>, which forms the bedrock of Thiel’s worldview. Thiel studied under Girard as an undergraduate at Stanford in the late 1980s. Their relationship stretched beyond the walls of Palo Alto classrooms and became a lifelong friendship. When Girard died, Thiel <a href="http://bookhaven.stanford.edu/2016/01/memorial-service-and-reception-for-rene-girard-on-tuesday-jan-19-be-there/" target="_blank" rel="noopener">spoke</a> at the memorial service.</p><p>Mimetic Theory rests on the assumption that all our cultural behaviors, beginning with the acquisition of language by children are imitative. He sees the world as a theatre of envy, where, like mimes, we imitate other people’s desires. His theory builds upon the kinds of books and people that modern people tend to ignore: <em>The Bible</em>, classic fiction writers such as Marcel Proust, and playwrights like Shakespeare. </p><p>Mimetic conflict emerges when two people desire the same, scarce resource. Like lions in a cage, we mirror our enemies, fight because of our sameness, and ascend status hierarchies instead of providing value for society. Only by observing others do we learn how and what to desire. Our Mimetic nature is simultaneously our biggest strength and biggest weakness. When it goes right, imitation is a shortcut to learning. But when it spirals out of control, Mimetic imitation leads to envy, violence, and bitter, ever-escalating violence. </p><p><em>Mimesis</em> is the Greek word for imitation. Imitation is not the childish, low-level form of behavior that many people think it is. Since humanity would not exist without it, humans aren’t as independent as they think they are. Early psychologists like Sigmund Freud didn’t take imitation seriously enough. In one essay, Thiel described human brains as “gigantic imitation machines.” </p><p>Our capacity for imitation is unconscious. This drive towards imitation separates us from other animals, and historically, it enabled our evolution from earlier primates to humans. <a href="https://static1.squarespace.com/static/55a55b50e4b08015467323fc/t/565f4a92e4b0a6f556b4e7c4/1449085586674/Contagion_12-13_Garrels_47-86.pdf" target="_blank" rel="noopener">Imitation</a> is linked to forms of intelligence that are unique to humans, especially culture and language. </p><p>We’ve known this for centuries. In the time of Shakespeare, the word ape meant both “primate” and “imitate.” Learning and human behavior is learned through imitation. Without it, all forms of culture would vanish. As any dancer will tell you, the heart beats fastest when two people agree to imitate each other and move in perfect sync. These are the moments when time disappears; when years of trust are built in seconds of synchronicity. </p><p>Thiel speaks with a religious reverence for Girard’s theory:</p><p>“[Girard’s ideas are] a portal onto the past, onto human origins, and our history. It’s a portal onto the present and onto the interpersonal dynamics of psychology. It’s a portal onto the future in terms of where we are going to let these Mimetic desires run amok and head towards apocalyptic violence… It has a sense of both danger and hope for the future as well. So it is this panoramic theory… [It’s] super powerful and extraordinarily different from what one would normally hear. There was almost a cult-like element where you have these people who were followers of Girard and it was a sense that we had figured out the truth about the world in a way that nobody else did.”</p><p>Thiel credits Girard with inspiring him to switch careers. Before he internalized Girard’s ideas, Thiel was on track to become a lawyer. He worked as an associate for <em>Sullivan &amp;</em> <em>Cromwell</em> in New York City, where the hours were long and the competition was cutthroat. As Thiel recounts, all the lawyers competed for the same shared goals. They ranked themselves not by absolute progress towards a transcendent end goal, but by progress within their peer group. </p><p>As Peter Thiel <a href="http://taxprof.typepad.com/taxprof_blog/2016/05/peter-thiels-advice-to-graduates-my-ambition-to-be-a-lawyer-was-less-a-plan-for-the-future-than-an-a.html" target="_blank" rel="noopener">recounted</a>:</p><p><em>“When I left after seven months and three days, one of the lawyers down the hall from me said, ‘You know, I had no idea it was possible to escape from Alcatraz.’ Of course that was not literally true, since all you had to do was go out the front door and not come back. But psychologically this was not what people were capable of. Because their identity was defined by competing so intensely with other people, they could not imagine leaving… On the outside, everybody wanted to get in. On the inside, everybody wanted to get out.”</em></p><p>Competition distracts us from things that are more important, meaningful, or valuable. We <a href="https://www.rottentomatoes.com/m/fight_club/quotes/" target="_blank" rel="noopener">buy</a> things we don’t need with money we don’t have to impress people we don’t like. Trapped in a never-ending rat race, lawyers climbed the corporate ladder by winning favor with partners at the top. Others engaged in small acts of sabotage against their coworkers. </p><p>Law school was worse. Like lobsters in a bucket, wannabe lawyers battled for law school placement and law firm employment. Each goal led to the next. Rather than focusing their attention on the end goal of developing a legal expertise, transforming the Constitution, or rescuing the powerless from tyrannical injustice, they elbowed their peers so they could score higher than their classmates on standardized tests. The competition was zero-sum. The better one student did, the worse their peers scored.</p><h3 id="How-Girard-Influenced-Thiel-in-Business"><a href="#How-Girard-Influenced-Thiel-in-Business" class="headerlink" title="How Girard Influenced Thiel in Business"></a><strong>How Girard Influenced Thiel in Business</strong></h3><p>Thiel sees the world at a strange angle. His contrarian streak runs through everything he does. But until now, nobody has explained the roots of his singular philosophy. </p><p>His verbal tendencies double as a mirror into his mind. Listen to a Thiel interview and you’ll notice how often he reframes the question before answering. When he speaks, he skips between perspectives faster than a game of hopscotch. He says things like “One version of this is…” or “You could say that…” He has an uncanny ability to consider cultural trends and investment trades from a diversity of perspectives. Sometimes, I wonder if he sees life as a game of chess, where he plays against himself and simultaneously switches from black, to white, and back again. Listen carefully and you’ll see how often he hides answers inside of questions. By playing both sides of the board with the rigor of a Dostoyevsky novel, he sees what others miss with crystal clarity. </p><p>In the <a href="https://amzn.to/2JZ6LiF" target="_blank" rel="noopener">words</a> of one of his friends: </p><p><em>“Peter is of two minds on everything. If you were able to open his skull, you would see a number of Mexican standoffs between powerful antagonistic ideas you wouldn’t think could be safely housed in the same brain.”</em></p><p>Before playing a game, you have to know the rules. Breakthrough businesses are so innovative that people don’t have the words to describe them. He focuses on questions as much as answers, so he can identify the difference that makes the difference. For example, people still talk about Google as a search engine and Facebook as a social networking site. Both descriptions miss the point. Google succeeded because it’s a <em>machine-powered</em> search engine. Until Facebook, social networks mostly helped people become virtual cats and dogs. Facebook succeeded because it helped people create real identities online. 15 years after its founding, people incorrectly frame the history of social networks. He doesn’t just focus on the brushstrokes. He looks at how the painting is framed. </p><p>Thiel’s companies are governed by Girard’s wisdom. Girard observed that all desires come from other people. When two people want the same scarce object, they fight. In response, as CEO of PayPal, Thiel set up the company structure to eliminate competition between employees. PayPal overhauled the organization chart every three months. By repositioning people, the company avoided most conflicts before they even started. Employees were evaluated on one single criterion, and no two employees had the same one. They were responsible for one job, one metric, and one part of the business. </p><p>Thiel provided the first outside money into Facebook and still serves on the company board. His $500,000 <a href="https://www.reuters.com/article/us-facebook-stake/peter-thiel-sells-most-of-remaining-facebook-stake-idUSKBN1DM2BQ" target="_blank" rel="noopener">investment</a> was partially informed by Mimetic Theory because he saw Girard’s ideas validated by social media. As Thiel said: “Facebook first spread by word of mouth, and it’s about word of mouth, so it’s doubly Mimetic. Social media proved to be more important than it looked, because it’s about our natures.” </p><p>To be sure, not all of Thiel’s investments have been successful. Thiel’s hedge fund, <em>Clarium Capital,</em> was unsuccessful. The fund fell 13 percent in August 2008, 18 percent in October 2008, and lost money for the third year in a row in 2009. By September 2009, the total assets under management had fallen from a peak of $7.8 billion to a mere $850 million, most of which was Thiel’s personal capital.</p><p>People who work with Thiel are told to look for heterodox ideas and people with clear visions of the future. Thiel doesn’t like to be an operator because it’s a low-leverage activity. Instead of banging the keyboard himself, Thiel installs strong CEOs and leaders whose judgements are similar to his own. Time and again, these skilled operators have the agency to act without Thiel’s approval, and are encouraged to pursue bold visions of the future. They have freedom to pursue bizarre ideas and people who don’t fit the standard mold. </p><p>In an epic exchange between two billionaires, Jeff Bezos said: </p><p><em>“Peter Thiel is a contrarian, first and foremost. You just have to remember that contrarians are usually wrong.”</em></p><p>In an email to <a href="https://amzn.to/32HoS58" target="_blank" rel="noopener">Ryan Holiday</a>, Peter responded as such: </p><p><em>“Contrarians may be mostly wrong, but when they get it right, they get it really right.”</em></p><p>Across PayPal and Facebook, Peter Thiel’s philosophy can be summarized in a single sentence: Don’t copy your neighbors. It’s like a search for keys. Instead of looking in the light, Thiel and his employees look in the dark, where nobody else is looking.</p><h2 id="Section-1-Don’t-Copy-Your-Neighbors"><a href="#Section-1-Don’t-Copy-Your-Neighbors" class="headerlink" title="Section 1: Don’t Copy Your Neighbors"></a><strong>Section 1: Don’t Copy Your Neighbors</strong></h2><p><em>“Do not love the world or the things in the world. If anyone loves the world, the love of the Father is not in him. For all that is in the world—the lust of the flesh, the lust of the eyes, and the pride of life—is not of the Father but is of the world. And the world is passing away, and the lust of it; but he who does the will of God abides forever.”</em> — 1 John 2: 15–17</p><p>Everybody imitates. We cannot resist Mimetic contagion, and that will never change. But there are bad ways to copy and good ways to copy. Bad imitators follow the crowd and mirror false idols, while good imitators copy a transcendent goal or figure. </p><p>Imitation draws people together. Then, it pulls them apart like an ocean riptide. </p><p>At first, two people who share the same desire will be united by it. But if they cannot share what they both desire, their relationship will transform. They’ll turn from the best of friends to the worst of enemies. Conventional wisdom says that we loathe people who are nothing like us. But when it comes to envy, jealousy, and resentment Girard takes a different perspective. Since small disagreements loom large in the imagination, Girard wrote that social differences and rigid hierarchies maintain peace. When those differences collapse, the infectious spread of violence accelerates. The fiercest rivalries emerge not between people who are different, but people who are the same. The more two people share the same desires, the greater the risk of Mimetic competition. </p><p>Consider the famous opening words of Shakespeare’s <em>Romeo and Juliet:</em> “Two houses, both alike in dignity…” Through bloody battles between the Montagues and the Capulets, Shakespeare reminds us that people fight not because they’re so different, but because they’re so alike. Similar people are most prone to Mimetic envy because we tend to compete for status with the people who are closest to us. When two people are different and far away from each other, the tension will stay calm. Thus, the more we resemble our peers, the more Mimetic conflict will arise. </p><p>Shakespeare wasn’t the only writer to identify the vicious Mimetic impulse. Sigmund Freud called the tendency for conflict between two similar people “The Narcissism of Small Differences.” We reserve tooth-grinding envy for people most like ourselves. Thomas Hobbes wrote that “if any two men desire the same thing, which nevertheless they cannot both enjoy, they become enemies; and in the way to their End… endeavor to destroy, or subdue one another.“</p><p>True to the observations of Shakespeare, Freud, and Hobbes, academics are famous for institutional elbow-knocking. </p><p>Prestige-oriented environments can create nasty feuds over little prizes. A family friend named Julia tells a head-spinning story about her time at Columbia University. She couldn’t leave her books in the library. When she did, competing students often stole them. Not because they needed money or material goods, but because they felt surges of envy. Rather than absorbing the course material and preparing themselves for a life after college, students sabotaged their peers and shared false study guides. Relationships were shattered by sour resentment. Classmates could not be trusted, especially those who wanted to help. </p><p>As Julia’s story demonstrates, academic rivalries are vicious because they focus on hierarchies over knowledge. They bicker over trivial details and compete for a limited set of status-based titles. In each department, there can only be one chairman. In each university, one president. Speaking about the faculty relationships at Harvard, Henry Kissinger once said: “The battles were so ferocious because the stakes were so small.” By obsessing over their competitors, the faculty lost sight over the big picture and fought over the small scraps of superficial status games. The more they strived to be different, the more their actions mirrored each other. </p><p>Choose your enemies well. Like two children who fight for a toy, the more you fight somebody, the more you resemble your enemy. </p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564974345000-S5USHTX0R6EI431Y8TQ5/ke17ZwdGBToddI8pDm48kMu52y_ezbP3-SP8iPKHFsV7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QHyNOqBUUEtDDsRWrJLTmW6PTEIPSiHkoxzSCmjHS75gmQ4fdF3tay3qlDlf0BPuJyfpfYuG41uVJqQqtBT-F/26B2A8CC-076C-41F2-822D-569AFBF71C3A.jpg" alt="img"></p><h3 id="Toys-Lessons-from-Rene-Girard"><a href="#Toys-Lessons-from-Rene-Girard" class="headerlink" title="Toys: Lessons from Rene Girard"></a><strong>Toys: Lessons from Rene Girard</strong></h3><p>I’ll be honest. When I first read about Mimetic Theory, I was skeptical. Girard’s ideas seemed trivial and I couldn’t find any evidence to support them. Then, I started seeing his ideas everywhere. Once I saw empirical evidence of Girard’s ideas, I started taking them seriously. </p><p>Mimetic Theory shines brightest in trivial everyday moments, such as watching children play with toys. First, you have to understand Mimetic Theory at an intellectual level. Then, you have to understand it at an emotional one. Until then, Girard’s ideas might feel like ancient and irrelevant ideas. Once you watch these ideas impact your family, your friends, and your coworkers, you will have the same revelation Peter Thiel had as a student in Girard’s class at Stanford.</p><p>Girard observed that even when you put a group of kids together in a room full of toys, they’ll inevitably desire the same toy instead of finding their own toy to play with. A rivalry will emerge. Human see, human want. </p><p>Our capacity for imitation leads to envy. Babies’ interest in a particular toy has less to do with the toy itself and more to do with the fact that the other babies desire the toy. As soon as one child desires the toy, so do the others. Eventually, even though there are many toys available to play with, all the children want the same toy.</p><h3 id="Toys-Lessons-from-Joseph-Henrich"><a href="#Toys-Lessons-from-Joseph-Henrich" class="headerlink" title="Toys: Lessons from Joseph Henrich"></a><strong>Toys: Lessons from Joseph Henrich</strong></h3><p>Harvard anthropologist Joseph Henrich found empirical evidence for Girard’s observations about children and toys. In his book, <a href="https://amzn.to/2K5gjZh" target="_blank" rel="noopener"><em>The Secret of Our Success</em></a><em>,</em> he shows that humans are cultural learners. Mimetic desire is innate, not learned. We copy other people spontaneously, automatically, and unconsciously. And we are especially likely to copy people who are more successful than us, especially in moments of difficulty or uncertainty. </p><p>Henrich illustrates our Mimetic nature by studying children and how they desire toys. Even at a young age, and especially in moments of confusion, they emulate people around them. In one study, Henrich found that babies engaged in social referencing four times more often when an ambiguous toy was placed in front of them. When faced with an ambiguous toy, babies altered their behavior based on adults’ emotional reactions. In their early years, babies depend on elders to navigate the world and outsource their decisions to them. </p><p>I can relate. Nothing piques a child’s desire like watching their friends receive a new toy. Throughout my childhood, I remember coming home to my parents to ask for new toys. Back when I needed a car seat to ride in a vehicle, I asked for Thomas the Tank Engine train sets. Once I could read and write, I asked for the same LeBron James jersey my friends had. And in my first month of college in North Carolina, I demanded the same “Nantucket Red” Vineyard Vines pants as my fraternity brothers. </p><p>None of these desires were my own. Looking back, these desires came from my peers. I wasn’t the only one. My friends’ desires moved in perfect synchronicity. Once one kid received a cool new toy, so did the rest of the group. When my parents wouldn’t buy me a toy, I shot back with Mimetic-fueled social proof: “But my friend Jeremy just got a new baseball glove and now I need one.” </p><p>Turns out, I’m not crazy. </p><p>Through toys, Girard and Henrich show how our tendency to desire the same scarce resources as our peers leads to envy and competition. </p><p>Mimetic competition is visible in every aspect of social life. People shift their attention from the object of desire to the other person, and the drive to beat them. From bored students, to ambitious graduate school students, to empire-building business professionals, the objects we fight about change, but human nature doesn’t. </p><h3 id="Competitive-Strategy-in-Business"><a href="#Competitive-Strategy-in-Business" class="headerlink" title="Competitive Strategy in Business"></a><strong>Competitive Strategy in Business</strong></h3><p>Thiel’s Christianity-inspired worldview lines up with Michael Porter’s philosophy of business strategy. Porter is a Harvard Business School professor known for his theories on economics and business strategy. He believed that strong businesses aim to be unique, not the best. Trying to outcompete rivals leads to mediocre performance, so companies should avoid competition and seek to create value instead of beating rivals. </p><p>As Thiel once wrote: </p><p><em>“Once you have many people doing something, you have lots of competition and little differentiation. You, generally, never want to be part of a popular trend… So I think trends are often things to avoid. What I prefer over trends is a sense of mission. That you are working on a unique problem that people are not solving elsewhere.”</em></p><p>After the 2008 financial crisis, when the new General Motors went public in 2010, CEO Dan Akerson announced that his company was free of legacy costs and ready to compete again. As he shouted to reporters: “May the best car win!” This phrase reflects an assumption that competition is the best way to grow shareholder value. It implies that if you want to win, you should try to be the best. But this is the wrong way to think about competition. </p><p>We analogize business to war. In war, victory requires that the enemy is crippled or destroyed. Rivals who pursue the “one best way” to compete will converge on a collision course, where everybody listens to the same advice and pursues the same strategies, leading to zero-sum outcomes where total industry profits fall towards nothing. </p><p>When you compete to be the best, you imitate. When you compete to be unique, you innovate. In business, multiple winners can thrive and coexist. You don’t have to annihilate your competition. While imitation creates a race to the bottom, innovation promotes healthy competition and economic growth. In that way, business is like the performing arts, not war. In the performing arts there are many entertaining singers and actors, each with a distinct style. The more talented and differentiated performers there are, the more the arts flourish. This is the essence of positive-sum competition. </p><p>To drive the point home, let’s turn back to Peter Thiel. The third chapter of his book, <a href="https://amzn.to/2LM7Uxt" target="_blank" rel="noopener"><em>Zero to One</em></a> is called “All Happy Companies Are Different.” </p><p>Thiel’s book applies Girard’s ideas to business. Like Girard himself, he says companies should avoid competition and walk the path of differentiation. He explains that many businesses create a lot of value, but don’t capture a lot of the value they create. As a result, even very big businesses can be unprofitable. </p><p>According to Thiel, monopoly is the end state of every successful business. If you want to create and capture lasting economic value, don’t compete. The more unique companies are, the more the business world can flourish. Consider Thiel’s favorite example: the airline industry. </p><p>As I type these words, I’m sitting in the United Airlines lounge at Denver International Airport. I’m writing during a five-hour layover on my way from New York to Los Angeles. In front of me, I see a lemon yellow Spirit Airlines jet preparing for takeoff. To advertise its affordable prices, the engine on the right wing says “Home of the Bare Fare.” Like the Southwest Airlines Boeing 737 to its left, the rise of low-cost airline carriers reflects the price sensitivity of flyers. I’m part of the bargain-hungry tribe too. This morning, I woke up at 3:50am so I could take a dirt-cheap 6:10am flight from La Guardia. As part of the journey, I also swallowed a five-hour layover in Denver so I could pay with frequent flyer points. My body screams for sleep, my mind shouts for productivity, and thankfully, due to the triple-shot cappuccino on the table in front of me, I’ll meet my writing quota today. </p><p>Let’s wrap my morning in economic language. Air travel is an “elastic good.” Small changes in price lead to big changes in demand for a flight. Behavior differs between leisure travelers and business travelers. Leisure travelers are particularly sensitive to price fluctuations, so they fly much less when prices are high than when they are low. In contrast, business travelers don’t have as much flexibility. Since there’s money at stake, their decision to travel isn’t as influenced by shifts in price. </p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1565096037818-XIBA3FQ2TV3IMO9DVNC2/ke17ZwdGBToddI8pDm48kNItmlYLWjOhdFkbSNEI4Il7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QPOohDIaIeljMHgDF5CVlOqpeNLcJ80NK65_fV7S1UTJEG4ObxWoeKzkDNbM0JWlN92fiCVWcWi2bOYWE2fA0i-IQuZvRKQfyCKZS1O6APg/public.jpeg" alt="img"></p><p>The airline industry suffers from near-perfect competition. Each year, U.S airlines serve millions of passengers and create hundreds of billions of dollars in consumer value. But in 2012, when the average airfare each way was $178, the airlines made only 37 cents per passenger trip. Whenever one airline makes a move such as lowering prices or adding an extra inch of leg room, its rivals match it. Since all the airlines chase the same price sensitive customers, they compete for every sale. That’s why, compared to the major tech companies, the major airlines in America are starving for profit. </p><p>As a contrast to the hyper-competitive airline business, consider Google. Here’s Peter Thiel: </p><p><em>“Compare [the airlines] to Google, which creates less value but captures far more. Google brought in $50 billion in 2012 (versus $160 billion for the airlines), but it kept 21% of those revenues as profits—more than 100 times the airline industry’s profit margin that year.</em> </p><p><em>Google makes so much money that it’s now worth three times more than every U.S. airline combined. The airlines compete with each other, but Google stands alone.”</em></p><p>Perfect competition is the default state in Economics 101. In a perfectly competitive market, undifferentiated companies sell homogenous and substitutable products. Firms don’t have market power, so their prices are determined by the iron laws of supply and demand. </p><p>High profits attract competition. According to economic theory, if outside entrepreneurs hear about profits, they’ll start a new firm and enter the industry. Increased supply will drive prices down, which will decrease total industry profits. If too many firms enter the market, the entire industry will suffer losses. If companies start to lose money, they’ll go out of business until industry prices rise back to sustainable levels. Most importantly, in a world of perfect competition, no company will make an economic profit in the long run. Just like the airline industry.</p><p>Thiel offers an alternative to perfect competition: monopoly. Without competition, they can produce at the quantity and price combination that maximizes their profits. Successful strategies attract imitators, so the best businesses are difficult to copy. Firms in a competitive industry who sell a commodity product cannot turn a profit. But companies who have a monopoly can set their own prices since they offer an in-demand product that cannot be replicated. Monopoly firms are big fish in a small pond. </p><p>Don’t copy your neighbors.</p><h2 id="Section-2-Time-Moves-Forward"><a href="#Section-2-Time-Moves-Forward" class="headerlink" title="Section 2: Time Moves Forward"></a><strong>Section 2: Time Moves Forward</strong></h2><p><em>“The twentieth century was great and terrible, and the twenty-first century promises to be far greater and more terrible.” — Peter Thiel</em></p><p>In this section of the essay, we will depart from a focus on Thiel. Instead, we’ll explore Christianity and the history of time. By doing so, we will have the necessary context to frame Thiel’s worldview in the next section. </p><p>The Christian story begins with: “In the beginning, God created the heavens and the earth.” At its root, the story is about how the world went bad and how we can fix it. The world is broken because humans are broken. Human sin is responsible for the world’s evil, and our relationship with God is broken because it was ruined by human rebellion. God is the central character in the story. That’s why instead of worshiping things, Christians are instructed to worship their creator. God’s purposes are central, not theirs. Humans need to be ruled, and man must glorify its king. Only under God’s rule can man discover his deepest satisfaction and forever enjoy the Kingdom of Heaven. </p><p>The Resurrection is a symbol that someday, all wrongs will be made right. Christians do not take it as a symbol, but as a concrete fact. Christians say that if you believe in Jesus — that he was raised from the dead and is the Son of God — he will restore your life until every pain and heartache becomes untrue.</p><p>Linear conceptions of time, and especially the idea of progress, emerged with Christianity. In a cyclical conception of time, the circle of time closes where it opened. There is no beginning or end. For example, the Hindu Vedas <a href="https://timothykeller.com/blog/2015/4/4/when-hope-and-history-rhyme" target="_blank" rel="noopener">teach</a> that the world spins along an endless cycle: creation, rise, decline, destruction, and rebirth. Even if the cycle repeats for millions of years, it will continue to spin forever. </p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564974531795-RBQRFP9WFOQFA9YFDC8I/ke17ZwdGBToddI8pDm48kLOVLk7mjj0IdHlyQexAHBd7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QPOohDIaIeljMHgDF5CVlOqpeNLcJ80NK65_fV7S1UeCSdhuF7BxrqRN6qzDXkrA-nVwZ-e3O9GIUl7kHkvVlLlCCt6gcyTKcVPX2ZcI6AQ/IMG_0287.jpg" alt="img"></p><p>With a linear perspective, time moves from the past to the future. It begins with the Garden of Eden at the beginning of <em>The Bible</em> and ends with the Kingdom of Heaven. </p><p>With Jesus as its savior, Christianity is the only religion that sees a human as the Son of God. When Jesus died on the cross, he paid for the sins of humanity so he could end evil and suffering. Jesus speaks of his return to earth in Matthew 19:28. He says: “I tell you the truth, at the renewal of all things, the Son of Man will sit on his glorious throne.” Instead of relying on a cyclical re-birth<em>,</em> Jesus’ return will fix the material world by destroying all decay and brokenness. </p><h3 id="From-Cyclical-to-Linear-Time"><a href="#From-Cyclical-to-Linear-Time" class="headerlink" title="From Cyclical to Linear Time"></a><strong>From Cyclical to Linear Time</strong></h3><p>Religious or not, it’s worth studying Jesus Christ. He’s had more influence than anybody in human history. For example, Western Civilization divides time into two periods: before and after Jesus Christ. He’s a universal icon. </p><p>In a letter called <a href="http://www.john3-16.net/OneLife.htm" target="_blank" rel="noopener"><em>One Solitary Life</em></a><em>,</em> James Allen Francis wrote<em>:</em> </p><p><em>“Twenty centuries have come and gone, and today he is the central figure of the human race. I am well within the mark when I say that all the armies that ever marched, all the navies that ever sailed, all the parliaments that ever sat, all the kings that ever reigned—put together—have not affected the life of man on this earth as much as that one, solitary life.”</em></p><p>Earlier this year, I attended a series of <em>Questioning Christianity</em> lectures in New York City. Every Thursday, Tim Keller spoke about the core tenets of Christianity: faith, meaning, satisfaction, identity, morality, justice, and hope. In one of his talks, he spoke about the human transition from hope to optimism. From praying for a better world to working hard to ensure a better future. In the sermon, Keller argued that humans are future-oriented beings. If we don’t have a positive vision for our future, we become slaves to the desires of the present day and crumble under the suffering of daily life. That’s why we need to believe that our lives are marching towards an end that’s worth striving for. Otherwise, we will become adrift like a log in the ocean. </p><p>In his final lecture, Keller quoted Robert Nisbet, the author of <a href="https://amzn.to/2lfNHnn" target="_blank" rel="noopener"><em>The History of the Idea of Progress</em></a><em>.</em> In it, Nisbet argues that ancient people saw time as cyclical, and no idea has been more important to Western Civilization than the idea of progress. </p><p>The Ancients assumed that humanity was doomed to cycles of pessimism. Even if they held ideas of moral, spiritual, and material improvement, the idea that humanity can improve itself, step-by-step and stage-by-stage into an earthly paradise is uniquely Western. Christian theology sees time as linear. It moves away from the Garden of Eden, and toward a day of judgement, justice, and the establishment of a divine, peace-filled kingdom. </p><p>The linear perspective on time was born out of Greek philosophy. Controversial at the time, writers like Seneca wrote that mankind had advanced in the past, and will continue to advance in the future. But the idea of progress did not crystallize until St. Augustine. His book, <em>The City of God,</em> was the first full-blown philosophy of world history. By fusing the Greek idea of growth with the Jewish idea of sacred history, St. Augustine introduced a Christianity-inspired linear theory of humanity. He believed in the unity of mankind, a succession of fixed stages of human development, the assumption that all that has happened and will happen is necessary, and the vision of a future condition of heaven on earth. </p><p>Through a belief in Redemption, Christians turned their minds to the supernatural and adopted a belief in an eternal heaven. Nisbet writes: </p><p><em>“Of all the contributions to the idea of progress by Christian thought, none is greater than this Augustinian suggestion of a final period on earth, utopian in character, and historically inevitable.”</em></p><p>Christian ideals of progress are sprinkled throughout <em>The City of God</em>. At the end of his book, St. Augustine refers to the seven stages of early history. The last, still-yet-to-come stage will consist of peace and happiness on earth. He wrote that as a result of the inevitable historical development from the primitive world of the Garden of Eden, those who put their faith in Christ will experience an earthly paradise. ¹ </p><p>Beginning with the Greeks and accelerated by the Christian writers such as St. Augustine, Western philosophy is defined by the march towards heavenly perfection. People in the West see progress, evolution, and innovation as synonyms. We assume that increased freedom and knowledge is limited only by the passage of time and an active commitment to creating a better future. Like a law of nature, progress was as inevitable as cherry blossoms in the spring.</p><p>If time is cyclical, the future will look like the present. The arrow of time points back towards its origin and ends where it began. Taken to the extreme, cyclical perspectives on time implicitly remove human agency. No matter what you do, the world will return to its original state. </p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564974624673-3HJZJM704NRZ7USFNG9E/ke17ZwdGBToddI8pDm48kE3woK2OGmdCyhaycVEVmPV7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QHyNOqBUUEtDDsRWrJLTmtB678DRWVwYkSJZ19In_NUbZPNpuoJaH_1BSguT_1AsqGrMHrAxxN0fF5wessgPT/IMG_AEC1FBA9C6F6-1.jpeg" alt="img"></p><h3 id="Girardian-Sacrifice-How-Violence-Stops-Violence"><a href="#Girardian-Sacrifice-How-Violence-Stops-Violence" class="headerlink" title="Girardian Sacrifice: How Violence Stops Violence"></a><strong>Girardian Sacrifice: How Violence Stops Violence</strong></h3><p>Once Tim Keller’s lectures were over and I understood Nisbet’s philosophy of progress, I turned to a series of Rene Girard interviews. As I started reading, I was shocked to see Nisbet’s idea of progress fit Girard’s theory of Mimetics like a pair of puzzle pieces. </p><p>The similarities are stunning. Girard saw sacrifice and the scapegoat mechanism as the reason for Christianity and the center of human culture. The Christian story is the ultimate Girardian ritual because Jesus is a classic scapegoat, but with an all-important twist. Where previous myths were told from the perspective of the community, the Christian story is told from the perspective of the victim. And according to Girard, this is the essence of biblical revelation. The Gospels classify Jesus as a scapegoat. True to the scapegoat phenomenon, Jesus is not killed by the Romans, the Jewish priests, or by the crowd alone, but by everybody. The death of Jesus, like a scapegoat ritual, is a collective and community murder. </p><p>Like all scapegoat victims, Jesus is killed despite his innocence. Christianity reveals the radical injustice of the scapegoat phenomenon. All scapegoats are both insiders and outsiders. At once, they must be insider enough to be part of the community, but outsider enough to blame for the community’s problems. As the Gospel of <em>John</em> says: “It is better for one man to die for the people, than for the whole nation to be destroyed… They hated me for no reason.”</p><p>Sacrifice is a social event. Without sacrifice, human beings wouldn’t have a culture. All human societies are built around religion because it’s the only way to peacefully work with the scapegoat mechanism. When humans engage in a Mimetic crisis, the violence can only be fixed by murdering the scapegoat. This process of killing the victim again and again is the main peace pill in an archaic society. People perform ritual sacrifices together, and when a priest is appointed to kill a victim, he kills the victim in the name of the whole community. After all, a community can’t scapegoat somebody unless it thinks the scapegoat is guilty. That’s why scapegoating has to be unconscious. Once the group ritual is performed, violence is repelled and peace is restored for the community. </p><p>Ritual protects communities from the great violence of Mimetic disorder thanks to the real and symbolic violence of sacrifice. Girard said “sacrificial systems <em>contain</em> violence.” His message has two meanings. Violence is the disease <em>and</em> the cure for the disease. Sacrificial ritual is always violent. And yet, since the real and symbolic violence of sacrifice restores peace in the community, it prevents the escalation of runaway Mimetic violence. In that way, humanity contains violence with violence because sacrifice saves the community from its own violence. </p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564974684524-SZB8CAC4SFRUBONXDFBW/ke17ZwdGBToddI8pDm48kNIWMw20e2rpD9AJs9V3wFh7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QPOohDIaIeljMHgDF5CVlOqpeNLcJ80NK65_fV7S1UTBqb5QBHdmpv8ZQoymGU7mfTHFNWSsxjm-msNdQvH1l2lzU2CMcTThHXQNSS0o_ag/IMG_140381BF3BD0-1.jpeg" alt="img"></p><h3 id="How-Time-Relates-to-Girardian-Sacrifice"><a href="#How-Time-Relates-to-Girardian-Sacrifice" class="headerlink" title="How Time Relates to Girardian Sacrifice"></a><strong>How Time Relates to Girardian Sacrifice</strong></h3><p>It’s hard to gauge the impact of various philosophies of time. Even as I argue for it, I’m skeptical that a linear perspective on time is a meaningful driver of innovation and technological progress. And yet, my skepticism is balanced by my own relationship with my future self. </p><p>Creating explicit images of my future has made me healthier, happier, and much more productive. I re-write my 25-year vision multiple times per year. Then, twice a month, I meet with a personal coach to make sure my short-term actions sync up with my long-term goals. By treating my future self with the same respect as my current self, I’m better able to ignore the nagging impulses of the moment and work towards a better future for myself and humanity. </p><p>Fueled by a healthy skepticism, I’d love to see two studies. The first one would track the relationship between technological progress and conceptions of time. Scientists would ask proxy questions for determining a culture’s time horizon, and use it to evaluate its impact on productivity growth. The second study would measure the relationship between urban life and farm life. In my recent podcast conversation with Jason Zweig, he shared his experience growing up on a farm in upstate New York. Farm life encourages cyclical thinking in a way city life doesn’t. On a farm, you’re mesmerized by simple pleasures: the movement of the sun, the turn of the seasons, and the emotions of the turbulent skies. Aside from violent rainstorms and purple-painted sunsets, synthetic city environments take us away from nature. I suspect that people in cities are more likely to see time as linear, while people who grow up in nature see its cyclical traits, such as the rise of the sun, the seasonal thunderstorms, and the changing of the seasons. </p><p>Likewise, ancient cultures saw time like an endless wheel. They believed that every so often, the universe would wind down and burn up, and after this re-birth, history would begin again. And everything, from our bodies to our souls, would be purified. Relative to the Christian tradition, this philosophy assumes the futility of long-term progress. </p><p>Girard offers a historical perspective for the transition from cyclical time to linear time. He identified a cyclical loop: First, when a scapegoat is sacrificed, peace is restored in the community. Then, the culture lives peacefully for a short time. But eventually, tensions flare and violence returns to the community. To restore the peace, a new scapegoat must be named and sacrificed, which re-starts the sacrificial loop. </p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564974946224-HZU1H87ROOK5EO1DAT6C/ke17ZwdGBToddI8pDm48kFvPnEpQblTSbhPmIq4v7cd7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QPOohDIaIeljMHgDF5CVlOqpeNLcJ80NK65_fV7S1UYaiy_2s4kAknDPtsPV63i4AU4EuGrimHizczX-Dgqq9WIB-7cQgYKo_bDpR6cEVkg/IMG_008CF1AC84F7-1.jpeg" alt="img"></p><h3 id="How-Linear-Time-Drives-Progress-and-Long-Term-Thinking"><a href="#How-Linear-Time-Drives-Progress-and-Long-Term-Thinking" class="headerlink" title="How Linear Time Drives Progress and Long-Term Thinking"></a><strong>How Linear Time Drives Progress and Long-Term Thinking</strong></h3><p>To Peter Thiel, short-term thinking is the essence of sin. Like <em>The Bible</em>, he advises us to make plans and sacrifice the present for the future. Greatness is like chess. To win, you must study the end game and work towards the one you want to see. Thiel’s favorite chess player was José Raúl Capablanca who <a href="https://amzn.to/2JSBbo5" target="_blank" rel="noopener">said</a>: “To begin you must study the end. You don’t want to be the first to act, you want to be the last man standing.” </p><p>Thiel says a bad plan is better than no plan at all. Having no plan is chaotic. He supports people who trade the shiny mirage of short-termism for the calm, controlled grace of a long time horizon. Like Capablanca, they are the kinds of people who study the end-game and work backwards from there. </p><p>In a thought-provoking essay called <a href="https://www.patheos.com/blogs/inebriateme/2014/06/peter-thiel-and-the-cathedral/" target="_blank" rel="noopener"><em>Peter Thiel and the Cathedral</em></a><em>,</em> Pascal-Emmanuel Gobry argues that Cathedrals were the equivalent of the Apollo project in the High Middle Ages. Like America’s Apollo program, each Cathedral required a specific and ambitious plan for building it. Medieval cathedrals were the first man-made structures to soar higher than the Egyptian Pyramids, which were monuments to death. But cathedrals are dedicated to the triumph over death. Moreover, cathedrals can only be built with scientific knowledge and communal support. They require scientists, mathematicians, engineers, craftsmen, and artists. And all of them need a long time horizon. </p><p>Long time horizons aren’t just psychological. They’re cultural. Modern society suffers from temporal exhaustion. Or as, sociologist Elise Boulding once said: “If one is mentally out of breath all the time from dealing with the present, there is no energy left for imagining the future.” </p><p>As I’ve <a href="https://www.perell.com/blog/never-ending-now" target="_blank" rel="noopener">written</a> before, the speed of technology and the hyperconnectivity of society have placed us in a “never-ending now.” Like hamsters running on a wheel, we live in an endless cycle of ephemeral content consumption — a merry-go-round that spins faster and faster but never goes anywhere. Even the virtues of information consumption have changed. Most people I know care more about being informed than being well read. By focusing on the desperate screams of moody news anchors and not the books you’ll find in libraries, they let the culture’s moods dictate their own. The news has swept us into a dizzying chaos. When we whirl in its vortex, we become overwhelmed by the slightest breeze of chaos and lose sight of our place in history. </p><p>For the opposite perspective, consider the Japanese. Some of its citizens recently <a href="http://www.bbc.com/future/story/20190611-how-to-build-something-that-lasts-10000-years" target="_blank" rel="noopener">witnessed</a> the 66th cycle of a ritual that began more than 13 centuries ago. In a city called Ise, people have been rebuilding the grand Jingu shrine with wood and thatch since the 7th century. This Shinto ritual does more than keep the structure intact. It helps the master temple builder train the next generation and injects participants with a long-time horizon. This Japanese commitment to maintenance allows it to sustain structures and rituals for millennia. We shouldn’t be surprised that Japan is home to most of the oldest companies in the world. </p><p>With that said, I don’t endorse the Japanese perspective in all its forms. The country is not as innovative as it once was. When I speak with friends who do business there, they complain about the rigid hierarchies and the inability to take risks. Instead of copying the Japanese commitment to long-term thinking, we should learn from it and use Christian-theology to build upon it. </p><p>Thiel concludes that time is linear, not cyclical. The future won’t look like the present. It will either be much worse or much better. Or more explicitly, “stagnation leads straight to apocalypse.” If we don’t, we’ll suffer from limitless Mimetic violence; and if things go well, we might find our place in God’s peaceful kingdom. </p><p>Informed by its linear conception of time and the Christian image of heaven, Thiel applauds the grand visions of yesterday’s leaders. Modern presidents no longer inspire Americans with positive visions of the future. The visions of the past weren’t just ambitious. They were clear and specific. Unfortunately, there is no modern equivalent of the Manhattan Project, the Apollo Project, or Nixon’s 1974 plan to defeat cancer by the end of the decade. </p><p>Christians were the first group to reject cyclical time. They shouted that the future could be meaningfully better than the past. By doing so, they initiated a positive feedback loop, where progress led to progress, which led to more progress. </p><p>Guided by this belief in the possibility of progress, Christians follow a high-resolution painting of a perfect future. It’s as if humanity is on a mission. They believe humans are here to reflect God’s light onto the world. Instead of returning to the Garden of Eden, humanity will march forward, from the past to the future, and create “a new heaven and a new earth.”</p><h2 id="Section-3-The-Future-will-Be-Different-From-the-Present"><a href="#Section-3-The-Future-will-Be-Different-From-the-Present" class="headerlink" title="Section 3: The Future will Be Different From the Present"></a><strong>Section 3: The Future will Be Different From the Present</strong></h2><p><em>“And I saw a new heaven and a new earth: for the first heaven and the first earth were passed away; and there was no more sea.”</em> – Revelation 21:1</p><p>*”The cliche goes like this; live each day as if it were your last. The best way to take this advice is to do exactly the opposite: live each day as if you would live forever.” — Peter Thiel*</p><h3 id="A-New-Heaven-and-a-New-Earth"><a href="#A-New-Heaven-and-a-New-Earth" class="headerlink" title="A New Heaven and a New Earth"></a><strong>A New Heaven and a New Earth</strong></h3><p>The <em>Book of Revelation</em> is the last chapter in the New Testament. In this section, I interpret it in a way that supports the rest of Thiel’s conclusions. Inevitably, I have misspoken here. If I met Thiel, this is the section I would focus on. It’s foundational to Thiel’s worldview and I’ve never heard him speak about this section of <em>The Bible</em> in public. </p><p>Here’s what I do know: Thiel is trying to save the world from apocalypse. </p><p><em>The Book of Revelation</em> paints two outcomes for the future of humanity: catastrophic apocalypse or a new heaven and a new earth. Some of the Christians I know believe that humans aren’t literally taken out of this world and transported into heaven. Instead, as explained in <em>Revelations 21</em>, heaven comes down to earth. According to this vision, humanity will be cleansed, renewed and perfected. The horrors of the world will be undone. People will receive the lives they’ve always wanted. All evils will be repaired, and the pain of existence will vanish like evaporating water after a thunderstorm. Better yet, the joy and glory of a world after redemption will be greater because humans have suffered to reach it.</p><p>I suspect Thiel holds this philosophy. To Thiel, <em>The Book of Revelation</em> is more than a metaphor. It’s a playbook for guiding humanity from the garden of the past to the city of the future.</p><p>As Thiel once <a href="https://play.google.com/store/books/details?pcampaignid=books_read_action&id=nv_EshzTdXEC" target="_blank" rel="noopener">wrote</a>:</p><p><em>“For Girard, this combination of mimesis and the unraveling of archaic culture implies that the modern world contains a powerfully apocalyptic dimension.”</em></p><p>The probability of a civilization-ending apocalypse is increasing. Just because we no longer believe that Zeus can strike humans with sky-lighting thunderbolts, doesn’t mean that existential risk isn’t possible. Like Girard, he worries that the world is becoming more Mimetic. Worse, globalization is raising the threat of runaway mimesis and an apocalyptic world with cold corpses, dead horses, and splintered guns. </p><p>In an essay called <a href="https://www.hoover.org/research/optimistic-thought-experiment" target="_blank" rel="noopener"><em>The Optimistic Thought Experiment</em></a>, Thiel advises us to build the modern equivalent of Noah’s ark, so we can survive the floods of Girardian evil. Thiel fears that due to technologies like nuclear weapons, humans are already capable of destroying the world. With modern technology, a tiny number of people are capable of inflicting unprecedented levels of damage and death with the push of a single button. That though, doesn’t mean we should stop innovating. A lack of progress leads straight to a bleak, ravaged, and apocalyptic world. He <a href="https://www.hoover.org/research/optimistic-thought-experiment" target="_blank" rel="noopener">writes</a>: </p><p>*”The entire human order could unravel in a relentless escalation of violence — famine, disease, war, and death. The final book of the Bible, the Book of Revelation, even gives a name and a place: The Battle of Armageddon in the Middle East is the great conflagration that would end the world. Against this future, it is far better to save one’s immortal soul and accumulate treasures in heaven, in the eternal City of God, than it is to amass a fleeting fortune in the transient and passing City of Man.”*</p><p>Here, Thiel encourages us to be specific about the long-term future we want to create. Here, he counters the secular and Eastern philosophy. Under the secular mindset, there is no transcendent future after death. This is it. You have one life. Similarly, according to Eastern religions, we lose our individuality and lose our material lives so we can become part of the whole again. But Christianity offers a different perspective: work for the fruits of eternity instead of chasing the fleeting pleasures of the day. Don’t place too much weight on the present moment. Instead of focusing on meaningless scandals, endless political dramas, or the limitless accumulation of wealth, we should focus on the impending catastrophe at the end of the road. Work to prevent runaway Girardian violence. That way, when the Day of Judgement comes, we’ll lean towards the side of the good. </p><p>If there was ever a silver bullet, Thiel believes living with a long time horizon is it. </p><p>Whether the future is better or worse will depend on our actions. Like Girard, Thiel, believes that Western political philosophy cannot cope with global violence. In 2004, three years after 9/11, Thiel sponsored a philosophical conference called “On Politics and Apocalypse.” Thiel contributed an essay called <em>The Straussian Moment.</em> In it, he tried to find common ground between Girard’s Mimetic theory and the work of two right-wing political philosophers: Leo Strauss and Carl Schmitt. He argued that the issue of violence and existential risk has not been taken seriously enough since the Enlightenment. </p><p>Here are Thiel’s words: </p><p><em>“The Christian statesman or stateswoman knows that the modern age will not be permanent, and ultimately will give way to something very different. One must never forget that one day all will be revealed, that all injustices will be exposed, and that those who perpetrated them will be held to account.</em></p><p><em>The postmodern world would differ from the modern world in a way that is much worse or much better — the limitless violence of runaway mimesis or the peace of the kingdom of God… One must never forget that one day all will be revealed, that all injustices will be exposed, and that those who perpetrated them will be held to account.”</em></p><p>As a libertarian who holds the New Testament as a seminal text, Thiel seeks to increase individual freedoms while preventing runaway Mimetic violence. As promised, here’s where Girard’s observations of the past can shape our understanding of the present. Everybody condemns hate-fueled online speech. If Girard’s theories are accurate, online fighting might be the preventative medicine we need, even if it tastes disgusting and comes with painful side-effects. The forces of globalization and technology may have abolished the boundaries of violence. </p><p>If so, the cure is nested inside the disease. Online, social-media based arguments might repel an apocalyptic scenario. Perhaps Thiel sees Facebook as a place to contain unbounded Mimetic violence. It simultaneously perpetuates violence and prevents it from happening. After all, if people fight on social media, they won’t fight on the streets. Like a boiling kettle, we have to let out steam somewhere. Better to cool the pot on social media than in the streets. In the words of Thiel, “social media proved to be more important than it looked.”</p><h3 id="Four-Ways-of-Thinking-About-the-Future"><a href="#Four-Ways-of-Thinking-About-the-Future" class="headerlink" title="Four Ways of Thinking About the Future"></a><strong>Four Ways of Thinking About the Future</strong></h3><p>The pull towards Girardian conflict stems from pessimism and short-term thinking. In <em>Zero to One,</em> Peter Thiel describes four ways of thinking about the future: definite optimism, indefinite optimism, definite pessimism, and indefinite pessimism. In a definite world, the future is knowable. There is a predetermined plan for what the future will look like. An indefinite world is more of a random walk. Like a lottery, the future is out of our control. It’s governed solely by probabilities and chance events, which makes it impossible to act with any agency. </p><p>Thiel defines the four quadrants as such:</p><ol><li>Definite Optimism: The future will be better and we know how.</li><li>Indefinite Optimism: The future will be better and we don’t know how.</li><li>Definite Pessimism: The future will be worse and we know how.</li><li>Indefinite Pessimism: The future will be worse and we don’t know how. </li></ol><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564975060560-0DXVVDZX16QOPLQBBYOL/ke17ZwdGBToddI8pDm48kBUpuTF4u9jsbAT69wI375gUqsxRUqqbr1mOJYKfIPR7LoDQ9mXPOjoJoqy81S2I8N_N4V1vUb5AoIIIbLZhVYxCRW4BPu10St3TBAUQYVKccQTRi9IGDhUoBQdHlVR_0aPikrTW6Nn0KnIJ4c4cQlgtMCtxi1_ol3D9kcxNNS6X/IMG_ADBE7063D097-1.jpeg" alt="img"></p><h3 id="Background-to-Definite-Optimism"><a href="#Background-to-Definite-Optimism" class="headerlink" title="Background to Definite Optimism"></a><strong>Background to Definite Optimism</strong></h3><p>Innovation begins with inspiration. Positive visions of the future inject people with imagination, which pulls the future forward. </p><p>A quick browse through the history books shows that Americans, and especially the government, used to make big plans and live with Definite Optimism. To illustrate the idea, let’s turn to my favorite example: The Reber Plan. </p><h3 id="Reber-Plan"><a href="#Reber-Plan" class="headerlink" title="Reber Plan"></a><strong>Reber Plan</strong></h3><p>The Reber Plan is my favorite example of Definite Optimism. In the 1940s a San Francisco-based teacher and amateur theater producer devised a plan to reconstruct the San Francisco Bay Area. People took the plan seriously. Newspaper boards across California endorsed it.</p><p>Reber proposed two large earth and rock dams, one between San Francisco and Oakland, and another between Marin County and Richmond. Dams would drain water from north to south and convert the Bay from saltwater to freshwater. Congress explored the project. Engineers planned to construct a 32-lane highway and scatter high-rise buildings throughout the reconstructed city. To test the plan, the Army Corps of Engineers built a 1.5-acre scale model of the proposed design.</p><p>Ultimately, the Reber Plan didn’t work. The freshwater lakes would have evaporated too quickly. Nevertheless, due to the spirit of the post World War II age, people gave the Reber Plan the respect it deserved. </p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564975106379-KMQT1KZDJVSRJVQ1DJGD/ke17ZwdGBToddI8pDm48kKaZwhDzTx2Ja_ukng_xIwZ7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QHyNOqBUUEtDDsRWrJLTmbAPWDwNhuSEKyCuGePwJdkAvP4mGgjEBEMKYiL81Wpz0qbKb-0jyHhmGzttiY2gU/IMG_4393427F321B-1.jpeg" alt="img"></p><h3 id="Ford-Motors-Airplanes-During-World-War-II"><a href="#Ford-Motors-Airplanes-During-World-War-II" class="headerlink" title="Ford Motors Airplanes During World War II"></a><strong>Ford Motors Airplanes During World War II</strong></h3><p>As Americans geared up for World War II in the early 1940s, President Franklin D. Roosevelt (FDR) called upon the nation to increase its production of airplanes. But in a 1940<a href="https://www.mtholyoke.edu/acad/intrel/WorldWar2/fdr16.htm" target="_blank" rel="noopener"> speech</a> to Congress, FDR said: “I should like to see this Nation geared up to the ability to turn out at least 50,000 planes a year.” At the time, nobody thought FDR’s goal was possible. </p><p>Americans were still plagued by the Great Depression. Roosevelt spoke to 132 million Americans. Only 48,000 of them earned more than $2,500 per year, the modern equivalent of $40,000 in today’s dollars. Nearly one-third had no running water. And none of them had antibiotics or unemployment insurance. </p><p>At the time, <a href="https://www.amazon.com/dp/B00FJ5EPVG/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1" target="_blank" rel="noopener">Americans</a> were producing fewer than 1,000 planes per year. The Nazis had 7 million soldiers, but America had less than 200,000. American industry responded with passionate intensity. <em>Ford Motors</em> had never built an airplane, but America sought to produce more airplanes at Willow Run than Hitler produced in all of Germany. To build the plant, builders moved 650,000 cubic yards of dirt and laid 58 miles of grain tile underground. Production exceeded expectations. Ford Liberator bombers took flight in the spring of 1942, ahead of schedule. Within five years, Ford produced tens of thousands of airplanes per year. War production board chief Donald Nelson captured the ambition of the moment: “When we are talking about America’s war production job we are discussing the biggest job in all of history.”</p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564975186848-3VRDXOBLWUV58BZ7PVTB/ke17ZwdGBToddI8pDm48kPrzOqmQC7SYickfqNyTYvB7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QPOohDIaIeljMHgDF5CVlOqpeNLcJ80NK65_fV7S1URw2XfNYbDnNaUjg84gcbwmM_5dw8OAMeZiQXPoJdDJEfvSKcCiQDXJ8mOZZ-46MLw/IMG_1BC8A6CEC9A5-1.jpeg" alt="img"></p><p>Today, these bold visions would be ignored and dismissed as lunacy. Definite Optimism is withering. Big dreams are now seen as childish illusions. We no longer trust amateurs with vast imaginations, and we no longer challenge people to imagine futures that look radically different from the present. Instead, we defer only to experts with mainstream opinions. </p><p>The Reber model has been demoted from a grand vision of the future to a meager Sausalito tourist attraction. “Let’s dam the San Francisco Bay” is too grand and too specific. Instead, we say “Let’s improve the economy” or “promote information.” We doubt the potential of grand plans. Instead, we put our faith in small tweaks and A/B tests, implying that millions of small actions are a better way of improving the world and creating a desired future. </p><p>We’ve moved from an atmosphere of utopian promises to one of dystopian threats. Definite Optimism has disappeared.</p><h3 id="The-End-of-the-Future"><a href="#The-End-of-the-Future" class="headerlink" title="The End of the Future"></a><strong>The End of the Future</strong></h3><p>Since the Financial Crisis, tens of thousands of Americans have moved into the Indefinite Optimism and Definite Pessimism quadrants. </p><p>According to Thiel, this shift has been worse than acknowledged. A 2011 essay called<a href="https://www.nationalreview.com/2011/10/end-future-peter-thiel/" target="_blank" rel="noopener"> <em>The End of the Future</em></a><em>,</em> which lives on the homepage of the website of his venture capital firm, argues that progress has stagnated. We’ve shifted away from funding transformational companies and toward companies that solve incremental problems, and sometimes even fake ones. To be sure, he doesn’t only invest in companies with little competition like Palantir and DeepMind. His firm also invested in Airbnb, Stripe, and Postmates.</p><p>Today, we’ve narrowed the definition of technology to Angry Birds and goofy SnapChat filters. That’s why Thiel longs for the days when technology alluded to space, airplanes, and rockets that generated more energy than a small atomic bomb. </p><p>NASA’s star spangled splendor transformed consciousness. Astronauts with stomachs of steel traveled the impossible distances of space. The Apollo 8 mission required superhuman precision, equivalent in scale to throwing a dart at a peach from a distance of 28 feet, and grazing the top of the fuzz without touching the fruit’s skin. To reach the moon, America’s pioneers traveled across 240,000 miles, about fifty-eight times the distance Columbus sailed when he discovered the Western world. As the Apollo rockets pierced through the stratosphere, and navigated the pin-drop silence of outer space, they inspired people back on earth to expand their horizons.</p><p>Literally. </p><p>America’s imagination peaked in 1969, when Neil Armstrong stepped foot on the moon. He stepped on moon-dust less than a decade after Alan Shepard became the first American in space, and only 8 years after President John F. Kennedy’s speech at Rice University where he said: “We choose to go to the moon, not because it’s easy, but because it’s hard.” </p><p>As the American people watched their comrades explore the distant skies and travel to the moon, they thought they’d witnessed the opening of a new frontier. Humans were no longer trapped on the pale blue dot. Soon, all of humanity would traverse the stratosphere and soar through space. Science fiction writers such as Arthur C. Clarke predicted imminent commercial space travel, interstellar exploration, and genuine artificial intelligences. The Apollo Project didn’t just shake the Florida launchpads. It shook the entire world. </p><p>To echo the point, Thiel likes to quote a 1967 best-selling book called <em>The American Challenge</em>. The book predicted that America would be a post-industrial society by the year 2000. Americans would work four days per week and seven hours per day. The year would be comprised of 39 work weeks and 13 weeks of vacation.</p><p>Unfortunately, this dream never arrived. Transportation machines soared higher and faster for 200 years. In the span of a single lifetime, people went from traveling by horse and buggy to walking on the moon. Depending on who you ask, it seemed like humanity was guided by the invisible hand or an all-powerful God. Interstellar travel and vacations on the moon were the future, and everybody knew it. </p><p>In an unexpected twist, the physics stagnated. Transportation stopped improving. And today, we’re no longer pushing the limits of height and speed. </p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564975252284-VAGADQYUZNQPRLINDSBY/ke17ZwdGBToddI8pDm48kFdB3nRHqglsJvgpYyN_1f17gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QPOohDIaIeljMHgDF5CVlOqpeNLcJ80NK65_fV7S1UVkJle2m9-S7BGBuh77W7SKuf0_v2lG_5U9-uoGPNKoqfvP3SPHe6Ky8NGlef7R0IQ/IMG_D47E8ED52D66-1.jpeg" alt="img"></p><p>Just ask Pan American World Airways, the iconic airline of the Post World War II era. After Americans stepped foot on the moon, the airline’s customer center was inundated with phone calls from around the country. First the astronauts. Then, the people. Customers wanted to reserve seats on the first trips to the moon. Between 1968 and 1971, Pan Am accepted 93,005 reservations for planned commercial flights to the moon. Fast forward five decades and only 12 men have ever walked on the moon. No American, let alone any ordinary human being, has stepped foot on the moon since 1972. </p><p>The rate of technological progress is slowing. The only major exceptions are semiconductors, DNA sequencing, and communications technology. Side effects of slow growth plague the economy. Real median wages haven’t risen since 1973. Meanwhile, the costs of housing, healthcare, and education are rising faster than inflation. More than 40 million Americans are collectively liable for more than $1.5 trillion in student loans. </p><p>In response, we’ve lowered our efficiency standards. The Golden Gate Bridge was built in less than four years in the 1930s. The recently completed Golden Gate Bridge access road, Doyle Drive, took seven years to build and cost more in real dollars than the original bridge. Buildings, too. The Empire State Building was built in 15 months from 1931-1932. 80 years later, The Freedom Tower took more than 12 years to build. We’ve masked our lack of progress with government money printing, rising debt levels, and distractions of digital technology. </p><p>America is not as dynamic as it once was. We see it in the statistics and feel it in our politics. And yet, ask the average person, and they’ll tell you that we’re living in a world of exponential technological growth. </p><p><em>Don’t believe Thiel?</em> </p><p>Follow the money. Warren Buffett, the richest investor in America bets <em>against</em> change. The less the world changes, the more Buffett succeeds. BNSF Railway, where Buffett recently invested $44 billion is the largest non-financial company in the <em>Berkshire Hathaway</em> portfolio. Thiel proclaims that 40 percent of railroads involve the transport of coal, so Buffett’s investment will do especially well if the travel and energy consumption patterns of the 21st century look like the past. </p><p>After digging through the <a href="https://www.berkshirehathaway.com/2018ar/linksannual18.html" target="_blank" rel="noopener"><em>2018 Berkshire Hathaway Annual Report</em></a>, I’d like to add context to Thiel’s thesis. Buffett’s firm has poured millions of dollars into renewable energy. In addition to coal and natural gas, Berkshire Hathaway Energy (90% owned by Berkshire Hathaway) has made meaningful investments in solar, nuclear, hydro-electric, geo-thermal, and in particular, wind.</p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564975279563-TIFLPWMW6VTCMS1KWRZ4/ke17ZwdGBToddI8pDm48kCXbIGZCF5ISkA_i8r8HbVd7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z4YTzHvnKhyp6Da-NYroOW3ZGjoBKy3azqku80C789l0kMlYkjvFlctRdmAM11rxFSdbx_99JZwzhc9EL4JfGfzX23cSFIMy00fXD13UHqklA/IMG_0256+2.jpg" alt="img"></p><p>From a distance, we see a mirage of progress. From up-close, once we remove the smartphone screens in front of us, we feel the reality of struggle and stagnation. According to a recent survey, 80% of Americans think the next generation will be worse off than the current generation. As Tim Keller wrote in <a href="https://amzn.to/2YuNhHI" target="_blank" rel="noopener"><em>Making Sense of God</em></a>: </p><p><em>“Younger Americans today are perhaps the first generation to be certain that they are and will be “worse off” than their parents. The interconnected nature of the world makes nightmare scenarios—pandemics, global economic collapse, climate-change disaster, cyberattacks, terrorism—all seem like genuine possibilities, even probabilities… Today hope has narrowed to the vanishing point of the self alone. In our current phase of American history we have lost belief in God and salvation, or in any shared sense of national greatness and destiny.”</em></p><p>This intuition is supported by data. <a href="https://www.federalreserve.gov/econres/feds/files/2018080pap.pdf" target="_blank" rel="noopener">Millennials</a> are less well off than members of earlier generations were when they were young. They have lower earnings, fewer assets, and less wealth. Children born in 1940 had a 90% chance of earning more than their parents. But <a href="https://www.theatlantic.com/magazine/archive/2019/08/raj-chettys-american-dream/592804/" target="_blank" rel="noopener">children</a> born in the 1980s have only a 50% chance. Christoper Kurz, an<a href="https://www.wsj.com/articles/playing-catch-up-in-the-game-of-life-millennials-approach-middle-age-in-crisis-11558290908" target="_blank" rel="noopener"> economist</a> at the Federal Reserve has shown that millennial households had an average net worth of about $92,000 in 2016, nearly 40% less than Gen X households in 2001, adjusted for inflation, and about 20% less than baby boomer households in 1989. Wages tell a similar story. In short, millennials have it tough and it isn’t their fault. With the <a href="https://foundersfund.com/2016/06/thought-thoughts-future/" target="_blank" rel="noopener">rise</a> of dystopian films, Hollywood creates and reflects these dark predictions about the future.</p><p>Unable to pay for college or afford an apartment in a job-filled city, many Millennials have lost hope. </p><p>One friend doesn’t want to have kids because “the entire state of California is going to be underwater by 2050.” Or, in the <a href="https://twitter.com/meganamram/status/968996931681701888?lang=en" target="_blank" rel="noopener">words</a> of a comedian on Twitter: “The fun part about living right now is we get to see how it ends.”</p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1564975315198-7P7IFYEBUP6BEOSCDQDF/ke17ZwdGBToddI8pDm48kIMxVCg35uqaPOlx-oxn9Ox7gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z4YTzHvnKhyp6Da-NYroOW3ZGjoBKy3azqku80C789l0hReLB75oIvKxcDxwlnLXaZFR4tDyWV9kaRnVEht_lV2Eb6513DCblt9X3MT3YECLQ/image-asset.jpeg" alt="img"></p><h3 id="Millennials-Young-and-Yearning"><a href="#Millennials-Young-and-Yearning" class="headerlink" title="Millennials: Young and Yearning"></a><strong>Millennials: Young and Yearning</strong></h3><p>When I speak with friends and travel the 50 states, I’m struck by how numb many people are to the world. Besides immigrants and their children, both of whom inspire me with their ambition and passionate work ethic, I see fear, complacency, and extreme risk-aversion everywhere. </p><p>Benjamin Franklin once said: “If everyone is thinking alike, then no one is thinking.” </p><p>The most talented people follow the same narrow tracks. People are afraid to dream big or stand out. Without a positive vision for their future, these young Americans are stuck playing vicious, zero-sum status games. Instead of constructing our own desires, they mirror the goals of people around them. Patrick Collison, the CEO of Stripe, <a href="https://patrickcollison.com/advice" target="_blank" rel="noopener">shared</a> a similar observation: </p><p><em>“If you’re in the US and go to a good school, there are a lot of forces that will push you towards following train tracks laid by others rather than charting a course yourself. Make sure that the things you’re pursuing are weird things that you want to pursue, not whatever the standard path is. Heuristic: do your friends at school think your path is a bit strange? If not, maybe it’s too normal.”</em></p><p>There’s a lack of differentiation. As Thiel observed: </p><p><em>“There is something very odd about a society where the most talented people get all tracked toward the same elite colleges, where they end up studying the same small number of subjects and going into the same small number of careers… It’s very limiting for our society as well as for those students.”</em></p><p>The top colleges have become vocational schools for investment banking and management consulting. In 2007, for example, half of Harvard seniors took jobs in finance or consulting. This mirrors my own experience. My college jobs department steered us towards high-status jobs instead of high-impact ones. Students, professors, and advisors cared more about perception than reality. It felt as if the goal of life wasn’t to improve the world, but to win awards and build an impressive resume. Instead, my smartest friends were pushed towards a handful of fields: law, management consulting, and investment banking. Other options were peripheral and besides the point. </p><p>Young Americans are trapped by student loans, crippled by path dependence, and constrained by runaway housing costs. They’re raised in institutional environments where conformity is praised and originality is punished. Like Pavlov’s rats, they’ve responded with authoritarian obedience. To no fault of their own, they’re sleepwalking through life as if their best years are already behind them. </p><p>I recently had dinner with a fraternity brother in Manhattan. Let’s call him Jim. Right after the bacon cheeseburgers arrived and just as we splattered ketchup on our crispy French Fries, I asked him how he liked his job. First, he paused for time. Then, he wiggled his eyes left and right, and said “Good. I’m learning a lot.”</p><p>Immediately, I smirked and questioned his answer. It reeked like Orwellian doublespeak. In my experience, “learning a lot” is code for “boring, but I’m putting up with it.” </p><p>Jim told me he liked his job because it taught him how to “collaborate” and “work with people.” His words sounded like they were parroted from the company’s Human Resources department. I poked and poked. And after 10 minutes, we reached the truth. </p><p>He explained how the school system taught him to follow rules, mimic his peers, and listen to teachers. That’s how Jim was taught to succeed, so that’s his strategy for climbing the corporate ladder. It’s as if the age-based fraternity hierarchy never left his mind. Pledge first. Succeed later. All the while, he’s spent years marching along the institutional track, obeying orders and doing exactly what others told him to do, without questioning why he should listen to them in the first place.</p><p>Spoiler alert: Jim is wasting his time.</p><p>He knows how to get things done, but never asks if it’s worth doing in the first place. Instead of working on important problems, he’s building “options” for the future. Like so many other college graduates, he’s been pushed into a mundane and uncreative profession. His dream-filled heart is crushed by the cold logic of investment banking. His words echo those of another friend, who said: “I’m just trying to get through the next 25 years as fast as possible.” </p><p>Sparkling dreams have become minor annoyances, like a buzzing fly in a lakeside cabin. Student loans keep him stuck on the institutional treadmill. He paid too steep a price for college, and now he’s unable to question the system and forced to accept the institutional doctrine as gospel. As I listened, I wondered what would happen if a high-voltage defibrillator shocked him and he woke up from his intellectual slumber. </p><p>Until then, he’ll stagger along the soul-crushing stepping stones of life: work hard in middle school so you can do well in high school; work hard in high school so you can do well in college; work hard in college so you can get a respected job; and get a respected job so one day, towards the end of your career, you can finally do what you want to do. All the while you “build skills” and “accumulate options,” as if the next corner will provide the happiness you’ve been seeking all along. </p><p>In an essay called <a href="https://www.thecrimson.com/article/2017/5/25/desai-commencement-ed/" target="_blank" rel="noopener"><em>The Trouble with Optionality</em>,</a> Harvard professor Mihir Desai worries that the language of finance has polluted life. He condemns the modern, finance-fueled affair with optionality. Rather than taking risks or working on important projects, students acquire options. In finance, when you hold an option and the world moves with you, you enjoy the benefits; when the world moves against you, your downside risk is protected and you don’t have to do anything. The more optionality, the better. Picking a path reduces optionality, so people stay in limbo and don’t make commitments. This language doesn’t only apply to career planning. Some students talk about marriage as the death of optionality. But life is not like options trading. </p><p>Optionality is a means to an end, not the end itself. Our obsession with optionality can backfire. In theory, these safety nets give them freedom. Bolstered by the confidence of security, they can jump head-first into ambitious projects. In practice, they become habitual acquirers of safety nets and never work on anything of substance. The longer they spend acquiring options, the harder it is to stop.</p><p>Desai advises:</p><p><em>“The shortest distance between two points is reliably a straight line. If your dreams are apparent to you, pursue them. Creating optionality and buying lottery tickets are not weigh stations on the road to pursuing your dreamy outcomes. They are dangerous diversions that will change you.”</em></p><p>When we pursue optionality, we avoid bold decisions. Like anything meaningful, venturing into the unknown is an act of faith. It demands responsibility. You‘ll have to take a stand, trust your decision, and ignore the taunts of outside dissent. But a life without conviction is a life controlled by the futile winds of fashion. Or worse, the hollow echoes of the crowd.</p><p>By brainwashing us into thinking that prosperity is inevitable, privilege can have a numbing effect. Among my friends in the upper echelons of society — the ones with the means to pursue transcendent dreams — I wonder if they’re too comfortable. Nobody believes in destiny. Social events revolve around binge drinking and conversations so superficial a robot could automate them. They’re dozing off in an intellectual slumber. Rather than rising to the level of their dreams, they fall to the average of their environment. In my college classes, where the annual education costs $40,000 per year, the vast majority of students wasted the time away on Facebook. Office hours were an afterthought. “Try hards” were mocked and made-fun-of, and nobody had a vision for their future.</p><p>We lack courage, not genius. We’re swimming in money, but starving for ambition. Every venture capitalist I meet says there’s too much money and not enough good ideas. As Peter Thiel reminds us:</p><p>*”Progress is neither automatic nor mechanistic; it is rare. Indeed, the unique history of the West proves the exception to the rule that most human beings through the millennia have existed in a naturally brutal, unchanging, and impoverished state. But there is no law that the exceptional rise of the West must continue.”*</p><p>We increasingly believe that progress is inevitable. Progress, though, is not guaranteed. We must work for it. Otherwise, our living standards will not improve, and may get worse. </p><h3 id="The-Promise-of-Christianity"><a href="#The-Promise-of-Christianity" class="headerlink" title="The Promise of Christianity"></a><strong>The Promise of Christianity</strong></h3><p>To offer solutions, Thiel turns to the Christian value of hope. He has a heterodox view of Christianity. In his reading of history, the non-violence of Jesus is the antidote to Mimetic conflict. </p><p>When I speak with Christians, they always return to the importance of hope. They have a point. Our beliefs about the future impact our thoughts about the present. The more we can turn our attention away from the ephemeral present and towards the eternal future, the more we can pursue grand visions and persist through the challenges of the day. The present cannot be divorced from the future. They are codependent. </p><p>One of my friends works for a California-based investment firm which manages $6 billion in investment assets. For the first three years, during the initial fundraising process, investors turned their cheeks. The firm struggled to raise capital. And yet, in the face of rejection, the fund’s Christian founder maintained faith in the face of struggle. As my friend observed: “She succeeded because her Christianity gave her hope.” </p><p>Our spirits rise when hopes are high. That’s why the day before Christmas is as exhilarating as Christmas Day. Big, bright gifts sit under the tree. Smaller ones hang in firetruck-red socks over the living room fireplace. Children play. Parents cook. Grandparents tell stories. And the rush of anticipation releases everybody’s serotonin.</p><p>Likewise, everybody knows that a team with belief is hard to beat. But a team that doesn’t believe they can win is hopeless. The importance of belief and momentum is evident to any shouting fan in any arena across the country. And yet, few consider its importance at the societal level. </p><p>Christianity promises a Living Hope that enables believers to endure unimaginable suffering. A hope so resilient that like a Captain America’s shield, it can survive any evil, any sickness, or any torture. No matter the obstacles, certainty about the future gives you the confidence to act in the present. </p><p>Thiel’s idea of Definite Optimism is Christian theology cloaked in secular language. By raising our spirits, a positive vision for the future unites society and raises our spirits. And that’s what the Western world needs right now.</p><p>Technological growth is the best way to reduce suffering in the world. Technological progress has stagnated since the 1970s, which contributes to the vile political atmosphere and the pessimism of modern Westerners. Thiel says we should acknowledge our lack of progress, dream up a vision of Definite Optimism, and guided by Christian theology, work to make it a reality.</p><h2 id="Section-4-Peter-Thiel’s-Advice"><a href="#Section-4-Peter-Thiel’s-Advice" class="headerlink" title="Section 4: Peter Thiel’s Advice"></a><strong>Section 4: Peter Thiel’s Advice</strong></h2><p><em>“Enter through the narrow gate. For wide is the gate and broad is the road that leads to destruction, and many enter through it. But small is the gate and narrow the road that leads to life, and only a few find it.” (Matthew 7:13)</em></p><p>Now that we’ve outlined the Christianity-inspired foundations of Peter Thiel’s worldview, we’ll close with Peter Thiel’s advice for how to live. I’ll conclude with three actionable, Thiel-inspired principles: (1) create a positive vision for the future, (2) be careful who you copy, and (3) follow the Ten Commandments. </p><h3 id="Search-for-Secrets"><a href="#Search-for-Secrets" class="headerlink" title="Search for Secrets"></a><strong>Search for Secrets</strong></h3><p><em>“It is the glory of God to conceal a matter; to search out a matter is the glory of kings.” —</em> Proverbs 25:2</p><p>Thiel opposes the idea that luck is all-powerful. He encourages human agency and believes in the power of a single individual to bend the future to their will. Thiel believes we attribute too much to luck, which stops us from actually doing things. As he proclaimed, “you are not a lottery ticket… you can either dispassionately accept the universe for what it is, or put your dent in it, but not both.”</p><p>For example, if you treat startup investments like a series of lottery tickets, you won’t think hard about them, and as a result, you will fail. Thiel asks: “Is this a business that I have enough confidence in that I would consider joining it myself?” If yes, he’ll consider an investment. If the answer is no, he won’t. He doesn’t see the world as a mere distribution of luck-based outcomes. Instead, he praises conviction, bets on transcendent founders, and invests in the kind of companies he’d want to work for. </p><p>God is an all-encompassing term for things we don’t understand. Under that definition, luck is the secular God. Naturally, Thiel speaks about luck in the context of startup investing. “It’s just a matter of luck” is a statement of the deep nature of the universe. Deferring to luck is counter-productive. Treating people and events like lottery tickets makes us doubt our agency. </p><p>Look for secrets instead of luck. Thiel recommends one book: <a href="https://amzn.to/2Kjdjcc" target="_blank" rel="noopener"><em>Things Hidden Since the Foundation of the World</em></a> by Rene Girard. The title is as revealing as the contents of the book. It comes from <em>Matthew 13:35,</em> which reads: “I will proclaim what has been hidden [since] the foundation of the world.” </p><p>In job interviews, Thiel famously asks: “What very important truth do very few people agree with you on?” With it, Thiel can identify heterodox thinkers who aren’t blinded by Mimetic dogmas or intellectual fashions. He insists that there are still secrets left to uncover. Some are small and incremental. But the most valuable secrets are big enough to shake the world. Like Easter eggs, these broad and unconventional truths are hidden in places where nobody looks. You can find them, but you have to dig in obscure places. Other secrets are hidden in plain sight. They’re so obvious that nobody thinks about them. And once you learn about them, you’ll pinch yourself for not seeing them before. </p><p>Writing in <a href="https://amzn.to/2KeHa5e" target="_blank" rel="noopener"><em>Zero to One</em></a>, Thiel says: </p><p><em>“The big secret is that there are many secrets left to uncover. There are still many large white spaces on the map of human knowledge. You can go discover them. So do it. Get out there and fill in the blank spaces. Every single moment is a possibility to go to these new places and explore them.”</em></p><p>Thiel’s attraction to secrets comes from a conservative writer named Leo Strauss. His writing was obscure because he hid truths behind a curtain of mystery. That way, they would only be shared with a small, select group of people. Make no mistake. Even today, forbidden truths are exchanged in closed forums, private conferences, and corner offices on the 72nd floor. They’re shared in whispers, not shouts. </p><p>Strauss did not believe in transparency. He believed that even in the most open-minded societies, many truths were too problematic to be shouted. His contemporary disciples, like Thiel, conceal their words. They hide controversial ideas in esoteric language, and Strauss described the benefits as such:</p><p>*”It has all the advantages of private communication without having its greatest disadvantage—that it reaches only the writer’s acquaintances. It has all the advantages of public communication without having its greatest disadvantage—capital punishment for the author… Their literature is addressed, not to all readers, but to trustworthy and intelligent readers only.”* </p><p>Sometimes, Straussians hide truths in plain sight. When they do, they’re concealed in unpopular characters, such as devils, beggars, and buffoons. Pseudonymous Twitter accounts are the new Straussian philosophers, but with one important twist. Instead of sharing their names and hiding the truth, today’s Straussians hide their names, but share the truth. </p><h3 id="Be-Careful-Who-You-Copy"><a href="#Be-Careful-Who-You-Copy" class="headerlink" title="Be Careful Who You Copy"></a><strong>Be Careful Who You Copy</strong></h3><p><em>“Then I saw that all toil and all skill in work come from a man’s envy of his neighbor. This also is vanity and a striving after wind.” —</em> Ecclesiastes 4:4</p><p>Even if imitation is inevitable, we can reduce the negative effects of it. We can avoid the kinds of competition that lead to violence. If Girard is right, we are not as individualistic as we think we are. If we must copy others, we should be careful who we copy. </p><p>Thiel encourages people to ask themselves: “How do I become less competitive in order that I can become more successful?”</p><p>Ask a Christian and they’ll say that you should <em>only</em> imitate Jesus. That’s why, in <em>Revelations,</em> humanity receives a warning: “In the future, an Antichrist will come who brings a promise: we can all be Gods and models for one another, and we can all live in harmony together.” In a world where everybody is a model, anybody can become a scapegoat. This is a recipe for evil. Rather than turning to each other for answers, the Bible tells us to imitate Jesus, and nobody else. Or as Christ says: “Imitate me as I imitate the father.”</p><p>I’m not sure that works for me. I feel an intellectual pull towards Christianity, but not an emotional one. Many of my secular friends feel the same way. Telling them to only follow Jesus’ teachings wouldn’t be productive. To a Christian, Jesus’ words carry the weight of the world. To me, they’re like a brick: heavy enough to make me careful, but light enough to add other ones to my mental backpack. </p><p>According to Girard, the more differentiated a society, the more stable it is. But on the internet, everybody feels like an undifferentiated peer. Social media decreases the distance between people and their role models, so the pull to idolize false gods is greater than ever. Pair that with the blank slate theory that anybody can do whatever they want, and you have a recipe for runaway Girardian conflict. YouTube celebrities and Instagram influencers sell the exact kinds of behaviors that the Bible warns us about. By manufacturing envy, they tell fans that if they look like them, dress like them, and act like them, they can become them. </p><p>We all form our identity by looking towards others. Since everybody copies, we can improve society by encouraging people to copy the right people. As a kid, back when I was 100% sure I was going to be a professional baseball player, I looked up to J.T. Snow, the first basemen for the San Francisco Giants. I was obsessed. I scavenged the kids’ section for his jerseys and waited patiently for autographs at the annual Giants meet-and-greet. I copied his mannerisms, his jersey number, and his position on the baseball field. And in 4th grade, I brought a chocolate ice cream cake to school to celebrate <em>his</em> birthday. </p><p>Here’s how Thiel would respond to my imitative instincts: Be careful who you copy. If you’re going to follow a role model, find one who you won’t compete with. Don’t look to your peers for answers. Find somebody in a different stage of life who you admire and respect. They should be somebody who defied the status quo and took an independent path. In life, you have two options: (1) you can dispassionately accept the universe for what it is, or (2) you can put your dent in it. But you can’t do both. </p><p>Win the decade, not the day. For example, if you’re a writer, your goals should transcend the <em>New York Times Bestseller List.</em> Think bigger than that. If you’re going to model a famous writer, pick a dead one such as Tolstoy or Hemingway. They are real enough to model. Since they’re dead, you won’t compete with them directly. Better yet, you can copy more than their writing. If you want to stretch your imagination, you can live where they lived and read what they read. That way, you can ignore superficial status competitions and think beyond the day-to-day stress of writing a book.</p><p>I suspect this is why Thiel admires Elon Musk so much. Since the first day of SpaceX, Elon has been on a mission to go to Mars. Since the entire company was aligned around the mission, the employees were motivated and paddling the boat in the same inspiring direction.</p><p>Great people trade the temptations of today for the trophies of tomorrow. Think like you’re immortal. Place the eternal before the perishable. Treat people like you’ll know them for the next ten thousand years and work on the kinds of projects you’ll be proud to tell your grandchildren about. Live like you’ll be alive forever. When in doubt, follow the Ten Commandments.</p><h3 id="Follow-the-Ten-Commandments"><a href="#Follow-the-Ten-Commandments" class="headerlink" title="Follow the Ten Commandments"></a><strong>Follow the Ten Commandments</strong></h3><p><em>“Thou shalt not covet your neighbor’s goods.” — 10th Commandment</em></p><p>To return to our initial question about the significance of the Cain and Abel story, we return to Rene Girard. From history, Girard learned that human relations are built on the primacy of violence. That’s why the Cain and Abel story is the archetypal example of Mimetic conflict, and Thiel sees Christianity as the optimal solution to apocalyptic violence. </p><p>As Girard once said: “There are fundamentally only two ways of looking at religion: as superfluous, added on—or as the origin of everything.” If there can be no in-between, I suspect that like Girard, Thiel sees religion as the origin of everything.</p><p><img src="https://images.squarespace-cdn.com/content/v1/55576406e4b02e4679105dc2/1565039002802-ZUKB0ZJ0HDNFYY01BL0U/ke17ZwdGBToddI8pDm48kFcjlnj0YL8Xxvs_4YKGxU97gQa3H78H3Y0txjaiv_0fDoOvxcdMmMKkDsyUqMSsMWxHk725yiiHCCLfrh8O1z5QPOohDIaIeljMHgDF5CVlOqpeNLcJ80NK65_fV7S1UfPG8xZ3pam-5f84PQP8Uc2u1Rf9Hdub3Nt19A9a4fIoIy6s5IQUKHhVn5UapeK2tg/public.jpeg" alt="img"></p><p>Thiel closed his<a href="https://www.youtube.com/watch?v=kjTlvw8Wh-8" target="_blank" rel="noopener"> Dave Rubin interview</a> with practical career advice, inspired by the Ten Commandments. </p><p>The first commandment says that we should only look to God. There is only one God and you should worship him. Look up, not around. Follow <em>The Bible,</em> which says there is no salvation in anyone other than Jesus. You won’t figure out what to do by looking at your peers, so don’t copy the people around you. Instead, we’ll end up in copycat rivalries where we claw and fight with each other like crabs in a bucket. </p><p>The last commandment says you shouldn’t covet your neighbor’s goods. Inspired by the 10th commandment, Thiel encourages listeners to avoid competition. True to Mimetic Theory, the last commandment focuses on the neighbor instead of the object of desire because all objects are desirable when they belong to your neighbor. Society will push you towards competition, but you shouldn’t compete with your peers or depend on them for guidance. Competition is for losers. Instead of looking to the people around you for answers, find models that you cannot compete with. If you’re Christian, follow Jesus, and if you’re not, follow an intellectual hero who is way ahead of you. Rather than using your peers as a reference point, find your own transcendent orientation. </p><p>Let the flame of Definite Optimism burn away the Mimetic virus. Use the Internet to curate your environment, so you can be hyper-mimetic towards the rare few who are anti-mimetic. Copy the people who don’t copy people. Take risks. Build a differentiated skillset. Pursue timeless wisdom, not intellectual fashions. Be skeptical of convention, and don’t let it double as a shortcut to the truth. Work on problems that <a href="https://www.perell.com/blog/what-should-you-work-on" target="_blank" rel="noopener">nobody else is working on</a>, especially if you’re uniquely capable of solving them. And ultimately, ask the questions you’re not supposed to ask, so you can find the answers you’re not supposed to find. </p><p>Guided by the Cain and Abel story, remember the danger of imitating the wrong person. At first, it can inspire cooperation. But over time, it leads to envy, violence, and the apocalypse. </p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a><strong>Footnotes</strong></h3><p>¹ In addition to St. Augustine, writers such as Adam Smith, Thomas Jefferson, and Benjamin Franklin supported Christian ideals of progress. Adam Smith’s book, The Wealth of Nations is regarded as economics’ foundational text. Smith declares that there’s a natural order to the progress of nations. His “invisible hand” doesn’t just speak to the stability of the economic system, but also to the natural progress of wealth, labor, skill, rent, and profits. Western civilization is built on these ideals. Two of America’s founding fathers, Thomas Jefferson and Benjamin Franklin operated with a similar progress-inspired philosophy.</p><p>Writing two years before his death in 1824, Thomas Jefferson marveled at all the progress he had witnessed in his life: “And where this progress. No one can say. Barbarism has, in the meantime, been receding before the steady step of amelioration, and will in time, I trust, disappear from the earth.”</p><p>Likewise, in a letter to a friend, Benjamin Franklin wrote: “It is impossible to imagine the height to which may be carried, in a thousand years, the power of Man over Matter.”</p><h3 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a><strong>Acknowledgements</strong></h3><p>Thank you to Kevin Harrington for the conversations that led to this post. Your wisdom and feedback is invaluable to me, and I’m grateful for our friendship. This essay is for you. </p><p>Thank you to the other people who contributed to this essay through feedback and conversation: Brent Beshore, Lyn Cook, Nick Maggiulli, Sid Jha, Bushra Farooqui, Jeremy Giffon, James Patterson, Manan Hora, Ben Colley, and Michael Naka.</p><p>Cover Photo: <a href="https://www.flickr.com/photos/jdlasica/" target="_blank" rel="noopener">JD Lasica</a> | <a href="https://creativecommons.org/licenses/by/2.0/" target="_blank" rel="noopener">CC 2.0 License</a> via <a href="https://www.flickr.com/photos/jdlasica/16103310713/in/photostream/" target="_blank" rel="noopener">Flickr.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Peter-Thiel’s-Religion-—-David-Perell&quot;&gt;&lt;a href=&quot;#Peter-Thiel’s-Religion-—-David-Perell&quot; class=&quot;headerlink&quot; title=&quot;Peter Thiel’s Reli
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>bash学习</title>
    <link href="http://yoursite.com/2020/12/10/bash%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/12/10/bash%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-12-10T08:38:24.000Z</published>
    <updated>2020-12-10T08:55:44.560Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="学习bash"><a href="#学习bash" class="headerlink" title="学习bash"></a>学习bash</h3><p> <a href="https://github.com/bobbyiliev/introduction-to-bash-scripting" target="_blank" rel="noopener">introduction-to-bash-scripting</a>的学习笔记 配合 <a href="https://repl.it/languages/bash" target="_blank" rel="noopener">线上bash解释器</a></p><p>bash 脚本开头一行 都有 <code>#!/bin/bash</code> 指此脚本使用<strong>/bin/sh</strong>来解释执行，<strong>#!</strong>是特殊的表示符，其后面根的是此解释此脚本的shell的路径, python脚本在开头也有类似的语句， <code>#!/bin/python2</code> or <code>#!/bin/python3</code></p><p>创建完一个bash脚本之后，需要通过<code>chmod +x XXX.sh</code> 赋予bash脚本执行权限， 文件的权限可以通过<code>ls -l</code> 查看详细， 用户组，其他，用户都具有自己对文件的权限。</p><p>bash 脚本执行可以 通过<code>./XXX.sh</code> 也可以直接指明<code>bash xxx.sh</code>  其中前者指定了sh 文件的路径，<a href="https://unix.stackexchange.com/questions/114300/whats-the-meaning-of-a-dot-before-a-command-in-shell" target="_blank" rel="noopener">参考</a></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>bash 变量不需要指定类型，直接赋值，解释器动态解释。</p><p><strong>变量定义</strong>:</p><p><code>name=&quot;DevDojo&quot;</code>  note： 赋值号左右不能又空格，如果平时编码习惯和这个不一样，需要注意下。</p><p><strong>变量使用</strong></p><p><code>echo ${name}</code> 括号增加可读性。同时变量也可以在表达式中使用，语法与直接使用一样。</p><p>bash 语句不像c++需要显式<code>;</code>表示语句结束</p><p><strong>用户输入</strong></p><p>从命令行读取用户输入</p><p><code>read variable</code></p><p><strong>外部参数</strong></p><p>bash 脚本在运行时候,可以跟可变多的参数,在脚本内部用$1, $2来指代,如下面例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Argument one is <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Argument two is <span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Argument three is <span class="variable">$3</span>"</span></span><br><span class="line"><span class="comment"># excute</span></span><br><span class="line">./arguments.sh dog cat bird</span><br></pre></td></tr></table></figure><p>也可以很方便的用 <code>$@</code> 来引用所有的外部参数.</p><p>$0表示脚本文件名,一个用处就是在执行完脚本之后,可以用$0获取脚本名,然后做自删除.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The name of the file is: <span class="variable">$0</span> and it is going to be self-</span></span><br><span class="line"><span class="string">deleted."</span></span><br><span class="line">rm -f <span class="variable">$0</span></span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><p>语法:<code>my_array=(&quot;value 1&quot; &quot;value 2&quot; &quot;value 3&quot; &quot;value 4&quot;)</code>  元素之间用空格隔开</p><p>数组引用类似C,  <code>echo ${my_array[1]}</code>  元素起始下标为0</p><p>数组长度获取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=(1 2 3 4)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#list[@]&#125;</span>  <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><ul><li>算数表达  语法类似, 用英文字母的缩写来表示比较属性, eg. lt(less than) ,eq(equal) …..<ul><li>[[ ${arg1} -eq ${arg2} ]]    equal  如果两个变量相同返回true</li></ul></li><li>字符串<ul><li>[[ -v ${varname} ]] 变量如果被赋值返回true</li><li>[[ -z ${string} ]] 字符串长度为0 为true</li><li>[[ -n ${string} ]] 字符串长度不为0</li></ul></li><li>文件表达式 在linux 下面一切都是文件,文件具有不同的类型 比如块文件,字符设备,目录等<ul><li>[[ -d ${file} ]]    是否为目录</li><li>[[ -x ${file} ]]  文件是否可执行</li><li>[[ -L ${file} ]]  文件是否为符号链接</li></ul></li></ul><p>有了条件表达式,自然引出了条件语句</p><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p><strong>if-else</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ some_test ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span> &lt;commands&gt;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>swith 语句</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$some_variable</span> <span class="keyword">in</span></span><br><span class="line">  pattern_1)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">  pattern_2| pattern_3)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    default commands</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>注意点</p><ol><li>case 语句用关键字<strong>case</strong>开始,引用变量,然后加关键字<strong>in</strong></li><li>匹配模式用) 结束</li><li>All clauses have to be terminated by adding ;; at the end</li><li>默认模式用*匹配</li><li>case 语句结束用esac关键字</li></ol><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><strong>while</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ your_condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    your_conditions</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>条件表达式都用[] 或者[[]]括起来, <a href="https://stackoverflow.com/questions/3427872/whats-the-difference-between-and-in-bash" target="_blank" rel="noopener">区别</a></p><p><strong>until</strong></p><p>含义是当条件不为真时候一直运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ your_condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    your_commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h3 id=&quot;学习bash&quot;&gt;&lt;a href=&quot;#学习bash&quot; class=&quot;headerlink&quot; title=&quot;学习bash&quot;&gt;&lt;/a&gt;学习bash&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;https://github.com/bobbyi
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>谁想看清尘世就应当同它保持必要的距离</title>
    <link href="http://yoursite.com/2020/11/20/%E8%B0%81%E6%83%B3%E7%9C%8B%E6%B8%85%E5%B0%98%E4%B8%96%E5%B0%B1%E5%BA%94%E5%BD%93%E5%90%8C%E5%AE%83%E4%BF%9D%E6%8C%81%E5%BF%85%E8%A6%81%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2020/11/20/%E8%B0%81%E6%83%B3%E7%9C%8B%E6%B8%85%E5%B0%98%E4%B8%96%E5%B0%B1%E5%BA%94%E5%BD%93%E5%90%8C%E5%AE%83%E4%BF%9D%E6%8C%81%E5%BF%85%E8%A6%81%E7%9A%84%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-11-20T13:07:07.000Z</published>
    <updated>2020-12-09T08:22:14.066Z</updated>
    
    <content type="html"><![CDATA[<p>《树上的男爵》是一本小册子，200来页，很快就能读完。</p><p>书中探讨了关于自我和集体，自我和爱情，以及为了追求一个完整的自我，所作的取舍。要有不少句子都充满哲理，引人深思。</p><blockquote><p>他懂得这个道理：集体会使人更强大，能突出每个人的长处，使人得到替自己办事时极难以获得的那种快乐，会为看到那么多正直、勇敢而能干的人而喜悦，为了他们值得去争取美好的东西（而在为自己而生活时，经常出现的是相反的情形，看到的是人们的另一副面孔，使你必须永远用手握住剑柄）。 这个火灾的夏季因此而成为一个不错的季节：在大家的心中有一个需要解决的共同问题，每个人都把它放在其他个人利益之前，而且从其他许多优秀人物的赞同和敬佩中得到了满足与报偿。 后来，柯希莫不得不明白，当那个共同的问题不存在之后，集体就不再像从前那么好了，做一个孤独的人更好一些，而不要当首领。</p></blockquote><blockquote><p>真事使人回忆起许多属于过去的时光、细腻的感情、烦扰、幸福、疑惑、光荣和对自己的厌恶，而故事中砍掉了主要的东西，一切显得轻而易举。但变来变去，最后发觉自己在回头去讲自己经历过的真实生活中体验过或发生过的事情。</p></blockquote><blockquote><p>如果不感到自身充满力量，就不可能有爱情。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《树上的男爵》是一本小册子，200来页，很快就能读完。&lt;/p&gt;
&lt;p&gt;书中探讨了关于自我和集体，自我和爱情，以及为了追求一个完整的自我，所作的取舍。要有不少句子都充满哲理，引人深思。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;他懂得这个道理：集体会使人更强大，能突出每个人的长
      
    
    </summary>
    
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>套接字选项小结</title>
    <link href="http://yoursite.com/2020/08/24/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/08/24/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9%E5%B0%8F%E7%BB%93/</id>
    <published>2020-08-24T09:41:40.000Z</published>
    <updated>2020-08-24T09:44:00.509Z</updated>
    
    <content type="html"><![CDATA[<p>总结影响网络收发包的一些套接字选项，对一些概念可能理解不对，希望大家多多指教。后面会持续更新ing。</p><a id="more"></a><p>[TOC]</p><h3 id="套接字属性设置"><a href="#套接字属性设置" class="headerlink" title="套接字属性设置"></a><strong>套接字属性设置</strong></h3><hr><p>通过setsockopt我们可以设置套接字的一些属性，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val,<span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>level</code> 参数设定的套接字属性使用范围，<code>SOL_SOCKET</code>表示用于通用套接字，<code>IPPROTO_TCP</code> 用于tcp协议，<code>IPPROTO_IP</code> 用于IP协议。</p><p>下表是《APUE》中给出的一些通用套接字设置选项</p><p><img src="https://s1.ax1x.com/2020/08/07/ahtjHI.png" alt="ahtjHI.png"></p><h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><blockquote><p>为什么需要保活?</p></blockquote><p>在tcp连接双方，建立连接之后，很长时间没有交换数据，在这种长时间没有数据交换情况下，双方不知道对方状态，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些TCP连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用TCP的保活报文来实现。</p><ol><li>探测连接的对端是否存活</li></ol><p>在应用交互的过程中，可能存在以下几种情况：</p><ol><li><p>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来 2小时再复位。</p></li><li><p>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP没有响应。服务器将不能够收到对探查的响应，并在<strong>75s</strong>后超时。服务器总共发送<strong>10个</strong>这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</p></li><li><p><strong>客户主机崩溃并已经重新启动</strong>。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</p></li><li><p>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。</p></li></ol><p>​     利用保活探测功能，可以探知这种对端的意外情况，从而保证在意外发生时，可以释放半打开的TCP连接。</p><ol start="2"><li><p><strong>防止中间设备因超时删除连接相关的连接表</strong></p><p>中间设备如防火墙等，会为经过它的数据报文建立相关的连接信息表，并为其设置一个超时时间的定时器，如果超出预定时间，某连接无任何报文交互的中间设备会将该连接信息从表中删除，在删除后，再有应用报文过来时，中间设备将丢弃该报文，从而导致应用出现异常，这个交互的过程大致如下图所示：</p></li></ol><p>默认情况下tcp的保活是关闭的,需要我们自己打开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optval = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, optlen);</span><br></pre></td></tr></table></figure><p><strong>全局修改探测活参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">600</span> &gt; /proc/sys/net/ipv4/tcp_keepalive_time <span class="comment">//超时时间</span></span><br><span class="line">echo <span class="number">60</span> &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl <span class="comment">//探测报文发送间隔</span></span><br><span class="line">echo <span class="number">20</span> &gt; /proc/sys/net/ipv4/tcp_keepalive_probes <span class="comment">//探测报文发送次数</span></span><br></pre></td></tr></table></figure><p><strong>通过系统调用对单个进程修改</strong></p><p>对应到的几个套接字选项如下</p><p><strong>TCP_KEEPCNT</strong>: 对应到探测报文发送次数；</p><p><strong>TCP_KEEPINTVL</strong>: 探测报文发送间隔</p><p><strong>TCP_KEEPIDLE</strong>: 超时时间</p><blockquote><p>TCP层的保活和应用层保活对比</p></blockquote><p><code>KeepAlive</code>通过定时发送探测包来探测连接的对端是否存活， 但通常也会许多在业务层面处理的，他们之间的特点：</p><ul><li>TCP自带的<code>KeepAlive</code>使用简单，发送的数据包相比应用层心跳检测包更小，仅提供检测连接功能</li><li>应用层心跳包不依赖于传输层协议，无论传输层协议是TCP还是UDP都可以用</li><li>应用层心跳包可以定制，可以应对更复杂的情况或传输一些额外信息</li><li><code>KeepAlive</code>仅代表连接保持着，而心跳包往往还代表客户端可正常工作</li></ul><h3 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a><strong>SO_LINGER</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>对应的<code>val</code>是一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">　　<span class="keyword">int</span> l_onoff; <span class="comment">//开关 0:关闭</span></span><br><span class="line">　　<span class="keyword">int</span> l_linger;<span class="comment">//延迟关闭时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个简单的使用例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">lin</span>&#123;</span><span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">setsockopt(fd,SOL_SOCKET,SO_SOCKET,&amp;lin);</span><br></pre></td></tr></table></figure><p>linger打开与否，以及不同时间的设置，可能导致不同的关闭结果。</p><p>三种断开方式：</p><ol><li>l_onoff = 0; l_linger忽略</li></ol><p>close()立刻返回，底层会将未发送完的数据发送完成后再释放资源，即优雅退出。</p><ol start="2"><li>l_onoff != 0; l_linger = 0;</li></ol><p>close()立刻返回，但不会发送未发送完成的数据，而是通过一个RST包强制的关闭socket描述符，即强制退出。</p><ol start="3"><li>l_onoff != 0; l_linger &gt; 0;</li></ol><p>close()不会立刻返回，内核会延迟一段时间，这个时间就由l_linger的值来决定。如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，close()会返回正确，socket描述符优雅性退出。否则，close()会直接返回错误值，未发送数据丢失，socket描述符被强制性退出</p><h4 id="SO-LINGER实现原理"><a href="#SO-LINGER实现原理" class="headerlink" title="SO_LINGER实现原理"></a>SO_LINGER实现原理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SO_LINGER:</span><br><span class="line"><span class="keyword">if</span>(optlen&lt;<span class="keyword">sizeof</span>(ling)) &#123;</span><br><span class="line">ret = -EINVAL;<span class="comment">/* 1003.1g */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!ling.l_onoff)<span class="comment">//没有打开linger</span></span><br><span class="line">sock_reset_flag(sk, SOCK_LINGER);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> (BITS_PER_LONG == <span class="number">32</span>)</span><br><span class="line"><span class="keyword">if</span> (ling.l_linger &gt;= MAX_SCHEDULE_TIMEOUT/HZ)</span><br><span class="line">sk-&gt;sk_lingertime = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">sk-&gt;sk_lingertime = ling.l_linger * HZ;<span class="comment">//设置linger时间</span></span><br><span class="line">sock_set_flag(sk, SOCK_LINGER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>程序调用函数close()关闭套接口时，与此相关的函数调用路径如下：<code>sys_close() -&gt; filp_close() -&gt; fput() -&gt; __fput() -&gt; sock_close() -&gt; sock_release() -&gt; inet_release() -&gt; tcp_close()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_release</span><span class="params">(struct socket *sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk) &#123;</span><br><span class="line"><span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Applications forget to leave groups before exiting */</span></span><br><span class="line">ip_mc_drop_socket(sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If linger is set, we don't return until the close</span></span><br><span class="line"><span class="comment"> * is complete.  Otherwise we return immediately. The</span></span><br><span class="line"><span class="comment"> * actually closing is done the same either way.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the close is due to the process exiting, we never</span></span><br><span class="line"><span class="comment"> * linger..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">timeout = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp;</span><br><span class="line">    !(current-&gt;flags &amp; PF_EXITING))</span><br><span class="line">timeout = sk-&gt;sk_lingertime;</span><br><span class="line">sock-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">sk-&gt;sk_prot-&gt;<span class="built_in">close</span>(sk, timeout);<span class="comment">//对应到tcp_close</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcp-close"><a href="#tcp-close" class="headerlink" title="tcp_close()"></a><code>tcp_close()</code></h4><p>当一个套接口正在或已经被关闭，如果在其接收队列有未读数据（不管是在关闭前就已收到的，或者还是在关闭后新到达的），那么此时就需给对端发送一个RST数据包,对应到下面一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data_was_unread) &#123;<span class="comment">//接受区还有数据没有被读完</span></span><br><span class="line"><span class="comment">/* Unread data was tossed, zap the connection. */</span></span><br><span class="line">NET_INC_STATS_USER(LINUX_MIB_TCPABORTONCLOSE);</span><br><span class="line">tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">tcp_send_active_reset(sk, GFP_KERNEL);<span class="comment">//发送RST</span></span><br></pre></td></tr></table></figure><p>如果linger结构体的字段<code>l_onoff</code>为1,而<code>l_linger</code>为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp; !sk-&gt;sk_lingertime) &#123;</span><br><span class="line"><span class="comment">/* Check zero linger _after_ checking for unread data. */</span></span><br><span class="line">sk-&gt;sk_prot-&gt;<span class="built_in">disconnect</span>(sk, <span class="number">0</span>); <span class="comment">//直接丢掉所有接收数据并且直接断开连接，具体也就是发送RST数据包，清空相关接收队列</span></span><br><span class="line">NET_INC_STATS_USER(LINUX_MIB_TCPABORTONDATA);</span><br></pre></td></tr></table></figure><p>下面就是对应正常四次挥手关闭流程，</p><p>先调用函数<code>tcp_close_state()</code>切换状态，判断是否需要发送FIN数据包（eg.如果当前还处于<code>TCP_SYN_SENT</code>状态，连接尚未完全建立，自然就不用发送FIN数据包），如果需要发送FIN数据包则调用<code>tcp_send_fin()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....... </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tcp_close_state(sk)) &#123;</span><br><span class="line">tcp_send_fin(sk);</span><br><span class="line">&#125;</span><br><span class="line"> sk_stream_wait_close(sk, timeout);</span><br></pre></td></tr></table></figure><h4 id="tcp-send-fin"><a href="#tcp-send-fin" class="headerlink" title="tcp_send_fin"></a><strong>tcp_send_fin</strong></h4><p>深入到发送fin内部来看，</p><p>如果发送队列还有数据，那么直接将取出末尾数据包，设置FIN。否则分配一个新的skb,最后调用函数<code>__tcp_push_pending_frames() -&gt; tcp_write_xmit()</code>发送数据包。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_send_fin</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = <span class="title">skb_peek_tail</span>(&amp;<span class="title">sk</span>-&gt;<span class="title">sk_write_queue</span>);</span> <span class="comment">//取出末尾数据包</span></span><br><span class="line"><span class="keyword">int</span> mss_now;</span><br><span class="line"></span><br><span class="line">mss_now = tcp_current_mss(sk, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_send_head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">TCP_SKB_CB(skb)-&gt;flags |= TCPCB_FLAG_FIN;<span class="comment">//</span></span><br><span class="line">TCP_SKB_CB(skb)-&gt;end_seq++;</span><br><span class="line">tp-&gt;write_seq++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Socket is locked, keep trying until memory is available. */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">skb = alloc_skb(MAX_TCP_HEADER, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (skb)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reserve space for headers and prepare control bits. */</span></span><br><span class="line">skb_reserve(skb, MAX_TCP_HEADER);</span><br><span class="line">skb-&gt;csum = <span class="number">0</span>;</span><br><span class="line">TCP_SKB_CB(skb)-&gt;flags = (TCPCB_FLAG_ACK | TCPCB_FLAG_FIN);</span><br><span class="line">TCP_SKB_CB(skb)-&gt;sacked = <span class="number">0</span>;</span><br><span class="line">skb_shinfo(skb)-&gt;tso_segs = <span class="number">1</span>;</span><br><span class="line">skb_shinfo(skb)-&gt;tso_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */</span></span><br><span class="line">TCP_SKB_CB(skb)-&gt;seq = tp-&gt;write_seq;</span><br><span class="line">TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + <span class="number">1</span>;</span><br><span class="line">tcp_queue_skb(sk, skb);</span><br><span class="line">&#125;</span><br><span class="line">__tcp_push_pending_frames(sk, tp, mss_now, TCP_NAGLE_OFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sk-stream-wait-close"><a href="#sk-stream-wait-close" class="headerlink" title="sk_stream_wait_close"></a><strong>sk_stream_wait_close</strong></h4><p>这是一个阻塞等待函数，参数timeout指示了等待的时间（单位为时钟滴答）。</p><p>while循环的退出点有两处</p><ul><li><p>当前进程收到信号或时间超时（timeout）</p></li><li><p>sk_wait_event()</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sk_stream_wait_close</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">DEFINE_WAIT(wait);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">prepare_to_wait(sk-&gt;sk_sleep, &amp;wait,</span><br><span class="line">TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (sk_wait_event(sk, &amp;timeout, !sk_stream_closing(sk)))<span class="comment">// 退出点1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (!signal_pending(current) &amp;&amp; timeout); <span class="comment">//退出点2</span></span><br><span class="line">finish_wait(sk-&gt;sk_sleep, &amp;wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们结合源码大致搞清楚了SO_LINGER选项的设置对TCP连接关闭的影响。</p><h3 id="SO-REUSEPORT-amp-amp-SO-REUSEADDR"><a href="#SO-REUSEPORT-amp-amp-SO-REUSEADDR" class="headerlink" title="SO_REUSEPORT&amp;&amp;SO_REUSEADDR"></a>SO_REUSEPORT&amp;&amp;SO_REUSEADDR</h3><p>SO_REUSEADDR和SO_REUSEPORT主要是影响socket绑定ip和port的成功与否。有几点绑定规则主要注意下<br> <strong>规则1</strong>：socket可以指定绑定到一个特定的ip和port，例如绑定到192.168.0.11:9000上；<br> <strong>规则2</strong>：同时也支持通配绑定方式，即绑定到本地”any address”（例如一个socket绑定为 0.0.0.0:21，那么它同时绑定了所有的本地地址）；<br> <strong>规则3</strong>：默认情况下，任意两个socket都无法绑定到相同的源IP地址和源端口</p><h4 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a><strong>SO_REUSEADDR</strong></h4><p><strong>1、改变了通配绑定时处理源地址冲突的处理方式</strong></p><p>so_reuseaddr作用在于允许一个socket 绑定了统配地址+port， 另外一个套接字绑定具体地址+相同端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SO_REUSEADDR       socketA        socketB       Result</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">  ON&#x2F;OFF       192.168.0.1:21   192.168.0.1:21    Error (EADDRINUSE)</span><br><span class="line">  ON&#x2F;OFF       192.168.0.1:21      10.0.0.1:21    OK</span><br><span class="line">  ON&#x2F;OFF          10.0.0.1:21   192.168.0.1:21    OK</span><br><span class="line">   OFF             0.0.0.0:21   192.168.1.0:21    Error (EADDRINUSE)</span><br><span class="line">   OFF         192.168.1.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br><span class="line">   ON              0.0.0.0:21   192.168.1.0:21    OK</span><br><span class="line">   ON          192.168.1.0:21       0.0.0.0:21    OK</span><br><span class="line">  ON&#x2F;OFF           0.0.0.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br></pre></td></tr></table></figure><p><strong>2、改变了系统对处于TIME_WAIT状态的socket绑定地址的处理</strong></p><p>处于time-wait 状态下的套接字需要等待2msl 才能重新使用其绑定的端口与地址，设置了so_reuseaddr没有此限制</p><h4 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a><strong>SO_REUSEPORT</strong></h4><ol><li>允许将多个socket绑定到相同的地址和端口，前提每个socket绑定前都需设置</li><li>linux内核在处理SO_REUSEPORT socket的集合时，进行了简单的负载均衡操作，即对于UDP socket，内核尝试平均的转发数据报，对于TCP监听socket，内核尝试将新的客户连接请求(由accept返回)平均的交给共享同一地址和端口的socket(监听socket)。</li></ol><p>通过设置套接字的SO_REUSEPORT能够用来解决epoll_wait存在的惊群问题，把监听描述符添加到epoll监听事件，多个子进程都epoll_wait阻塞等待，由内核来做负载均衡，这样就避免了当实践发生时同时惊醒多个工作进程，添加了SO_REUSEPORT的模型如下:</p><img src="https://s1.ax1x.com/2020/08/13/azw6DU.png" alt="azw6DU.png" style="zoom:80%;" /><h3 id="TCP-CORK"><a href="#TCP-CORK" class="headerlink" title="TCP_CORK"></a>TCP_CORK</h3><p>tcp_cork与tcp_nodelay 以及nagle 容易搞混，这里我们结合他们的应用场景以及代码来理清楚。</p><p><strong>nagle算法</strong></p><p>大致思想：</p><p>为了提高网络吞吐量，如果发送小数据包，那么20字节包头的负担太大，于是通过将小数据包累积到一个MSS长度再发出来。</p><p>同样影响小包发送的套接字选项:<strong>TCP_NODELAY，TCP_CORK</strong></p><p>Nagle算法的<strong>基本定义</strong>是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</p><p>Nagle算法的规则（tcp_output.c文件里tcp_nagle_check函数注释）：</p><p>（1）如果包长度达到MSS，则允许发送；</p><p>（2）如果该包含有FIN，则允许发送；</p><p>（3）设置了TCP_NODELAY选项，则允许发送；</p><p>（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；</p><p>（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。</p><p><code>TCP_NODELAY</code>是禁用Nagle算法，即数据包立即发送出去，而选项TCP_CORK与此相反，可以认为它是Nagle算法的进一步增强，即阻塞数据包发送，具体点说就是：TCP_CORK选项的功能类似于在发送数据管道出口处插入一个“塞子”，使得发送数据全部被阻塞，直到取消TCP_CORK选项（即拔去塞子）或被阻塞数据长度已超过MSS才将其发送出去。举个对比示例，比如收到接收端的ACK确认后，Nagle算法可以让当前待发送数据包发送出去，即便它的当前长度仍然不够一个MSS，但选项TCP_CORK则会要求继续等待。</p><h4 id="TCP-CORK的应用场景"><a href="#TCP-CORK的应用场景" class="headerlink" title="TCP_CORK的应用场景"></a>TCP_CORK的应用场景</h4><p>TCP_CORK选项的作用主要是阻塞小数据发送，服务器处理一个客户端请求，发送的响应数据包括响应头和响应体两部分，利用TCP_CORK选项就能让这两部分数据一起发送。</p><p>按照之前的分析，设置了CORK之后，有几种可能数据会被发送</p><ul><li>通过setoptsock关闭TCP_CORK这个选项。</li><li>socket阻塞的数据大于MSS。</li><li>自从堵上塞子写入第一个字节开始，已经经过200ms。</li><li>socket被关闭。</li></ul><p>一旦满足上面的任何一个条件，TCP就会将数据发送出去。对于Server来说，发送HTTP响应既要发送尽量少的segment，同时又要保证低延迟，那么需要在写完数据后显式取消设置<code>TCP_CORK</code>选项，让数据立即发送出去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, &amp;state, <span class="keyword">sizeof</span>(state)); <span class="comment">//开启cork</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(http_resp_header);</span><br><span class="line">sendfile(sockfd, fd, &amp;off, len); <span class="comment">//阻塞</span></span><br><span class="line"></span><br><span class="line">state = <span class="number">0</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, &amp;state, <span class="keyword">sizeof</span>(state)); <span class="comment">//关闭cork</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.lenky.info/archives/2013/02/2220" target="_blank" rel="noopener">Socket选项系列之SO_LINGER</a></p><p><a href="http://senlinzhan.github.io/2017/02/10/Linux的TCP-CORK/" target="_blank" rel="noopener">Nagle 算法与 TCP socket 选项 TCP_CORK</a></p><p><a href="https://juejin.im/post/6844903878819840008" target="_blank" rel="noopener">https://juejin.im/post/6844903878819840008</a></p><p><a href="https://blog.biezhi.me/2017/08/talk-tcp-keepalive.html" target="_blank" rel="noopener">https://blog.biezhi.me/2017/08/talk-tcp-keepalive.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结影响网络收发包的一些套接字选项，对一些概念可能理解不对，希望大家多多指教。后面会持续更新ing。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡大量TW分析</title>
    <link href="http://yoursite.com/2020/08/23/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%A4%A7%E9%87%8FTW%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/08/23/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%A4%A7%E9%87%8FTW%E5%88%86%E6%9E%90/</id>
    <published>2020-08-23T06:59:02.000Z</published>
    <updated>2020-08-23T07:03:47.004Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>背景</p><p>LB集群使用了LVS做负载均衡，使用的是NAT模式对tcp 80端口进行负载均衡。因为服务器访问量比较大，所以负载均衡后面的web服务器上出现了大量的 timewait 状态连接。</p><p>分析思路</p><ul><li>打开tcp_tw_recycle；load balancer作为中间代理应该需要开启tcp_tw_recyvle 同时需要开启tcp_timestamps</li><li>设置SO_LINGER ; 只有正常的四次挥手过程才会出现time-wait。 打开so-linger同时将延时设为0，服务器发起关闭时，发送RST直接断开连接</li><li>调整tcp_max_tw_buckets</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;背景&lt;/p&gt;
&lt;p&gt;LB集群使用了LVS做负载均衡，使用的是NAT模式对tcp 80端口进行负载均衡。因为服务器访问量比较大，所以负载均衡后面的web服务器上出现了大量的 timewait 状态连接。&lt;/p&gt;
&lt;p&gt;分析思路&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>tcp40ms延迟问题分析</title>
    <link href="http://yoursite.com/2020/08/23/%E2%80%9Ctcp40ms%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E2%80%9D/"/>
    <id>http://yoursite.com/2020/08/23/%E2%80%9Ctcp40ms%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E2%80%9D/</id>
    <published>2020-08-23T06:53:50.000Z</published>
    <updated>2020-08-23T07:07:00.659Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>背景</strong></p><p>tcp抓包发现服务端回复ack存在40ms左右延迟</p><p><img src="https://s1.ax1x.com/2020/08/17/dmqEqK.png" alt="dmqEqK.png"></p><p><strong>问题排查过程</strong></p><p>通过查阅资料发现tcp40ms延迟不是一个偶然的现象。先给出结论：<strong>客户端开启nagle算法+服务端延迟ack</strong>，延迟ack的超时时间为40ms。</p><p>先介绍下重要的概念</p><p><strong>delay ack</strong></p><p>在TCP建立连接之后，最开始的数据交互是处于quick ack mode,顾名思义就是当对端收到数据立马就会回复ack。在接下来的数据交互过程中，服务端仍然执行快速ack,服务端然后往对端发送交互数据，此时系统探测到了这样一种交互行为，于是开启ping pong mode。服务端开启了ping pong mode之后，收到数据不会立马回复对端ack,而是在回复响应数据时候带上ack,这样减少了网络中的包量。但是如果服务端在延时ack时间都没有响应客户端的请求就可能出现短暂的响应延迟。</p><p><img src="https://s1.ax1x.com/2020/08/17/dmqAr6.png" alt="dmqAr6.png"></p><p><strong>nagle算法</strong></p><p>Nagle算法的<strong>基本定义</strong>是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</p><p>Nagle算法的规则（tcp_output.c文件里tcp_nagle_check函数注释）：</p><p>（1）如果包长度达到MSS，则允许发送；</p><p>（2）如果该包含有FIN，则允许发送；</p><p>（3）设置了TCP_NODELAY选项，则允许发送；</p><p>（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；</p><p>（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。</p><p>有了上面的知识铺垫，我们具体分析下客户端开启nagle,服务端处于delay ack 状态下，客户端不同大小数据请求下延时情况。</p><ol><li>当客户端请求数据小于mss大小</li></ol><p>假设客户端之前的数据已经全部被ack了，此时发送一个新的数据请求，小于mss,对端服务器在收到数据之后，不会立马回复ack,但是在delay ack超时之前能够回复响应数据，顺带就把ack发过去了，所以不会出现我们说的40ms延迟。</p><ol start="2"><li>客户端请求数据大于mss</li></ol><p>由于请求数据大于mss,一个包装不下这么多数据，tcp会将数据分成小包发送，在发送第一个小包之后，服务端延迟ack,同时由于数据不全，服务端不能立即响应，于是就在等待延迟ack超时，同时客户端这边开启了nagle，之前发送的数据包还没有被ack,待发送的数据包小于mss，于是也进入等待，这样一来双方都处于等待，进入了短暂的”死锁“。</p><p><strong>解决方案</strong></p><p>有了上面的分析，我们可以从两个方向来考虑如何解决40ms延迟。</p><ol><li><p>服务端关闭延迟ack ；<code>echo 1 &gt; /proc/sys/net/ipv4/tcp_no_delay_ack</code></p></li><li><p>客户端关闭nagle；通过设置<code>TCP_NODELAY</code>来实现</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tcp抓包发现服务端回复ack存在40ms左右延迟&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/17/dmqEqK.png&quot; alt=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>socket从创建到连接过程小结</title>
    <link href="http://yoursite.com/2020/08/08/socket%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/08/08/socket%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%B0%8F%E7%BB%93/</id>
    <published>2020-08-08T02:40:45.000Z</published>
    <updated>2020-08-08T02:44:29.819Z</updated>
    
    <content type="html"><![CDATA[<p>分析了套接字创建到连接过程中，一些关键的函数调用以及数据结构，同时分析了connect()过程中tcp三次握手状态变化。</p><a id="more"></a><h3 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h3><h4 id="系统调用流程图"><a href="#系统调用流程图" class="headerlink" title="系统调用流程图"></a>系统调用流程图</h4><p><img src="https://s1.ax1x.com/2020/08/07/aW8ts0.png" alt="aW8ts0.png"></p><h4 id="sock-create"><a href="#sock-create" class="headerlink" title="sock_create()"></a>sock_create()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock_create(family, type, protocol, &amp;sock)</span><br></pre></td></tr></table></figure><p><strong>family</strong> </p><p>指定了协议族，比较常用的ipv4协议族对应AF_INET，PF_INET。</p><p>AF_INET 表示address_family, PF_INET 表示protocol family ，这两者的宏定义是相同的，对于BSD,是<strong>AF</strong>,对于POSIX是<strong>PF</strong>。</p><table><thead><tr><th>名称</th><th>含义</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>PF_UNIX,PF_LOCAL</td><td>本地通信</td><td>PF_X25</td><td>ITU-T X25 / ISO-8208协议</td></tr><tr><td>AF_INET,PF_INET</td><td>IPv4 Internet协议</td><td>PF_AX25</td><td>Amateur radio AX.25</td></tr><tr><td>PF_INET6</td><td>IPv6 Internet协议</td><td>PF_ATMPVC</td><td>原始ATM PVC访问</td></tr><tr><td>PF_IPX</td><td>IPX-Novell协议</td><td>PF_APPLETALK</td><td>Appletalk</td></tr><tr><td>PF_NETLINK</td><td>内核用户界面设备</td><td></td><td></td></tr></tbody></table><p><strong>type</strong></p><p>用于设置套接字通信的类型，主要有SOCKET_STREAM（流式套接字）、SOCK_DGRAM（数据包套接字）等。</p><p><strong>protocol</strong></p><p>protocol用于制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0。</p><p>因此对于一个面向对象的连接，创建一个套接字如下</p><p><code>int lfd=socket(AF_INET,SOCK_STREAM,0)</code>;</p><p>sock 类型是<code>struct socket</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">    socket_state        state;<span class="comment">//枚举类型 标识了当前socket的状态 eg. SS_CONNECTED, SS_DISCONNECTED</span></span><br><span class="line">    kmemcheck_bitfield_begin(type);</span><br><span class="line">    short           type;<span class="comment">//标识套接字类型 eg.SOCK_STREAM,SOCK_DGRAM</span></span><br><span class="line">    kmemcheck_bitfield_end(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> __<span class="title">rcu</span>  *<span class="title">wq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>     *<span class="title">file</span>;</span><span class="comment">//与套接字对应的文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     *<span class="title">sk</span>;</span><span class="comment">//指向代表下层协议(network layer)数据的sock结构</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>  *<span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="sock-alloc"><a href="#sock-alloc" class="headerlink" title="sock_alloc()"></a>sock_alloc()</h4><p>先分配socket<code>struct socket *sock_alloc(void)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *sock_alloc-allocate a socket</span></span><br><span class="line"><span class="comment"> *分配inode，socket 这两者是一一对应的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct socket *<span class="title">sock_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> * <span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">inode = new_inode(sock_mnt-&gt;mnt_sb);<span class="comment">//分配inode</span></span><br><span class="line">sock = SOCKET_I(inode);<span class="comment">//通过inode得到socket</span></span><br><span class="line"></span><br><span class="line">inode-&gt;i_mode = S_IFSOCK|S_IRWXUGO;</span><br><span class="line">inode-&gt;i_sock = <span class="number">1</span>;</span><br><span class="line">inode-&gt;i_uid = current-&gt;fsuid;</span><br><span class="line">inode-&gt;i_gid = current-&gt;fsgid;</span><br><span class="line"></span><br><span class="line">get_cpu_var(sockets_in_use)++;</span><br><span class="line">put_cpu_var(sockets_in_use);</span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="net-families-gt-create"><a href="#net-families-gt-create" class="headerlink" title="net_families-&gt;create()"></a>net_families-&gt;create()</h4><p>从全局net_families数组中根据下标<code>family</code>取到对应的<code>struct net_proto_family</code>结构pf,然后调用<code>create()</code>  对于ipv4协议而言，对应到<code>net/ipv4/Af_inet.c</code>的<code>inet_create()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((err = net_families[family]-&gt;create(sock, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_module_put;</span><br></pre></td></tr></table></figure><p><code>struct net_proto_family</code>定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> = &#123;</span></span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    .create = inet_create,</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>inet_create</strong></p><ol><li><p>先将struct socket的state设为SS_UNCONNECTED;</p></li><li><p>根据struct socket的type(eg.SOCK_STREAM), 遍历inetsw[type], 找到对应到protocol的结构体</p><p><code>struct inet_protosw</code>定义如下</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is used to register socket interfaces for IP protocols.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two fields form the lookup key.  */</span></span><br><span class="line"><span class="keyword">unsigned</span> short type;   <span class="comment">/* This is the 2nd argument to socket(2). */</span></span><br><span class="line"><span class="keyword">int</span> protocol; <span class="comment">/* This is the L4 protocol number.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">prot</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span>              capability; <span class="comment">/* Which (if any) capability do</span></span><br><span class="line"><span class="comment">      * we need to use this socket</span></span><br><span class="line"><span class="comment">      * interface?</span></span><br><span class="line"><span class="comment">                                      */</span></span><br><span class="line"><span class="keyword">char</span>             no_check;   <span class="comment">/* checksum on rcv/xmit/none? */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flags;      <span class="comment">/* See INET_PROTOSW_* below.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_create</span><span class="params">(struct socket *sock, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">    sock-&gt;state = SS_UNCONNECTED;<span class="comment">//1.</span></span><br><span class="line">    <span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">list_for_each_rcu(p, &amp;inetsw[sock-&gt;type]) &#123; <span class="comment">//2.inetsw是一个链表数组, key为SOCK_STREAM, SOCK_DGRAM, SOCK_RAW等等.</span></span><br><span class="line">answer = list_entry(p, struct inet_protosw, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;<span class="comment">//3.</span></span><br><span class="line">    sk = sk_alloc(PF_INET, GFP_KERNEL,answer_prot-&gt;slab_obj_size, answer_prot-&gt;slab);<span class="comment">//4.</span></span><br><span class="line">    inet = inet_sk(sk);<span class="comment">//5.</span></span><br><span class="line">    sock_init_data(sock, sk);<span class="comment">//6.</span></span><br><span class="line">   <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;init) &#123;</span><br><span class="line">err = sk-&gt;sk_prot-&gt;init(sk);<span class="comment">//7.</span></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">sk_common_release(sk);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>将”对应到protocol的结构体”的ops赋给struct socket结构的ops. <code>sock-&gt;ops = answer-&gt;ops;</code></p></li><li><p>调用sk_alloc, 分配网络子系统核心(net/core)的数据结构struct sock ( 记录family, protocol到sk_family, sk_prot成员 )</p></li><li><p>将struct sock强转为struct inet_sk(调用inet_sk)</p></li><li><p>调用sock_init_data(struct socket, struct sock)，用scoket 来初始化sock。</p></li><li><p>调用sk-&gt;sk_prot-&gt;init, 例如对于TCP, 指向net/ipv4/Tcp_ipv4.c的全局结构体struct proto tcp_port中的tcp_v4_init_sock, 此方法完成该socket在内核网络子系统TCP层的初始化:</p></li></ol><h4 id="sock-map-fd"><a href="#sock-map-fd" class="headerlink" title="sock_map_fd"></a>sock_map_fd</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/socket.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_map_fd</span><span class="params">(struct socket *sock, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fd = get_unused_fd_flags(flags);<span class="comment">//1.</span></span><br><span class="line">  ...</span><br><span class="line">  newfile = sock_alloc_file(sock, flags, <span class="literal">NULL</span>);<span class="comment">//2.</span></span><br><span class="line">  <span class="keyword">if</span> (likely(!IS_ERR(newfile))) &#123;</span><br><span class="line">    fd_install(fd, newfile);<span class="comment">//3.</span></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  sock_map_fd()主要用于对socket的<em>file指针初始化，经过sock_map_fd()操作后，socket就通过其</em>file指针与VFS管理的文件进行了关联，便可以进行文件的各种操作，如read、write、lseek。</p><p>sock_map_fd流程如下</p><ol><li><p>找到一个未使用的文件描述符fd。</p></li><li><p>为socket分配一个struct file实例。</p></li><li><p>建立fd到socket file的映射关系，并返回fd给上层。</p></li></ol><p>将struct socket的file设为struct file，struct file的private_data设为struct socket;这样struct socket和struct file便互相关联起来了.</p><p><img src="https://s1.ax1x.com/2020/08/07/aW8YMq.png" alt="aW8YMq.png"></p><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p><img src="C:%5CUsers%5Cdiliangdeng%5CPictures%5Cimage-20200807150150809.png" alt="image-20200807150150809"></p><p>bind()作用是给创建的套接字绑定地址，函数原型以及包含的头文件如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sockaddr 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">               <span class="keyword">sa_family_t</span> sa_family;<span class="comment">// 地址协议族</span></span><br><span class="line">               <span class="keyword">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//sockaddr_in </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    short            sin_family;       <span class="comment">// 2 bytes e.g. AF_INET, AF_INET6</span></span><br><span class="line">    <span class="keyword">unsigned</span> short   sin_port;    <span class="comment">// 2 bytes e.g. htons(3490)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">sin_addr</span>;</span>     <span class="comment">// 4 bytes see struct in_addr, below</span></span><br><span class="line">    <span class="keyword">char</span>             sin_zero[<span class="number">8</span>];     <span class="comment">// 8 bytes zero this if you want to</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bind()中的第二个参数addr类型为struct sockaddr,在实际的socket编程中，我们一般都是将特定类型地址转化为sockaddr，比如将ipv4中绑定地址一般如下操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">//地址格式描述</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">   servaddr.sin_family = AF_INET;  <span class="comment">//IPV4</span></span><br><span class="line">   servaddr.sin_port = htons(<span class="number">123</span>); <span class="comment">//端口号</span></span><br><span class="line">   servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//INADDR_ANY一般为0，内核选择IP地址</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(struct sockaddr_in)) == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"bind socket addr failed!\n"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>既有sockaddr,又有sockaddr_in，然后还要转化，看起来多此一举，其实不然，不同的协议族地址可能不一样(eg.ipv6就和ipv4不一样），sockaddr提供了一个统一的地址接口。</p><h4 id="sys-bind"><a href="#sys-bind" class="headerlink" title="sys_bind"></a>sys_bind</h4><p>与socket()一样，bind通过系统调用统一接口到了sys_bind</p><h4 id="sockfd-lookup-light"><a href="#sockfd-lookup-light" class="headerlink" title="sockfd_lookup_light"></a>sockfd_lookup_light</h4><p>sockfd_lookup_light通过fd来查找sock</p><ol><li>在当前进程的描述符中通过fd 找到struct file</li><li>通过<code>file-&gt;f_dentry-&gt;d_inode</code> 得到inode</li><li>通过 <code>SOCKET_I(inode)</code>得到sock</li></ol><p>这里具体看下如何通过inode得到sock。</p><p>SOCKET_I通过调用<code>container_of(inode, struct socket_alloc, vfs_inode)-&gt;socket</code>, vfs_inode类型为inode,作为socket_alloc的数据成员。</p><p>container_of的作用就是通过传入inode地址，inode地址作为socket_alloc的第二个数据成员，通过计算相对socket_alloc首地址的偏移，既可以获得socket_alloc地址，即socket地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">define <span class="title">container_of</span><span class="params">(ptr, type, member)</span> <span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> typeof( ((type *)<span class="number">0</span>)-&gt;member ) *__mptr = (ptr);</span></span></span><br><span class="line"><span class="function"><span class="params">        (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> struct socket_alloc </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>move_addr_to_kernel 将地址拷贝到内核空间</li><li>ops-&gt;bind; 这个是sys_bind最为重要的一步调用，在创建套接字时候，我们将sock-&gt;ops设定为了与协议类型相关的函数操作集，这里我们具体分析tcp,在TCP协议情况下inet_stream_ops中bind成员函数为inet_bind。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bind, <span class="keyword">int</span>, fd, struct sockaddr __user *, umyaddr, <span class="keyword">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (sock) &#123;</span><br><span class="line">err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</span><br><span class="line"><span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">err = security_socket_bind(sock,</span><br><span class="line">   (struct sockaddr *)&amp;address,</span><br><span class="line">   addrlen);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">      (struct sockaddr *)</span><br><span class="line">      &amp;address, addrlen);<span class="comment">//inet_bind</span></span><br><span class="line">&#125;</span><br><span class="line">fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="inet-bind"><a href="#inet-bind" class="headerlink" title="inet_bind"></a>inet_bind</h4><ol><li>做了一些检查，比如绑定地址的长度，协议族类型。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*地址长度检验*/</span></span><br><span class="line"><span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(struct sockaddr_in))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">/*bind地址中协议检查，必须是下面两种情况</span></span><br><span class="line"><span class="comment">* 1.绑定的地址协议为AF_INET</span></span><br><span class="line"><span class="comment">* 2.绑定协议为0（AF_UNSPEC）同时地址也为0</span></span><br><span class="line"><span class="comment">* 否则直接退出inet_bind ,返回地址不支持错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (addr-&gt;sin_family != AF_INET) &#123;</span><br><span class="line"><span class="comment">/* Compatibility games : accept AF_UNSPEC (mapped to AF_INET)</span></span><br><span class="line"><span class="comment"> * only if s_addr is INADDR_ANY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = -EAFNOSUPPORT;</span><br><span class="line"><span class="keyword">if</span> (addr-&gt;sin_family != AF_UNSPEC ||</span><br><span class="line">    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>inet_addr_type(net, addr-&gt;sin_addr.s_addr); 做了地址类型检查， 地址类型必须是本机，多播，组播中的一个，否则直接返回错误码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取根据IP地址得出地址类型</span></span><br><span class="line"><span class="comment">RTN_LOCAL 本机地址</span></span><br><span class="line"><span class="comment">RTN_MULTICAST 多播</span></span><br><span class="line"><span class="comment">RTN_BROADCAST 广播</span></span><br><span class="line"><span class="comment">RTN_UNICAST</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">chk_addr_ret = inet_addr_type(net, addr-&gt;sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">err = -EADDRNOTAVAIL;</span><br><span class="line"><span class="keyword">if</span> (!net-&gt;ipv4_sysctl_ip_nonlocal_bind &amp;&amp;</span><br><span class="line">    !(inet-&gt;freebind || inet-&gt;transparent) &amp;&amp;</span><br><span class="line">    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY) &amp;&amp;</span><br><span class="line">    chk_addr_ret != RTN_LOCAL &amp;&amp;</span><br><span class="line">    chk_addr_ret != RTN_MULTICAST &amp;&amp;</span><br><span class="line">    chk_addr_ret != RTN_BROADCAST)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure><ol start="3"><li>获取端口号，并且对保留端口做访问权限检查。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">err = -EACCES;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3.要绑定的端口小于1024时候，要求运行该应用程序的为超级权限</span></span><br><span class="line"><span class="comment">* 否则返回并报权限不运行的错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp;</span><br><span class="line">    !ns_capable(net-&gt;user_ns, CAP_NET_BIND_SERVICE))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure><ol start="4"><li>bind动作发生在TCP三次握手之前，此时TCP状态应该是CLOSE且没有绑定过其他端口</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;inet_num)</span><br><span class="line"><span class="keyword">goto</span> out_release_sock;</span><br></pre></td></tr></table></figure><ol start="5"><li>端口号能否被绑定检查,端口没有被使用返回0，否则返回非0。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">err = -EADDRINUSE;</span><br><span class="line"><span class="keyword">goto</span> out_release_sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>更新<code>sk_userlocks</code>标记，表明本地地址和端口已经绑定</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line"><span class="keyword">if</span> (inet-&gt;inet_rcv_saddr)</span><br><span class="line">sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;</span><br><span class="line"><span class="keyword">if</span> (snum)</span><br><span class="line">sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;</span><br><span class="line">inet-&gt;inet_sport = htons(inet-&gt;inet_num);<span class="comment">//端口绑定</span></span><br></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>客户端主动发起连接，调用connect</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>connect最后调用系统调用sys_connect</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_connect</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr __user *uservaddr, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="keyword">char</span> address[MAX_SOCK_ADDR];</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">sock = sockfd_lookup(fd, &amp;err);</span><br><span class="line"><span class="keyword">if</span> (!sock)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">err = move_addr_to_kernel(uservaddr, addrlen, address);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">err = sock-&gt;ops-&gt;<span class="built_in">connect</span>(sock, (struct sockaddr *) address, addrlen,</span><br><span class="line"> sock-&gt;file-&gt;f_flags);</span><br><span class="line">out_put:</span><br><span class="line">sockfd_put(sock);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找sock,将地址从用户空间拷贝内核空间，这些操作与bind()分析一样， 这里不再赘述，主要看下 <code>sock-&gt;ops-&gt;connect</code></p><p>对于ipv4这个family来说,type为<code>SOCK_STREAM，</code>sock-&gt;ops指向inet_stream_ops，sock-&gt;ops-&gt;connect指向inet_stream_ops的connect, 即<code>inet_stream_connect</code>.</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://s1.ax1x.com/2020/08/07/ahrMnO.png" alt="ahrMnO.png"></p><ol><li>调用ip_route_connect进行寻路, 取得struct rtable，目的是为了确定下一跳目的地址</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tmp = ip_route_connect(&amp;rt, nexthop, inet-&gt;saddr,</span><br><span class="line">       RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,</span><br><span class="line">       IPPROTO_TCP,</span><br><span class="line">       inet-&gt;sport, usin-&gt;sin_port, sk);</span><br><span class="line"><span class="keyword">if</span> (!inet-&gt;opt || !inet-&gt;opt-&gt;srr)</span><br><span class="line">daddr = rt-&gt;rt_dst;</span><br></pre></td></tr></table></figure><ol><li>设置套接字状态为SYN_SENT</li><li>调用<code>tcp_v4_hash_connect(sk)</code></li></ol><p>这一步的目的是绑定端口，并且将套接字插入到bind链表，哈希链表以port为关键字，将地址相同的串在一个链表上(哈希冲突)。</p><p>这一步之前source port可能还为0(对于client端调用socket后直接调用connect不经过bind的情况, source port为0).所以该方法会生成一个随机的source port, 赋给struct inet_sk的inet_sport成员</p><ol><li><code>ip_route_newports</code> 分配完端口后，再查一次路由</li><li>生成初始序列号ISN</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secure_tcp_sequence_number(inet-&gt;saddr,inet-&gt;daddr,inet-&gt;sport,usin-&gt;sin_port);</span><br></pre></td></tr></table></figure><ol><li><code>tcp_connect()</code>构造SYN，将连接数据包发送出去</li></ol><ul><li><code>buff = alloc_skb(MAX_TCP_HEADER + 15, sk-&gt;sk_allocation);</code> 分配skb</li><li><code>TCP_SKB_CB(buff)-&gt;flags = TCPCB_FLAG_SYN;</code>设置syn 标志</li><li><code>__skb_queue_tail(&amp;sk-&gt;sk_write_queue, buff);</code> 将构建好的skb添加到套接字对应的写队列</li><li><code>tcp_transmit_skb(sk, skb_clone(buff, GFP_KERNEL));</code>  tcp层实际的处理和传输过程</li><li><code>tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp-&gt;rto);</code>   设定syn超时重传</li></ul><blockquote><p>我们说connect() 调用时候发送SYN, 在返回之前回复对方ACK ,在代码中体现?</p></blockquote><p>客户端发送syn之后，阻塞在<code>inet_wait_for_connect()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">inet_wait_for_connect</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DEFINE_WAIT(wait);</span><br><span class="line"></span><br><span class="line">prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Basic assumption: if someone sets sk-&gt;sk_err, he _must_</span></span><br><span class="line"><span class="comment"> * change state of the socket from TCP_SYN_*.</span></span><br><span class="line"><span class="comment"> * Connect() does not allow to get error notifications</span></span><br><span class="line"><span class="comment"> * without closing the socket.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//循环检查状态变化</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">release_sock(sk);</span><br><span class="line">timeo = schedule_timeout(timeo);</span><br><span class="line">lock_sock(sk);</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current) || !timeo)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br><span class="line">finish_wait(sk-&gt;sk_sleep, &amp;wait);</span><br><span class="line"><span class="keyword">return</span> timeo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端在收到SYN+ACK之后，调用流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp_v4_rcv→tcp_v4_do_rcv→tcp_rcv_state_process→tcp_rcv_synsent_state_process</span><br></pre></td></tr></table></figure><p>在函数tcp_rcv_state_process中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TCP_SYN_SENT:</span><br><span class="line">        tp-&gt;rx_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">        tcp_mstamp_refresh(tp);</span><br><span class="line">        <span class="comment">//进入tcp_rcv_synsent_state_process处理</span></span><br><span class="line">        queued = tcp_rcv_synsent_state_process(sk, skb, th);</span><br><span class="line">        <span class="keyword">if</span> (queued &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> queued;</span><br><span class="line">        <span class="comment">/* Do step6 onward by hand. */</span></span><br><span class="line">        tcp_urg(sk, skb, th);</span><br><span class="line">        __kfree_skb(skb);</span><br><span class="line">        tcp_data_snd_check(sk);</span><br><span class="line">        retur</span><br></pre></td></tr></table></figure><p>在tcp_rcv_synsent_state_process中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查ACK的有效性</span></span><br><span class="line">tcp_ack(sk, skb, FLAG_SLOWPATH);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果ack有效,则完成连接，将状态兄TCP_SYN_SENT-&gt;TCP_ESTABLISHED</span></span><br><span class="line">tcp_finish_connect(sk, skb);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//发送ack</span></span><br><span class="line"> tcp_send_ack(sk);</span><br></pre></td></tr></table></figure><p>tcp_finish_connect将连接状态设为TCP_ESTABLISHED，然后唤醒之前阻塞在<code>inet_wait_for_connect()</code>  的进程，至此connet()完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_finish_connect</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    tcp_set_state(sk, TCP_ESTABLISHED); <span class="comment">/* 在这里设置为连接已建立的状态 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (! sock_flag(sk, SOCK_DEAD)) &#123;</span><br><span class="line">        sk-&gt;sk_state_change(sk); <span class="comment">/* 指向sock_def_wakeup，会唤醒调用connect()的进程，完成连接的建立 */</span></span><br><span class="line">        sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT); <span class="comment">/* 如果使用了异步通知，则发送SIGIO通知进程可写 */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/18609397/whats-the-difference-between-sockaddr-sockaddr-in-and-sockaddr-in6" target="_blank" rel="noopener"><a href="https://stackoverflow.com/questions/18609397/whats-the-difference-between-sockaddr-sockaddr-in-and-sockaddr-in6" target="_blank" rel="noopener">What’s the difference between sockaddr, sockaddr_in, and sockaddr_in6?</a></a></p><p><a href="https://vcpu.me/bind/" target="_blank" rel="noopener">bind</a></p><p><a href="https://johnhx.github.io/2017/05/11/LinuxKernel-Connect-flow/" target="_blank" rel="noopener">Linux内核网络子系统源码分析(2) – connect系统调用</a></p><p><a href="https://blog.csdn.net/zhangskd/article/details/45508569" target="_blank" rel="noopener">Socket层实现系列 - connect()的实现_zhangskd的专栏-CSDN博客_inet_csk_wait_for_connect</a></p><p><a href="https://e-mailky.github.io/2017-01-14-tcp-connect" target="_blank" rel="noopener">socket建立连接 sys_connect</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析了套接字创建到连接过程中，一些关键的函数调用以及数据结构，同时分析了connect()过程中tcp三次握手状态变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>网络协议栈收包过程小结</title>
    <link href="http://yoursite.com/2020/08/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%94%B6%E5%8C%85%E8%BF%87%E7%A8%8B%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/08/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%94%B6%E5%8C%85%E8%BF%87%E7%A8%8B%E5%B0%8F%E7%BB%93/</id>
    <published>2020-08-05T13:19:25.000Z</published>
    <updated>2020-08-08T02:47:57.119Z</updated>
    
    <content type="html"><![CDATA[<p>linux网络协议栈学习小结</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>下面的包分析基于下面的TCP/IP四层协议栈，内核代码基于2.6版本。</p><p><img src="https://s1.ax1x.com/2020/08/08/a42rFO.png" alt="a42rFO.png"></p><h3 id="发包过程"><a href="#发包过程" class="headerlink" title="发包过程"></a>发包过程</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层是数据包发送起始点， 应用进程通过套接字API发起写系统调用。对套接字做读写操作，和对普通文件做读写操作相似，在linux中万物皆是文件。</p><p>常用的写套接字API如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>send</code>,<code>write</code>,<code>writev</code>只能用于面向连接的套接字(SO_STREAM)。</p><p><code>writev()</code>可以指定一系列的缓冲区，收集要写的数据，使可以安排数据保存在多个缓冲区中，然后同时写出去，从而避免出现Nagle和延迟ACK算法的相互影响，起到类似”gather write”的效果。 </p><p><strong>struct iovec</strong>结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *iov_base; <span class="comment">/*基本地址指针，指向缓冲区*/</span></span><br><span class="line"><span class="keyword">size_t</span> iov_len; <span class="comment">/*指定缓冲区长度*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述的套接字API接口处理流程相似</p><ul><li>输入参数都是描述符，我们需要将<code>fd-&gt; struct sock</code>。</li><li>创建消息头部，套接字控制信息(uid,pid,…)</li></ul><p>无论我们通过<code>write</code>还是<code>sendmsg</code>等写操作，最后都会到<code>sock_senmsg()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">iocb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> <span class="title">siocb</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">init_sync_kiocb(&amp;iocb, <span class="literal">NULL</span>);</span><br><span class="line">iocb.<span class="keyword">private</span> = &amp;siocb;</span><br><span class="line">ret = __sock_sendmsg(&amp;iocb, sock, msg, <span class="built_in">size</span>);</span><br><span class="line"><span class="keyword">if</span> (-EIOCBQUEUED == ret)</span><br><span class="line">ret = wait_on_sync_kiocb(&amp;iocb);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__sock_sendmsg()做了一些安全检查之后，会调用协议相关的消息发送函数<code>sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size)</code>，协议相关的 操作集在套接字创建过程通过type,family初始化。举个例子，如果是一个TCP套接字，那么实际将调用tcp_sendmsg,如果是一个UDP套接字，将调用udp_sendmsg。</p><h4 id="套接字接口层"><a href="#套接字接口层" class="headerlink" title="套接字接口层"></a>套接字接口层</h4><p>我们在实际做网络通信过程中，一般需要经过这几个步骤</p><ul><li>通过<code>socket()</code>创建套接字</li><li><code>bind()</code>绑定套接字</li><li><code>listen()</code>监听套接字</li></ul><p>这里详细参考我的这篇文章   <a href="https://hustddl.com/2020/08/08/socket%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%B0%8F%E7%BB%93/#more" target="_blank" rel="noopener">socket从创建到连接过程小结</a></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>TCP 栈简要过程：</p><ol><li><p>tcp_sendmsg 函数会首先检查已经建立的 TCP connection 的状态，然后获取该连接的 MSS，开始 segement 发送流程。</p></li><li><p>构造 TCP 段的 playload：它在内核空间中创建该 packet 的 sk_buffer 数据结构的实例 skb，从 userspace buffer 中拷贝 packet 的数据到 skb 的 buffer。</p></li><li><p>构造 TCP header。</p></li><li><p>计算 TCP 校验和（checksum）和 顺序号 （sequence number）。 </p><p>TCP 校验和是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现 TCP 首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则 TCP 段会被直接丢弃。TCP 校验和覆盖 TCP 首部和 TCP 数据。</p></li><li><p>发到 IP 层处理：调用 IP handler 句柄 ip_queue_xmit，将 skb 传入 IP 处理流程。</p></li></ol><hr><p>具体到一些细节</p><p><strong>tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,size_t size)</strong></p><p>按照之前的分析，<strong>sock_sendmsg</strong>最终调用<strong>tcp_sendmsg</strong>,我们知道TCP是一个面向连接的协议，因此在发送数据之前，内核会检查TCP的连接状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wait for a connection to finish. */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT))</span><br><span class="line"><span class="keyword">if</span> ((err = sk_stream_wait_connect(sk, &amp;timeo)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br></pre></td></tr></table></figure><p>从上面的代码可以发现，如果连接尚未建立，不处于<strong>ESTABLISHED</strong>或者<strong>CLOSE_WAIT</strong>状态，那么进程进行睡眠，等待三次握手的完成。被动关闭方收到FIN,处于CLOSE_WAIT状态，此时处于半关闭状态，仍然可以发数据(不要错看成TIME-WAIT)了。</p><h5 id="tcp建立连接"><a href="#tcp建立连接" class="headerlink" title="tcp建立连接"></a>tcp建立连接</h5><p>在传输数据之前，tcp作为面向连接的协议，需要先通过三次握手来建立连接。篇文章是很好的 <a href="http://www.leviathan.vip/2018/08/09/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-TCP%E5%8D%8F%E8%AE%AE-1/" target="_blank" rel="noopener">参考</a></p><p><img src="http://www.leviathan.vip/2018/08/09/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-TCP%E5%8D%8F%E8%AE%AE-1/tcp_3.png" alt="Imgur"></p><h5 id="tcp-senmsg"><a href="#tcp-senmsg" class="headerlink" title="tcp_senmsg"></a>tcp_senmsg</h5><p>一旦连接建立好，<code>tcp_sendmsg()</code>先做了发包之前的准备工作，比如获取<code>mss(maxium segment size)</code>,mss规定了一次发送的最大数据大小，mss的值一般为1460byte,因为数据链路层的MTU一般为1500byte,mss加上tcp，ip头部即得到MTU。</p><p>具体到发送数据，这里<strong>第一次涉及到用户空间数据到内核空间的拷贝</strong>， 内核先分配<code>struct sk_buff</code>。 如果skb的线性数据区还有剩余空间，就复制用户进程数据到线性数据区中,如果线性区域使用完，就使用分页区域， 通过<code>skb copy to page</code>拷贝用户空间的数据到skb的分页中，同时计算校验和。</p><h5 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h5><p>这里看下sk_buff中线性区域和非线性区域具体细节。</p><p>有四个指针，标识线性区域，（head,end)表示分配的缓存范围，(data,tail)表示实际数据的范围。head指针和end指针指向的位置一直都不变，对于数据的变化和协议信息的添加都是通过data指针和tail指针的改变来表现的。</p><p>sk_buff中有几个长度很容易搞混，这里梳理一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sk_buff-&gt;data_len ;分片中数据的长度，即是分片结构体中page指向的数据区长度</span><br><span class="line">sk_buff-&gt;len;当前缓冲区中数据块的大小的总长度,即线性缓存长度+data_len</span><br><span class="line">sk_buff-&gt;truelen;  缓冲区的总长度，包括sk_buff结构和数据部分 即 sk_buff-&gt;len+sizeof(sk_buff)</span><br></pre></td></tr></table></figure><p>下面的图大致描述了sk_buff结构</p><p><img src="https://s1.ax1x.com/2020/07/13/UYKpCt.png" alt="UYKpCt.png"></p><h5 id="tcp-transmit-skbs"><a href="#tcp-transmit-skbs" class="headerlink" title="tcp_transmit_skbs"></a><strong>tcp_transmit_skbs</strong></h5><p><strong>tcp_sendmsg</strong>最终通过调用<code>tcp_transmit_skb</code> 将数据包传到IP层。这里面主要做了这几件事情。首先，sk_buff是没有头部信息的，我们需要自己构造TCP头部，包含了源端口，目的端口，序列号等。与头部相关的数据结构为<code>struct scphdr</code>,定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line">__u16source;</span><br><span class="line">__u16dest;</span><br><span class="line">__u32seq;</span><br><span class="line">__u32ack_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LITTLE_ENDIAN_BITFIELD)</span></span><br><span class="line">__u16res1:<span class="number">4</span>,</span><br><span class="line">doff:<span class="number">4</span>,</span><br><span class="line">fin:<span class="number">1</span>,</span><br><span class="line">syn:<span class="number">1</span>,</span><br><span class="line">rst:<span class="number">1</span>,</span><br><span class="line">psh:<span class="number">1</span>,</span><br><span class="line">ack:<span class="number">1</span>,</span><br><span class="line">urg:<span class="number">1</span>,</span><br><span class="line">ece:<span class="number">1</span>,</span><br><span class="line">cwr:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__BIG_ENDIAN_BITFIELD)</span></span><br><span class="line">__u16doff:<span class="number">4</span>,</span><br><span class="line">res1:<span class="number">4</span>,</span><br><span class="line">cwr:<span class="number">1</span>,</span><br><span class="line">ece:<span class="number">1</span>,</span><br><span class="line">urg:<span class="number">1</span>,</span><br><span class="line">ack:<span class="number">1</span>,</span><br><span class="line">psh:<span class="number">1</span>,</span><br><span class="line">rst:<span class="number">1</span>,</span><br><span class="line">syn:<span class="number">1</span>,</span><br><span class="line">fin:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span><span class="meta-string">"Adjust your &lt;asm/byteorder.h&gt; defines"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__u16window;</span><br><span class="line">__u16check;</span><br><span class="line">__u16urg_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现结构体的布局和大小端是有关系的，但是只涉及到标志位。</p><h5 id="字节序和比特序"><a href="#字节序和比特序" class="headerlink" title="字节序和比特序"></a>字节序和比特序</h5><p>先问自己一个问题</p><blockquote><p> 上述代码如果不添加条件编译语句，为什么不具有移植性?</p></blockquote><p>字节序的最小单位是1个字节，位域的最小单位是一个位域字段。</p><p>位域，也就是变量后面跟上冒号接数字表示这个变量占几个比特位的这种字段，比如：__u16    res1:4这表示ihl只占用了4个比特位。由于位域并不固定几个比特位，所以系统没法提供基于位域的大小端转换函数(htons,htonl.etc)。</p><p>之所以offset以及FIN等标志位要按照大端，小端字节序判断，就是为了使得主机无论是大端还是小端，offset相对fin标志位总是处于内存低地址处。</p><p><a href="https://yizhi.ren/2016/11/14/bitorder/" target="_blank" rel="noopener">位域</a></p><p>在<code>tcp_transmit_skb</code> 中实际填充tcp头部的过程如下，将seq,ack_seq做了主机字节序到网络字节序的转化。计算tcp头部检验和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">th-&gt;source= inet-&gt;sport;</span><br><span class="line">th-&gt;dest= inet-&gt;dport;</span><br><span class="line">th-&gt;seq= htonl(tcb-&gt;seq);</span><br><span class="line">th-&gt;ack_seq= htonl(tp-&gt;rcv_nxt);</span><br><span class="line">th-&gt;check= <span class="number">0</span>;</span><br><span class="line">th-&gt;urg_ptr= <span class="number">0</span>;</span><br><span class="line">tp-&gt;af_specific-&gt;send_check(sk, th, skb-&gt;len, skb);<span class="comment">// 计算tcp头部校验和</span></span><br></pre></td></tr></table></figure><p>具体看下检验和是如何计算的，发现除了用到tcp头部的信息，还有用到发送端，接收端的ip地址，这么做的目的是因为TCP头部不包含这些信息，为了提高检验能力，我们在计算checksum时，人为的加上一个”伪首部”，伪首部并不会在网络中传输。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_v4_send_check</span><span class="params">(struct sock *sk, struct tcphdr *th, <span class="keyword">int</span> len,struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_HW) &#123;</span><br><span class="line">th-&gt;check = ~tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr, <span class="number">0</span>);</span><br><span class="line">skb-&gt;csum = offsetof(struct tcphdr, check);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">th-&gt;check = tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr,</span><br><span class="line"> csum_partial((<span class="keyword">char</span> *)th,</span><br><span class="line">      th-&gt;doff &lt;&lt; <span class="number">2</span>,</span><br><span class="line">      skb-&gt;csum));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过调用<code>queue_xmit</code>将待发送数据添加到待发送队列。 发送队列的具体位置如下图</p><img src="https://user-gold-cdn.xitu.io/2019/4/19/16a35787afe2efd7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="消息发送" style="zoom:80%;" /><h4 id="IP层"><a href="#IP层" class="headerlink" title="IP层"></a>IP层</h4><p>对于单播发包，函数调用的流程图如下：</p><p><img src="https://s1.ax1x.com/2020/08/05/ayf6uF.png" alt="ayf6uF.png"></p><p>上图可以看到，当 L4 层有数据包待发送时，对于TCP包它将调用<code>ip_queue_xmit</code>它们将这些包交由<code>NETFILTER（ LOLACL_OUT）</code>处理后，然后交给 dst_output，这会根据是多播或单播选择合适的发送函数。如果是单播，它会调用 ip_output()，然后是 <code>ip_finish_output()</code>，这个函数主要是检查待发送的数据包大小是否超过 MTU，如果是，则要首先调用 <code>ip_fragment()</code>将其分片，然后再传给 <code>ip_finish_output2()</code>,由它交给链路层处理了。  </p><p>IP层在TCP数据包的基础上，主要做下面几件事情</p><ul><li>构建IP头部</li><li>路由查询以及维护TTL(time to live)</li><li>包分片</li><li>Netfilter与iptabels做防火墙过滤</li></ul><p>如果数据包发送的目的端是本机应用程序，那么数据包将不经过底层协议栈，直接到接收方的TCP层。</p><h5 id="分片细节"><a href="#分片细节" class="headerlink" title="分片细节"></a><strong>分片细节</strong></h5><p>总的思路就是当L4层传过来的包大于MTU,通过循环，每次分配一个skb，然后将原来skb里面的IP头部部分数据拷贝到新分配的skb中，不同分片的标识号是一样的，不同之处在分片中起始数据相对原始报文的偏移，以及<code>MF(more fregment)</code>等一些标志位。</p><p>这里主要关注不同分片IP头部中offset如何设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-2.6.11\net\ipv4\ip_output.c*/</span></span><br><span class="line"><span class="comment">//ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff*)) slow_path:</span></span><br><span class="line">left = skb-&gt;len - hlen;<span class="comment">//待分片长度</span></span><br><span class="line">offset = (ntohs(iph-&gt;frag_off) &amp; IP_OFFSET) &lt;&lt; <span class="number">3</span>;<span class="comment">//从待分片报文提取offset</span></span><br><span class="line"><span class="comment">//循环分片</span></span><br><span class="line"><span class="keyword">while</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    len=left;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; mtu) len = mtu;</span><br><span class="line">    <span class="comment">//分配skb结构体,以及做一些填充工作</span></span><br><span class="line">    skb2 = alloc_skb(len+hlen+ll_rs, GFP_ATOMIC)</span><br><span class="line">    iph = skb2-&gt;nh.iph;</span><br><span class="line">    iph-&gt;frag_off = htons((offset &gt;&gt; <span class="number">3</span>));<span class="comment">//设置offset</span></span><br><span class="line">    offset += len;<span class="comment">//更新offset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ip_queue_xmit</strong></p><p>tcp层最中通过<code>tp-&gt;af_specific-&gt;queue_xmit(skb, 0);</code>将数据包传到了IP层，具体到TCP协议，就是调用<code>ip_queue_xmit</code></p><ul><li>调用<code>__sk_dst_check</code>对路由信息做检查</li><li>调用<code>ip_route_output_flow</code> ,这里是实际做路由计算的点，调用<code>__ip_route_output_key</code>来查找一条路径，使用<code>struct flowi</code>来记录路由查询信息，首先从缓存中查找，如果没找到就从FIB里面找(Forwarding Information Base)</li></ul><p>在做路由的过程中，可能会有下面几种可能</p><ul><li>包继续forwarded,  到ip_forward</li><li>包路由失败，不能解析，到ip_output </li><li>包路由解析成功，到dev_queue_xmit</li></ul><p>假设我们成功做了路由解析，找到了一条到目的端路径，那么就通过<code>dev_queue_xmit</code>到了数据链路层。</p><h5 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a><strong>Netfilter</strong></h5><p>在数据流中什么位置(过滤点)对数据包做什么操作(规则)。</p><ol><li>过滤点(chain)，输入，输出，转发，路由前，路由后</li><li>过滤规则: <ul><li>filter</li><li>nat</li><li>magle </li></ul></li></ol><p><img src="https://img2018.cnblogs.com/i-beta/729011/202002/729011-20200206184522753-754025474.png" alt=""></p><ol><li>当数据包从物理层和数据链路层传输过来，如果数据包是访问Linux主机本身。则经过PRE_ROUTING和LOCAL_IN钩子函数，到达传输层和应用层。</li><li>当数据包从物理层和数据链路层传输过来，如果数据包需要转发，则经过PRE_ROUTING、FORWARD和POST_ROUTING三个钩子函数。</li><li>当数据包从Linux主机本身向外发送数据包，要经过LOCAL_OUT和POST_ROUTING钩子函数。</li></ol><p>以发数据为例，本地产生的数据经过HOOK函数<code>NF_IP_LOCAL_OUT</code> 处理后，进行路由选择处理，然后经过<code>NF_IP_POST_ROUTING</code>处理后发送出去。</p><h5 id="hook原理"><a href="#hook原理" class="headerlink" title="hook原理"></a>hook原理</h5><p>所有的回调函数都注册在二维数组全局变量<code>struct list_head nf_hooks[NFPROTO_NUMPROTO][NF_MAX_HOOKS] __read_mostly;</code>中。。数组的第一个维度是注册回调函数的协议族，第二个维度是注册回调函数的hook点，也就是每一个协议族的每一个hook点都是一个双向链表连接的一组回调函数。</p><p>当代码执行到HOOK点根据协议类型， HOOK点编号，来遍历执行对应链表所有注册的回调函数，hook点回调函数处理完毕并允许下一步逻辑执行时,<code>okfn</code>被执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NF_HOOK(pf, hook, skb, indev, outdev, okfn)</span><br></pre></td></tr></table></figure><p><a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">深入理解 iptables 和 netfilter 架构</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-ntflt/index.html" target="_blank" rel="noopener">Linux Netfilter实现机制和扩展技术</a></p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层负责将ip层的数据加上包头，发送给网卡。</p><p><strong>dev_queue_xmit</strong></p><p>在这个函数中，一开始通过屏蔽所有的软中断(buttom-half)来获得设备的队列锁，接着调用<code>qdisc_run()</code>检查设备是否数据包需要传输，如果设备忙，那么该函数将再次在软中断中被调用。<code>qdisc_restart</code>获取设备的<code>xmit</code>锁，如果成功就调用<code>dev-&gt;hard_start_xmit</code>来完成最终的数据包传输，这个调用是和具体的设备有关系。一旦网卡完成报文发送，将产生中断通知 CPU，然后驱动层中的中断处理程序就可以删除保存的 skb 了。</p><h5 id="网卡中断收发包机制"><a href="#网卡中断收发包机制" class="headerlink" title="网卡中断收发包机制"></a>网卡中断收发包机制</h5><p>一般的当网卡有数据到来，通过产生一个硬件中断来通知CPU处理，在运行中断服务历程(ISR)时候，将屏蔽所有中断，也就意味着在执行硬件中断服务时候，不能被抢占，如果中断服务处理的任务比较轻，比如响应键盘等，这个是没有问题的。但是，网卡的中断需要处理的任务是很重的，比如说分配缓存结构体<code>sk_buff</code>,将接收数据拷贝到<code>sk_buff</code>等等，中断服务在处理这些任务时候占用了大量的CPU时间，导致不能及时相应其他的中断。</p><p>为了解决上述的问题，linux将中断的处理分为两个步骤top-half,buttom-half。其主要区别就在于上半部分执行的时候禁止一些或者全部中断，下半部分执行期间中断是打开的，可以响应所有中断。上半部分一定运行在中断上下文中，下半部分有很多种实现方式，根据不同的实现方式可能运行在中断上下文中，也可能运行在任务(process)上下文中。上半部分实际响应<code>request_irq()</code>，下半部分推迟实现，以软中断为例，在上半部分硬件中断返回后标记，然后触发软中断。(这一块具体可以参考《内核设计与实现》第八章)</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>下图总结了数据从用户态拷贝到内核，然后经过内核协议栈到最后网卡发送的整个流程。</p><p><img src="http://www.uml.org.cn/embeded/images/201604141011.png" alt="img"></p><h4 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h4><p><code>struct inet_sock</code>是INET域专用的一个socket表示，它是在struct sock的基础上进行的扩展，在基本socket的属性已具备的基础上，struct inet_sock提供了INET域专有的一些属性，比如TTL，组播列表，IP地址，端口等。</p><h5 id="网卡多队列"><a href="#网卡多队列" class="headerlink" title="网卡多队列"></a>网卡多队列</h5><p>概念：一张网卡具有多个接收队列</p><p>解决问题</p><p>每个cpu有一个软中断线程对应网卡收包，当网卡流量特别大情况下，就会导致cpu负载高，性能存在瓶颈；</p><p>工作原理</p><p>网卡多任务队列将收到的包根据四元组信息做哈希运算，然后放到多队列其中一个，之后该连接所有的包都将经过相同队列，每个队列对应不同cpu的软中断，这样就实现了网卡收包的负载均衡，避免了某些cpu负载特别高。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/aiwz/p/6333235.html" target="_blank" rel="noopener">tcp_sendmsg</a></p><p><a href="https://wiki.linuxfoundation.org/networking/kernel_flow#transmission_path" target="_blank" rel="noopener">transmission_path</a></p><p><a href="https://www.slideshare.net/hugolu/the-linux-networking-architecture" target="_blank" rel="noopener">linux网络架构</a></p><p>《understading linux kernel internals》</p><p><a href="http://www.uml.org.cn/embeded/2016041410.asp?artid=17878" target="_blank" rel="noopener"> <strong>Linux 网络栈</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux网络协议栈学习小结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>并发</title>
    <link href="http://yoursite.com/2020/08/05/%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/08/05/%E5%B9%B6%E5%8F%91/</id>
    <published>2020-08-05T13:17:21.000Z</published>
    <updated>2020-08-08T02:17:12.819Z</updated>
    
    <content type="html"><![CDATA[<p>《OSTEP》线程并发小结</p><a id="more"></a><h4 id="理解多线程为什么会有竞争状态问题"><a href="#理解多线程为什么会有竞争状态问题" class="headerlink" title="理解多线程为什么会有竞争状态问题"></a>理解多线程为什么会有竞争状态问题</h4><p>多线程对共享资源访问，可能不是原子操作，导致不确定结果。</p><h4 id="条件量使用"><a href="#条件量使用" class="headerlink" title="条件量使用"></a>条件量使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>wait 操作传入参数除了条件变量还有锁，这样做的目的是为了把进程休眠同时释放锁。否则其他线程就没法获得锁，唤醒休眠线程。</p><p>下面代码做线程之间同步存在什么问题</p><ol><li>spin 忙等待浪费cpu</li></ol><p>但是这个能够实现线程之间同步操作么?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局标志变量</span></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//thread A</span></span><br><span class="line"><span class="keyword">while</span>(flag==<span class="number">0</span>); <span class="comment">//spin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//thread B singal</span></span><br><span class="line">flag=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="锁的设计"><a href="#锁的设计" class="headerlink" title="锁的设计"></a>锁的设计</h4><p>在设计锁之前，有几个指标能够来衡量设计方案的好坏。</p><ol><li><p>能否实现互斥</p></li><li><p>公平性(防止饥饿）</p></li><li><p>实现锁带来的额外负担</p></li></ol><p>最直接的想法是通过关闭中断来实现互斥，竞态条件下执行结果的不稳定，就是因为线程执行过程中被打断，调度。我们通过关闭中断，就能够实现对资源的互斥访问，但是这个在实际情况不太可能实现(多CPU,以及关闭中断带来的巨大风险)。</p><h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p>通过硬件支持的同步原语来实现互斥，首先我们看一个没有原子操作的互斥锁方案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span> <span class="keyword">int</span> flag; &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">mutex-&gt;flag = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>);<span class="comment">// TEST the flag spin-wait (do nothing)</span></span><br><span class="line">mutex-&gt;flag = <span class="number">1</span>;<span class="comment">// now SET it!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>上述方案的问题在于检查flag和设置flag不是原子操作，可能存在一种情况线程A执行完while()然后被调度，导致两个线程都获得锁。</p><p>改进方案如下</p><p>CAS（compare and swap）一种原子操作，</p><p>bool CAS(V, A,B) // 检查现有V 是否与A== 如果== 将V设置为B 同时返回true</p><p><strong>自旋锁伪码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CAS（compare <span class="keyword">and</span> swap）一种原子操作，</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAS</span><span class="params">(V, A,B)</span> <span class="comment">// 检查现有V 是否与A== 如果==  将V设置为B 同时返回true</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">自旋锁伪码实现</span><br><span class="line"><span class="keyword">bool</span> flag =<span class="literal">false</span>; <span class="comment">//锁为true 表示被占用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!CAS(flag,<span class="literal">false</span>,<span class="literal">true</span>));</span><br><span class="line"><span class="comment">//do-something</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//release lock</span></span><br><span class="line">flag=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>自旋锁虽然能够实现对临界区的互斥访问，但是带来了性能问题，spin通过忙等待形式去获取锁，导致了CPU资源的浪费。</p><p>比如场景：单核cpu运行多个线程</p><p>线程1获得lock进入临界区,然后被打断，线程2被调度，一直自旋等待锁被释放。</p><h5 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h5><p>针对上述问题，一种解决方法是通过主动放弃CPU，当线程发现锁被占用，主动将自己的状态由RUNNING-&gt;READY， 避免了自旋等待占用CPU。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!CAS(flag,<span class="literal">false</span>,<span class="literal">true</span>)) <span class="built_in">yield</span>();</span><br></pre></td></tr></table></figure><p>yield 带来的问题</p><ol><li><p>大量的上下文切换操作</p></li><li><p>仍然没有解决饥饿问题</p></li></ol><h5 id="sleep队列"><a href="#sleep队列" class="headerlink" title="sleep队列"></a>sleep队列</h5><p>无论自旋，还是yield， 调度器的选择很多，导致了资源的浪费。如果线程发现自己暂时不能获取锁，将自己休眠，就带来了效率提升。</p><p>下面实现代码还是很巧妙的</p><ul><li>guard作用: 用于自旋等待变量</li></ul><p>相比于自旋等待整个临界区，gaurd的获取和释放间隔很短；eg.多核CPU, 当一个进程A拿到gaurd,然后另一个进程B被调度，此时B就拿不到gaurd，自旋等待，但是由于A临界区代码很短，很快A就会释放gaurd.</p><ul><li>unlock()中， 唤醒线程之后，没有将flag设置为0</li></ul><p>这么做的原因是线程被唤醒之后，可以看作是从park（）返回，此时线程没有拿到guard,锁没有释放就直接传递给了被唤醒线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">int</span> guard;</span><br><span class="line"><span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">m-&gt;flag= <span class="number">0</span>;</span><br><span class="line">m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line"><span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired</span></span><br><span class="line">m-&gt;guard = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">queue_add(m-&gt;q, gettid());</span><br><span class="line">m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">park(); <span class="comment">//线程休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line"><span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock (for next thread!)</span></span><br><span class="line">m-&gt;guard = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="基于锁的数据结构"><a href="#基于锁的数据结构" class="headerlink" title="基于锁的数据结构"></a>基于锁的数据结构</h4><h5 id="并发链表设计"><a href="#并发链表设计" class="headerlink" title="并发链表设计"></a>并发链表设计</h5><p>关键在于数据结构的定义，节点如何定义(int, node*) ，链表怎么定义(锁+链表头)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic node structure</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basic list structure (one used per list)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">node_t</span> * head;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Init</span><span class="params">(<span class="keyword">list_t</span> * L)</span> </span>&#123;</span><br><span class="line">    L-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_init(&amp;L-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> * L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> * <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>)); <span class="comment">//先分配节点，只有在更新全局资源时候加锁，而不是一上来就全部加锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"malloc"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// fail</span></span><br><span class="line">    &#125;</span><br><span class="line">pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">    L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表查找需要加锁么? 不涉及到全局变量的修改，但是如果不加锁，一个线程在修改正在查找的链表，也会导致race condition</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Lookup</span><span class="params">(<span class="keyword">list_t</span> * L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">node_t</span> * curr = L-&gt;head;</span><br><span class="line">    <span class="keyword">int</span> rv=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line">            rv=<span class="number">0</span>;<span class="comment">//返回0 表示找到</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rv;  <span class="comment">// faulure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="并发哈希表"><a href="#并发哈希表" class="headerlink" title="并发哈希表"></a>并发哈希表</h5><p>有了这个基础，设计并发哈希表就很简单，通过拉链方法来避免哈希冲突</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUCKETS (101)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hash_Init</span><span class="params">(<span class="keyword">hash_t</span> * H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUCKETS; i++) &#123;</span><br><span class="line">        List_Init(&amp;H-&gt;lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Insert</span><span class="params">(<span class="keyword">hash_t</span> * H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Lookup</span><span class="params">(<span class="keyword">hash_t</span> * H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Lookup(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><blockquote><p>什么是信号量?</p><p>信号量和条件变量区别</p></blockquote><p>信号量用来做lock,也能够用来做条件变量，关键在于信号量的初始化。</p><p>信号量=变量+操作</p><p><strong>信号量操作伪码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *s)</span> </span>&#123;</span><br><span class="line">decrement the value of semaphore s by one</span><br><span class="line">wait <span class="keyword">if</span> value of semaphore s is negative</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *s)</span> </span>&#123;</span><br><span class="line">increment the value of semaphore s by one</span><br><span class="line"><span class="keyword">if</span> there are one <span class="keyword">or</span> more threads waiting, wake one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号量做二元锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> m;</span><br><span class="line">sem_init(&amp;m, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// initialize semaphore to 1</span></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line"><span class="comment">// critical section here</span></span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure><p><strong>信号量做条件变量</strong></p><p>下面代码目的是同步父子进程，父进程等待子进程结束。</p><p>注意条件变量被初始化为0，分两个情况考虑，如果子进程被创建之后先执行，sem_post将信号量+1,父进程执行sem_wait正常返回；如果父进程先执行，sem-1小于0，父进程被挂起，子进程执行，将sem+1，然后唤醒父进程。 所以符合我们预定执行顺序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">sem_post(&amp;s); <span class="comment">// signal here: child is done</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> c;</span><br><span class="line">Pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">sem_wait(&amp;s); <span class="comment">// wait here for child</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>允许多个读，一个写，第一个读者自动获得写锁，最后一个读锁释放，写锁也释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">sem_t</span> lock;</span><br><span class="line">    <span class="keyword">sem_t</span> <span class="built_in">write</span>;</span><br><span class="line">    <span class="keyword">int</span> readers;</span><br><span class="line">&#125; rw_lock;</span><br><span class="line"></span><br><span class="line">init(rw_lock*m)&#123;</span><br><span class="line">    sem_init(m-&gt;lock,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    sem_init(m-&gt;<span class="built_in">write</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    m-&gt;readers=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_acquire_read</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_wait(m-&gt;lock);</span><br><span class="line">    m-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span>(m-&gt;readers==<span class="number">1</span>) sem_wait(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">    sem_post(m-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_release_read</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_wait(m-&gt;lock);</span><br><span class="line">    m-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span>(m-&gt;readers==<span class="number">0</span>) sem_post(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">    sem_post(m-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_acquire_write</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_wait(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_acquire_write</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_post(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OSTEP》线程并发小结&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OSTEP" scheme="http://yoursite.com/tags/OSTEP/"/>
    
  </entry>
  
  <entry>
    <title>内存虚拟化</title>
    <link href="http://yoursite.com/2020/08/01/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>http://yoursite.com/2020/08/01/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/</id>
    <published>2020-08-01T01:55:22.000Z</published>
    <updated>2020-08-03T15:49:09.669Z</updated>
    
    <content type="html"><![CDATA[<p>《OSTEP》 内存虚拟化部分小结</p><a id="more"></a><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><blockquote><p>为什么引入了虚拟地址?</p></blockquote><ul><li>使得编程简单，每个应用进程有自己很大一片的地址空间，不用担心代码,变量存放到哪里</li><li>提供了进程之间的保护和隔离；如果我们直接操控物理内存，那么很可能由于进程一个不小心override导致其他进程崩溃</li></ul><p>举个例子两个进程A,B 都有自己的地址空间，eg. 对0x100访问，由于虚拟地址的映射他们对应的物理地址不同。</p><blockquote><p>设计一套虚拟内存需要满足满足那些目标?</p></blockquote><ol><li><p>透明； 对于编程者而言，我们应该是感知不到虚拟地址到物理地址之间的转化，操作系统和硬件在后面帮我们做了地址转化的这些工作</p></li><li><p>高效； 引入虚拟内存，空间角度上来看使用额外很多的内存来存储辅助数据结构，时间上不能导致程序运行变慢</p></li><li><p><strong>保护/隔离</strong>；这个我觉得是最为重要的，程序装载到内存中不能够影响到其他进程。</p><p>具体来看，虚拟内存实现机制，分段，分页下如何做进程间保护?</p></li></ol><h4 id="简单地址翻译"><a href="#简单地址翻译" class="headerlink" title="简单地址翻译"></a>简单地址翻译</h4><p>作者先做了一些假设，对虚拟内存系统设计做了一些简化，然后慢慢放宽条件，逐渐模拟一个真实场景下的虚拟内存系统。这样能够让读者循序渐进体会到系统设计面临的问题，然后慢慢引入新的方案来改进。</p><p> 一开始作者假设</p><ol><li>虚拟地址空间连续存放到物理内存</li><li>地址空间大小不超过物理内存&amp;&amp;每个进程地址空间相同</li></ol><h5 id="硬件支持地址翻译"><a href="#硬件支持地址翻译" class="headerlink" title="硬件支持地址翻译"></a>硬件支持地址翻译</h5><p>在上述假设下，有了基于硬件支持的动态重定位来做地址翻译通过硬件寄存器支持 base+limit </p><p>地址转化： <code>physical address = virtual address + base</code></p><p>limit用来做权限保护，如果虚拟地址超出了limit，程序将终止。</p><p>之前经常听到的MMU,用来做地址转化的硬件单元，这里提到的base,limit寄存器就是MMU的一部分，当然后面为了做更加复杂的地址翻译，MMU还有一些其他硬件的支持。</p><p>从操作系统角度，基于上述虚拟内存的实现方案，有几个问题要解决</p><ul><li>进程创建时，分配与地址空间对应的物理内存</li><li>当进程结束时，回收内存</li><li>进程切换，上下文保存；这里只需要保存一对base-limit寄存器</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>base+bound 的地址转化方案</p><p><strong>优点</strong></p><ul><li><p>在硬件支持下起来很高效快速</p></li><li><p>提供了进程间的保护隔离</p></li></ul><p><strong>缺点</strong></p><p>- 进程空间的整个映射到内存导致了内部碎片(heap,stack)</p><h4 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h4><p>基于单个base-limit寄存器将整个地址空间存到了内存造成了内存的浪费，我们分析主要的原因在于，stack,和heap的不确定，基于此，我们为什么不能够在单对寄存器的基础上，对code,data,stack,heap 都分配一对寄存器</p><p><img src="https://s1.ax1x.com/2020/07/31/a1UDsg.png" alt="a1UDsg.png"></p><p>我们经常见到的段错误(segment fault)就是访问非法地址，超出了bound的范围。</p><p>段表的引入带来了一个问题，如何确定访问哪一个段对应的寄存器?</p><p>显示的做法时用虚拟地址前几个bit来标识，如下图</p><p><img src="https://s1.ax1x.com/2020/07/31/a1Uwz8.png" alt="a1Uwz8.png"></p><p>分段机制下地址转化伪码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get top 2 bits of 14-bit VA</span></span><br><span class="line"><span class="comment">//Bounds[] 段表</span></span><br><span class="line">Segment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT <span class="comment">//确定是哪一个段</span></span><br><span class="line"><span class="comment">// now get offset</span></span><br><span class="line">Offset= VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"><span class="keyword">if</span> (Offset &gt;= Bounds[Segment])<span class="comment">//边界检查</span></span><br><span class="line">RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PhysAddr = Base[Segment] + Offset</span><br><span class="line">Register = AccessMemory(PhysAddr)</span><br></pre></td></tr></table></figure><p>按段加载还有一个好处使得段共享成为可能，比如将代码段设为只读，进程仍然认为访问的是私有地址空间，这样也不会破坏进程间的隔离。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>好处：</p><ul><li><p>减少了内部碎片,内存浪费</p></li><li><p>代码段等可以共享</p></li></ul><p>问题：</p><ul><li><p>大小不一的段可能导致外部碎片</p></li><li><p>内存不能做到按需分配</p></li></ul><p>产生外部碎片的原因在于，之前按照整个地址空间加载，并且进程地址空间大小一致，这样就可以将内存看作是一个大的数组，每次分配都是一个slot单位，现在按照段分配，虽然避免了内部碎片产生，但是由于每个段大小不一样，在内存的频繁分配与释放，就可能产生外部碎片，一些小的内存块就不能够得到利用。</p><h4 id="空闲物理内存管理"><a href="#空闲物理内存管理" class="headerlink" title="空闲物理内存管理"></a>空闲物理内存管理</h4><p>我们在C中分配释放内存如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>会发现当我们释放内存时候，只是给了起始地址，没有指定大小，那么系统怎么知道要释放多少了?</p></blockquote><p>分配器用额外的头部信息来记录分配内存的大小，魔数用来做完整性检查。因此当我们申请N字节大小内存，实际分配了N+sizeof(header)</p><p><img src="https://s1.ax1x.com/2020/07/31/a1UBQS.png" alt="a1UBQS.png"></p><h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><blockquote><p> free memory is first conceptually thought of as one big space of size 2N. When a request for memory is made, the search for free space recursively divides free space by two until a block that is big enough to accommodate the request is found (and a further split into two would result in a space that is too small).</p></blockquote><h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>我们说分段导致了外部碎片产生，根本原因在于段的大小不一，分页机制通过将地址空间划分为固定大小的地址单元(eg.4k)来解决这个问题。</p><p>每个进程有自己的一个页表，记录了虚拟页号和物理页号的对应关系。常见的地址映射如下</p><p>​                                               <img src="https://s1.ax1x.com/2020/07/31/a1UzOe.png" alt="a1UzOe.png"></p><p>实现页机制有几个问题</p><blockquote><p>1.页表存在哪里?</p><p>2.每一个页表项具体有什么内容?</p></blockquote><p>对于32bit地址空间，假设一个页表项4byte, 整个地址空间页表需要4M，每个进程有自己的页表，因为页表很大，不可能像段机制那样通过CPU的寄存器来存，因此我们的页表是直接存到内存里面的，刚刚分析一个页表就是4M,这个很恐怖，如果有上百个进程，光是页表就消耗了几百兆内存，因此这一部分后面是需要优化的。</p><p>X86下一个页表项的内容如下，有几个flag需要注意下</p><ul><li>P：存在位。为1表示页表或者页位于内存中。否则，表示不在内存中，必须先予以创建或者从磁盘调入内存后方可使用。</li><li>R/W：读写标志。为1表示页面可以被读写，为0表示只读。当处理器运行在0、1、2特权级时，此位不起作用。页目录中的这个位对其所映射的所有页面起作用。</li><li>U/S：用户/超级用户标志。为1时，允许所有特权级别的程序访问；为0时，仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用。</li></ul><p><img src="https://s1.ax1x.com/2020/07/31/a1UxyD.png" alt="a1UxyD.png"></p><p>由于页表位于内存，带来的后果就是我们对于一条指令的执行将额外增加一次内存访问(地址翻译)，伪码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"></span><br><span class="line"><span class="comment">// Form the address of the page-table entry (PTE)</span></span><br><span class="line">PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE)) <span class="comment">//ptbr 页表起始地址 存在寄存器里面</span></span><br><span class="line"><span class="comment">// Fetch the PTE</span></span><br><span class="line">PTE = AccessMemory(PTEAddr)v<span class="comment">//一次内存访问得到物理地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if process can access the page</span></span><br><span class="line"><span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">RaiseException(SEGMENTATION_FAULT)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// Access is OK: form physical address and fetch it</span></span><br><span class="line">offset= VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset</span><br><span class="line">Register = AccessMemory(PhysAddr) <span class="comment">//二次内存访问</span></span><br></pre></td></tr></table></figure><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>好处：</p><ul><li><p>固定大小内存单元，避免外部碎片</p></li><li><p>相对分段内存使用灵活</p></li></ul><p>缺点</p><ul><li><p>页表占用内存过大</p></li><li><p>访问太慢(相比直接内存访问，多一次内存访问)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OSTEP》 内存虚拟化部分小结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OSTEP" scheme="http://yoursite.com/tags/OSTEP/"/>
    
  </entry>
  
  <entry>
    <title>文件系统的持久化</title>
    <link href="http://yoursite.com/2020/06/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-06-11T01:54:53.000Z</published>
    <updated>2020-06-11T02:51:28.763Z</updated>
    
    <content type="html"><![CDATA[<p>《OSTEP》文件持久化部分阅读笔记</p><a id="more"></a><h3 id="什么是crash-consistency-problem"><a href="#什么是crash-consistency-problem" class="headerlink" title="什么是crash-consistency problem?"></a>什么是crash-consistency problem?</h3><p>在两次write()之间，系统可能出现异常的断电，崩溃等情况，导致磁盘文件被部分更新。</p><p>在系统重启时，文件系统被再次装载，如何解决之前异常崩溃带来的on-disk image inconsistent state 是接下来要讨论的重点</p><p>具体来看下磁盘出现不一致的情况</p><p>当我们append new data block 到一个文件，至少需要更新3个数据结构:<code>inode,data block,data bitmap</code>在更新这三个数据结构的过程中，系统都可能崩溃，在不同的阶段崩溃造成的后果不一样。</p><p><img src="https://s1.ax1x.com/2020/06/11/tHFAQx.png" alt="tHFAQx.png"></p><p>假设只有一次更新成功</p><ul><li>data block is updated  不会造成一致性问题，因为没有inode指向更新的data block</li><li>inode  造成一致性问题，与bitmap 冲突，同时由于data block没有更新，会读取脏数据。</li><li>data bitmap 同上带来一致性问题，同时带来空间泄漏，因为bitmap更新之后，指向的空间不会被系统分配</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-file-system-checker"><a href="#1-file-system-checker" class="headerlink" title="1.file system checker"></a>1.file system checker</h4><p>基本思路是让不一致发生，然后修复它。</p><p>但是存在一些问题比如,即使inode 与data bitmap 一致，仍然可能存在读取脏数据<br>其次这种做法最大的问题就是速度太慢！ 需要扫描整个磁盘来检查所有相关的数据结构。</p><ol start="2"><li><h4 id="日志-write-ahead-logging"><a href="#日志-write-ahead-logging" class="headerlink" title="日志(write-ahead logging)"></a>日志(write-ahead logging)</h4></li></ol><p>在更新磁盘之前，先将当前操作(trananactions) 记录下来，当系统崩溃时候，能够replay。这样做的好处就是能够精准定位崩溃问题，不需要扫描整个磁盘。</p><p>具体如何实现</p><h5 id="data-log"><a href="#data-log" class="headerlink" title="data log"></a>data log</h5><ol><li>Journal write: Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.</li><li>Checkpoint: Write the pending metadata and data updates to their final locations in the file system.</li></ol><p>问题<br>在写日志的时候可能崩溃</p><p>改进<br>将写日志操作拆分为两步</p><ul><li>写日志开始标志+data+inode+bitmap</li><li>写日志结束标志</li></ul><p>这样做的好处在于磁盘能够保证对单个区块(512byte)的原子操作，进而保证对单条日志记录要么成功要么失败。</p><p>日志的空间大小有限，一旦日志空间满，之后的transactions 将不能被记录。<br>具体解决方法通过循环日志(类似循环队列) 一旦一个transaction 被check了，系统就释放对应的日志空间</p><p>经过上述几个改进，我们现在的做法如下</p><ol><li><p>Journal write: Write the contents of the transaction (containing TxBand the contents of the update) to the log; wait for these writes to<br> complete.</p></li><li><p>Journal commit: Write the transaction commit block (containingTxE) to the log; wait for the write to complete; the transaction is now committed.</p></li><li><p>Checkpoint: Write the contents of the update to their final locations within the file system.</p></li><li><p>Free: Some time later, mark the transaction free in the journal by updating the journal superblock.</p></li></ol><p>上述解决方案还能进一步优化: 我们将data block 两次写到了磁盘</p><h5 id="metadata-log"><a href="#metadata-log" class="headerlink" title="metadata log"></a>metadata log</h5><p>基本操作与之前一样，只是没有将data 写到日志中。</p><ol><li>Data write: Write data to final location; wait for completion(the wait is optional; see below for details).</li><li>Journal metadata write: Write the begin block and metadata to thelog; wait for writes to complete.</li><li>Journal commit: Write the transaction commit block (containingTxE) to the log; wait for the write to complete; the transaction (including data) is now committed.</li><li>Checkpoint metadata: Write the contents of the metadata updateto their final locations within the file system.</li><li>Free: Later, mark the transaction free in journal superblock.</li></ol><p>先写data 是为了避免脏读，如果先写meta，然后系统崩溃，就会导致读取旧的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《OSTEP》文件持久化部分阅读笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口小结</title>
    <link href="http://yoursite.com/2020/06/11/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/06/11/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B0%8F%E7%BB%93/</id>
    <published>2020-06-11T01:45:39.000Z</published>
    <updated>2020-06-11T01:51:51.825Z</updated>
    
    <content type="html"><![CDATA[<p>滑动窗口可以用来优化一些暴力求解问题，将时间复杂度降低到线性。</p><a id="more"></a><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h4><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>思路</p><ul><li>先扫描一遍T，把对应的字符及其出现的次数存到 HashMap 中。</li><li>然后开始遍历S，就把遍历到的字母对应的 HashMap 中的 value 减一，如果减1后仍大于等于0，cnt 自增1。</li><li>如果 cnt 等于T串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是T串中不可缺少的字母(hash表中对应value&gt;0)，那么 cnt 自减1，表示此时T串并没有完全匹配。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t) <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">int</span> len=t.size();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,cnt=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--<span class="built_in">map</span>[s[i]]&gt;=<span class="number">0</span>) cnt++;</span><br><span class="line">            <span class="keyword">while</span>(cnt==len)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.empty()||res.size()&gt;i-j+<span class="number">1</span>) res=s.substr(j,i-j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(++<span class="built_in">map</span>[s[j++]]&gt;<span class="number">0</span>) cnt--;<span class="comment">//移动左边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>进一步理解</strong><br>本来我们是可以开两个哈希表，这里为了节省空间，将其合并，遍历S字符串的时候，哈希表中字符出现的次数可以理解还缺多少个，就可以满足和T字符串匹配。这样一来就能很好理解在移动左边界的判断条件<code>++hash[s[j++]]&gt;0</code> 表示左边界指针移动之后，缺的个数大于0.</p><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p><strong>滑动窗口</strong>  思路非常类似上一题76.最小覆盖子串</p><p>这个题目的滑动窗口大小固定，因此需要先调整大小，然后添加满足条件的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> c:p) <span class="built_in">map</span>[c]++;</span><br><span class="line">       <span class="keyword">int</span> total=p.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,cnt=<span class="number">0</span>;j&lt;s.size();j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(--<span class="built_in">map</span>[s[j]]&gt;=<span class="number">0</span>) cnt++; <span class="comment">//移动右指针</span></span><br><span class="line">           <span class="comment">//移动左指针 维护窗口大小为p.size</span></span><br><span class="line">           <span class="keyword">while</span>(j-i+<span class="number">1</span>&gt;total)&#123;</span><br><span class="line">               <span class="keyword">if</span>(++<span class="built_in">map</span>[s[i++]]&gt;<span class="number">0</span>) cnt--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(cnt==total) res.push_back(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;滑动窗口可以用来优化一些暴力求解问题，将时间复杂度降低到线性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据流算法题目小结</title>
    <link href="http://yoursite.com/2020/06/09/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/06/09/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%B0%8F%E7%BB%93/</id>
    <published>2020-06-09T00:09:21.000Z</published>
    <updated>2020-06-09T05:08:24.019Z</updated>
    
    <content type="html"><![CDATA[<p>由于数据是动态的，按照一般的做法，比如遍历，当新数据的加入，处理单个操作的时间复杂度为<code>O(n)</code>,这样往往造成TLE</p><p>通过使用合理的数据结构来存储，比如堆，能够将时间复杂度降低到 <code>logn</code></p><a id="more"></a><h4 id="703-数据流中的第K大元素"><a href="#703-数据流中的第K大元素" class="headerlink" title="703. 数据流中的第K大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">703. 数据流中的第K大元素</a></h4><p>这个本质的思想就是通过小根堆来求第K大元素，通过限制堆大小为k,以及判断堆顶元素与新加入元素val大小关系，将时间复杂度降低到logn.</p><p>有一点需要注意的就是做<code>pop()</code> 一定要检查堆是否为空。</p><h4 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></h4><p>通过使用两个堆，一个小根堆存放序列中较大的一部分元素，大根堆存放较小的一部分元素，可以形象的把这个结构想象成一个沙漏</p><p>通过堆顶元素就能够很方便的得到数据流的中位数。</p><p>当新元素val加入如何维护堆?</p><ol><li>val 先添加到大根堆maxq,  如果maxq.top&gt;minq.top 需要交换两个堆定元素</li><li>始终保持maxq.size()&lt;=minq.size()+1 这样才能通过堆顶来求中位数</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于数据是动态的，按照一般的做法，比如遍历，当新数据的加入，处理单个操作的时间复杂度为&lt;code&gt;O(n)&lt;/code&gt;,这样往往造成TLE&lt;/p&gt;
&lt;p&gt;通过使用合理的数据结构来存储，比如堆，能够将时间复杂度降低到 &lt;code&gt;logn&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>shared_from_this解决了什么问题</title>
    <link href="http://yoursite.com/2020/06/02/shared-from-this%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/02/shared-from-this%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-02T05:39:07.000Z</published>
    <updated>2020-06-07T23:57:22.596Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>enable_shared_from_this 含义<br>如果一个T类型的对象t,是被std::shared_ptr管理的，且类型T继承自<code>std::enable_shared_from_this</code>，那么T就有个<code>shared_from_this</code>成员函数，这个函数返回一个新的<code>std::shared_ptr</code>的对象，也指向对象t</p><p>如果不这么做, 会出现什么问题，看下面一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obj</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">get_shr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">ret</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">smart_ptr</span><span class="params">(<span class="keyword">new</span> obj)</span></span>;</span><br><span class="line">    obj&amp; a=*smart_ptr;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;obj&gt; b=a.get_shr(); <span class="comment">//两个智能指针管理的是同一个对象，造成对象两次释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述场景是 对象希望获得管理自己的智能指针，但是直接通过成员函数返回一个<code>shared_ptr</code>,造成了被管理对象的重复删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;enable_shared_from_this 含义&lt;br&gt;如果一个T类型的对象t,是被std::shared_ptr管理的，且类型T继承自&lt;code&gt;std::enable_shared_from_this&lt;/code&gt;，那么T就有个
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>系统调用open(),read(),write()具体发了什么?</title>
    <link href="http://yoursite.com/2020/06/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8open-read-write-%E5%85%B7%E4%BD%93%E5%8F%91%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2020/06/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8open-read-write-%E5%85%B7%E4%BD%93%E5%8F%91%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2020-06-01T04:12:25.000Z</published>
    <updated>2020-06-01T12:25:18.707Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要想探究的是我们平时说的IO系统调用与<code>inode</code>，文件系统等之间的交互，或者说，在做文件IO时候，有那些底层的数据结构参与进来。</p><a id="more"></a><p>在讲具体的系统调用之前，先要简单了解几个概念</p><p><strong>文件系统</strong></p><p>文件系统可以简单的理解为数据结构+方法</p><p>数据结构：文件系统以一种怎样的结构来组织其存储的数据</p><p>方法:open(),read()等调用如何与数据结构打交道</p><p>一个简单的文件系统一般有这几部分</p><ul><li>inode table记录文件的metadata,主要有文件的权限，用户，创建时间，文件所对应blocks</li><li>data block 存储实际问文件内容</li><li>inode bitmap 记录inode table 分配情况位图用0/1来表示对应项是否分配</li><li>data bitmap 记录data blocks 分配情况</li><li>superblock 记录了整个文件系统的一些信息，比如inode个数，data blocks个数，inode table 起始地址。当文件系统<code>mount()</code> superblock被加载到内存。</li></ul><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>以<code>/foo/bar</code> 为例，假设文件大小为4kb</p><p>首先<code>open(&quot;/foo/bar&quot;,O_RDONLY)</code> 需要找到文件bar对应的inode,具体的做法是按照文件路径遍历，通过目录中存储的文件名-&gt;inode-number来找到文件<code>bar</code>对应的inode。</p><p>将文件对应的inode加载到内存，做权限检查，比如文件读写属性。每个进程中都有一个open-file-table,系统为打开的文件分配文件描述符。</p><p>一旦文件打开之后，read()按照顺序从第一个block开始读取，具体来看需要读取inode来获取区块位置信息，更新inode中last-access-time。更新open-file-table中的file offset。</p><p>打开一个文件所涉及到的IO操作与文件路径长度成正比。每次通过父目录中的data-block来获取inode-number，用来在inode table查找对应的inode，通过inode来查找data-block位置。 因此每多添加一层目录就会有额外的两次IO.</p><p>下面的图直观的说明这一过程</p><p><img src="https://s1.ax1x.com/2020/06/01/tJimWt.png" alt="tJimWt.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要想探究的是我们平时说的IO系统调用与&lt;code&gt;inode&lt;/code&gt;，文件系统等之间的交互，或者说，在做文件IO时候，有那些底层的数据结构参与进来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>最长上升子序列</title>
    <link href="http://yoursite.com/2020/05/27/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/05/27/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-05-26T16:00:48.000Z</published>
    <updated>2020-05-30T11:58:29.789Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><a id="more"></a><h3 id="解法1-动态规划"><a href="#解法1-动态规划" class="headerlink" title="解法1.动态规划"></a>解法1.动态规划</h3><p><strong>时间复杂度O($n^2$)</strong></p><p><strong>思路</strong></p><p><code>f[i]</code>表示以ith字符结尾的最长上升子序列长度</p><p>这道题难在状态转移的求解<br><code>f[i]=max(f[i-1],f[i-2],......)+1</code>  前提条件是 f[j]&lt;f[i] 才能构成上升子序列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            f[i]=<span class="number">1</span>; <span class="comment">//表示只含当前字符的序列长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i]) f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:f) res=<span class="built_in">max</span>(res,c);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="解法2-直接构造最长上升子序列"><a href="#解法2-直接构造最长上升子序列" class="headerlink" title="解法2  直接构造最长上升子序列"></a>解法2  直接构造最长上升子序列</h3><p>时间复杂度 $O(nlogn)$</p><p>开一个辅助数组 <code>f[i]</code> 表示最长上升子序列长度为<code>i+1</code> 中最小结尾值</p><p>eg. [1,2,4] ,[1,2,3]两个子序列长度都为3， 但是第一个子序列结尾值3&lt;4 ，于是 f[2]=3;</p><p>这里面的思路背景是 在dp解法中  f[i]=max(f[j]+1)  nums[j] 越小 那么对nums[i]限制就越小</p><p>两个最长上升子序列长度相同 那么子序列尾部值越小 越有可能构建成更加长的子序列</p><p>由于构造的辅助数组一定单调上升，因此可以通过二分查找来做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size(),len=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> p=lower_bound(f.begin(),f.end(),c)-f.begin(); </span><br><span class="line">            <span class="keyword">if</span>(p==f.size()) f.push_back(c);<span class="comment">//查找元素比辅助数组最大值还要大</span></span><br><span class="line">            <span class="keyword">else</span> f[p]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最好是通过一个 toy example 来给给面试官讲这个思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>排序二叉树转化为双向链表</title>
    <link href="http://yoursite.com/2020/05/24/%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/05/24/%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-24T13:51:08.000Z</published>
    <updated>2020-05-24T13:53:12.405Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>这道题目注意审题，注意双向链表的表头和表尾部是否连接，如果连接就是一个循环双向链表。</p><a id="more"></a><h3 id="循环双向链表-递归"><a href="#循环双向链表-递归" class="headerlink" title="循环双向链表+递归"></a>循环双向链表+递归</h3><p>思路上很直接，在二叉搜索树的中序遍历基础上，改变当前节点<code>root</code>指针指向，因为我们需要将<code>root-&gt;left</code> 指向前一个顺序遍历的节点，我们用一个指针<code>pre</code>表示当前节点的前一个节点。</p><p>解法一<br>递归返回头节点和尾节点，注意递归传递的参数应该是引用类型(<del>不然debug搞死你。。。)</del></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        Node*head=<span class="literal">nullptr</span>,*pre=<span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root,head,pre);</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node*root,Node*&amp;head,Node*&amp;pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left,head,pre);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;root-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            head=root;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;right=root;</span><br><span class="line">            root-&gt;left=pre;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;right,head,pre);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p>大体和上面一样递归，但是递归的时候没有保存头节点,而是在把节点指针顺序改变好之后(实际上这个时候双链表已经建好了）通过链表的反向遍历找到头节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Node*pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">auto</span> head=pre;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;left) head=head-&gt;left;</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        root-&gt;left=pre;</span><br><span class="line">        <span class="keyword">if</span>(pre) pre-&gt;right=root;</span><br><span class="line">        pre=root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="解法3-利用栈非递归中序遍历"><a href="#解法3-利用栈非递归中序遍历" class="headerlink" title="解法3  利用栈非递归中序遍历"></a>解法3  利用栈非递归中序遍历</h3><p>二叉搜索树的中序遍历后结果是一个有序数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; stk;</span><br><span class="line">        Node*pre=<span class="literal">NULL</span>,*head=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(root||stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            root-&gt;left=pre;</span><br><span class="line">            <span class="keyword">if</span>(pre) pre-&gt;right=root;</span><br><span class="line">            pre=root;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        head=pre;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;left) head=head-&gt;left;</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：&lt;br&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p&gt;
&lt;p&gt;这道题目注意审题，注意双向链表的表头和表尾部是否连接，如果连接就是一个循环双向链表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>overload,override,overwrite小结</title>
    <link href="http://yoursite.com/2020/05/23/overload-override-overwrite%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/05/23/overload-override-overwrite%E5%B0%8F%E7%BB%93/</id>
    <published>2020-05-23T15:48:48.000Z</published>
    <updated>2020-05-23T15:56:20.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="overload-override-overwrite小结"><a href="#overload-override-overwrite小结" class="headerlink" title="overload,override,overwrite小结"></a>overload,override,overwrite小结</h3><p>这几个关键字本身没有多大联系，但是因为名字上的关系,造成了一些误解，其次C++里面也没有overwrite这一说法，对应的概念应该为覆盖重写。</p><a id="more"></a><h4 id="overload"><a href="#overload" class="headerlink" title="overload"></a>overload</h4><p><strong>同一个作用域中</strong>，定义了多个函数名完全相同、参数（类型或者个数）不相同的函数</p><p>如何解决命名冲突？<br>根据“作用域+返回类型+函数名+参数列表” 做name tangling。作用域指的是在一个类中定义了不同的重载函数，类本身就标识了一个作用域。</p><p>不同的编译器有不同的名字修饰规则，因此很少有链接器能够处理所有编译器产生的目标代码。</p><p>名字修饰还有一个很常见的点，在C++代码里面经常看到下面代码，这是为了保证条件编译的代码段按照C语言处理，即不做名字修饰。</p><p>如果不加<code>extern C</code>,对下面的一些C库函数做了名字修饰，那么在C runtime libaray将导致链接错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span> <span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span> <span class="params">(<span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">strcmp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span> <span class="params">(<span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>什么函数不能够被重载?</p><ol><li>仅仅返回类型不同，不能够做函数重载</li><li>成员函数名称以及参数完全相同，仅仅其中一个是static成员函数。</li><li>函数参数差别仅在于有无顶层const或volatile</li></ol><p>注意，用<strong>const 修饰的成员函数是重载</strong>， 因为const 用来修饰成员函数中隐含的this 指针</p><p>这里就引入什么是top-level const/volatile</p><blockquote><p>A top-level const qualifier affects the object itself. Others are only relevant with pointers and references. </p></blockquote><p><code>char const x = &#39;t&#39;;</code>就是顶层常量 </p><p>override 可能存在二义性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转型造成二义性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">float</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>)</span></span>;  </span><br><span class="line">function(<span class="number">3.4</span>);<span class="comment">// 转型 C++中浮点数为double </span></span><br><span class="line">function(<span class="number">34</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//默认形参带来的二义性v</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of x is : "</span> &lt;&lt;x&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> z=<span class="number">12</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of y is : "</span> &lt;&lt;y&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of z is : "</span> &lt;&lt;z&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-override"><a href="#2-override" class="headerlink" title="2.override"></a>2.override</h4><p>子类重新改写父类声明为virtual的函数<br>有几个特点：</p><ul><li><p>范围不同(作用域不同)</p></li><li><p>函数签名完全一样(名字，常数列表)</p></li><li><p>基类函数必须带有virtual 关键字</p><p>  C++11 中的 <code>override</code>关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译阶段会报错</p></li></ul><h4 id="3-overwrite"><a href="#3-overwrite" class="headerlink" title="3.overwrite"></a>3.overwrite</h4><p>派生类的函数隐藏了与其同名的基类函数 ，两种情况</p><ul><li>派生类函数参数与基类不同，不管基类有无virtual</li><li>派生类函数参数与基类相同，但是基类没有virtual</li></ul><p>overwrite 是要被避免的，其行为不是我们预期的，C++11 引入override 关键字就是起这个作用的</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://stackoverflow.com/questions/13880205/is-the-override-keyword-just-a-check-for-a-overridden-virtual-method" target="_blank" rel="noopener">override keyword’s function</a></p><p><a href="https://en.wikipedia.org/wiki/Name_mangling" target="_blank" rel="noopener">名字修饰</a></p><p><a href="https://stackoverflow.com/questions/3789340/combining-c-and-c-how-does-ifdef-cplusplus-work" target="_blank" rel="noopener">extern c/c++</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;overload-override-overwrite小结&quot;&gt;&lt;a href=&quot;#overload-override-overwrite小结&quot; class=&quot;headerlink&quot; title=&quot;overload,override,overwrite小结&quot;&gt;&lt;/a&gt;overload,override,overwrite小结&lt;/h3&gt;&lt;p&gt;这几个关键字本身没有多大联系，但是因为名字上的关系,造成了一些误解，其次C++里面也没有overwrite这一说法，对应的概念应该为覆盖重写。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
