<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年5月19日</title>
    <url>/2020/05/19/2020%E5%B9%B45%E6%9C%8819%E6%97%A5/</url>
    <content><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><p>hi 我是XXX</p>
]]></content>
  </entry>
  <entry>
    <title>最长上升子序列</title>
    <url>/2020/05/27/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<a id="more"></a>

<h3 id="解法1-动态规划"><a href="#解法1-动态规划" class="headerlink" title="解法1.动态规划"></a>解法1.动态规划</h3><p><strong>时间复杂度O($n^2$)</strong></p>
<p><strong>思路</strong></p>
<p><code>f[i]</code>表示以ith字符结尾的最长上升子序列长度</p>
<p>这道题难在状态转移的求解<br><code>f[i]=max(f[i-1],f[i-2],......)+1</code>  前提条件是 f[j]&lt;f[i] 才能构成上升子序列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            f[i]=<span class="number">1</span>; <span class="comment">//表示只含当前字符的序列长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i]) f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:f) res=<span class="built_in">max</span>(res,c);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2-直接构造最长上升子序列"><a href="#解法2-直接构造最长上升子序列" class="headerlink" title="解法2  直接构造最长上升子序列"></a>解法2  直接构造最长上升子序列</h3><p>时间复杂度 $O(nlogn)$</p>
<p>开一个辅助数组 <code>f[i]</code> 表示最长上升子序列长度为<code>i+1</code> 中最小结尾值</p>
<p>eg. [1,2,4] ,[1,2,3]两个子序列长度都为3， 但是第一个子序列结尾值3&lt;4 ，于是 f[2]=3;</p>
<p>这里面的思路背景是 在dp解法中  f[i]=max(f[j]+1)  nums[j] 越小 那么对nums[i]限制就越小</p>
<p>两个最长上升子序列长度相同 那么子序列尾部值越小 越有可能构建成更加长的子序列</p>
<p>由于构造的辅助数组一定单调上升，因此可以通过二分查找来做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size(),len=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> p=lower_bound(f.begin(),f.end(),c)-f.begin(); </span><br><span class="line">            <span class="keyword">if</span>(p==f.size()) f.push_back(c);<span class="comment">//查找元素比辅助数组最大值还要大</span></span><br><span class="line">            <span class="keyword">else</span> f[p]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最好是通过一个 toy example 来给给面试官讲这个思路。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>stringstream 处理字符串</title>
    <url>/2020/05/20/stringstream-%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>在刷leetcode 过程中，C++一直没有比较好的方法来分割字符串，尤其对于带有很明显的分隔符比如<code>.,\</code>,等</p>
<p>我一般的做法都是用两个下标来标识一段子字符串，然后<code>substr()</code>来做进一步处理。</p>
<p>最近学习了用<code>stringstream</code>来处理字符串，类似<code>iosteam,fsteam</code>,使得操作<code>string</code>就像操作输入流一样。</p>
<a id="more"></a>

<h4 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></h4><p><strong>思路</strong></p>
<p>对于文件路径有很明显的分隔符<code>/</code>，类似的对于IP地址分隔符<code>.</code></p>
<ul>
<li>用输入字符串来初始化<code>stringstream</code>对象</li>
<li>while循环提取子字符串，根据情况判断</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">is</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> res,temp;</span><br><span class="line">        <span class="keyword">while</span>(getline(is,temp,<span class="string">'/'</span>))&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;"temp:    "&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">""</span>||temp==<span class="string">"."</span>) <span class="comment">// 处理// /./情况</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="string">".."</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.size())st.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span> st.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:st)&#123;</span><br><span class="line">            res+=<span class="string">"/"</span>+str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.empty()) <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>下面的snippet code 用来处理类似<code>&quot;dog cat mouse ...&quot;</code>字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">raw</span><span class="params">(str)</span></span>;</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">     <span class="built_in">string</span> line;</span><br><span class="line">     <span class="keyword">while</span> (raw &gt;&gt; line) strs.push_back(line);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用open(),read(),write()具体发了什么?</title>
    <url>/2020/06/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8open-read-write-%E5%85%B7%E4%BD%93%E5%8F%91%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>本文主要想探究的是我们平时说的IO系统调用与<code>inode</code>，文件系统等之间的交互，或者说，在做文件IO时候，有那些底层的数据结构参与进来。</p>
<a id="more"></a>



<p>在讲具体的系统调用之前，先要简单了解几个概念</p>
<p><strong>文件系统</strong></p>
<p>文件系统可以简单的理解为数据结构+方法</p>
<p>数据结构：文件系统以一种怎样的结构来组织其存储的数据</p>
<p>方法:open(),read()等调用如何与数据结构打交道</p>
<p>一个简单的文件系统一般有这几部分</p>
<ul>
<li>inode table记录文件的metadata,主要有文件的权限，用户，创建时间，文件所对应blocks</li>
<li>data block 存储实际问文件内容</li>
<li>inode bitmap 记录inode table 分配情况位图用0/1来表示对应项是否分配</li>
<li>data bitmap 记录data blocks 分配情况</li>
<li>superblock 记录了整个文件系统的一些信息，比如inode个数，data blocks个数，inode table 起始地址。当文件系统<code>mount()</code> superblock被加载到内存。</li>
</ul>
<h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>以<code>/foo/bar</code> 为例，假设文件大小为4kb</p>
<p>首先<code>open(&quot;/foo/bar&quot;,O_RDONLY)</code> 需要找到文件bar对应的inode,具体的做法是按照文件路径遍历，通过目录中存储的文件名-&gt;inode-number来找到文件<code>bar</code>对应的inode。</p>
<p>将文件对应的inode加载到内存，做权限检查，比如文件读写属性。每个进程中都有一个open-file-table,系统为打开的文件分配文件描述符。</p>
<p>一旦文件打开之后，read()按照顺序从第一个block开始读取，具体来看需要读取inode来获取区块位置信息，更新inode中last-access-time。更新open-file-table中的file offset。</p>
<p>打开一个文件所涉及到的IO操作与文件路径长度成正比。每次通过父目录中的data-block来获取inode-number，用来在inode table查找对应的inode，通过inode来查找data-block位置。 因此每多添加一层目录就会有额外的两次IO.</p>
<p>下面的图直观的说明这一过程</p>
<p><img src="https://s1.ax1x.com/2020/06/01/tJimWt.png" alt="tJimWt.png"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>谁想看清尘世就应当同它保持必要的距离</title>
    <url>/2020/05/20/%E8%B0%81%E6%83%B3%E7%9C%8B%E6%B8%85%E5%B0%98%E4%B8%96%E5%B0%B1%E5%BA%94%E5%BD%93%E5%90%8C%E5%AE%83%E4%BF%9D%E6%8C%81%E5%BF%85%E8%A6%81%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p>《树上的男爵》是一本小册子，200来页，很快就能读完。</p>
<p>书中探讨了关于自我和集体，自我和爱情，以及为了追求一个完整的自我，所作的取舍。要有不少句子都充满哲理，引人深思。</p>
<blockquote>
<p>他懂得这个道理：集体会使人更强大，能突出每个人的长处，使人得到替自己办事时极难以获得的那种快乐，会为看到那么多正直、勇敢而能干的人而喜悦，为了他们值得去争取美好的东西（而在为自己而生活时，经常出现的是相反的情形，看到的是人们的另一副面孔，使你必须永远用手握住剑柄）。 这个火灾的夏季因此而成为一个不错的季节：在大家的心中有一个需要解决的共同问题，每个人都把它放在其他个人利益之前，而且从其他许多优秀人物的赞同和敬佩中得到了满足与报偿。 后来，柯希莫不得不明白，当那个共同的问题不存在之后，集体就不再像从前那么好了，做一个孤独的人更好一些，而不要当首领。</p>
</blockquote>
<blockquote>
<p>真事使人回忆起许多属于过去的时光、细腻的感情、烦扰、幸福、疑惑、光荣和对自己的厌恶，而故事中砍掉了主要的东西，一切显得轻而易举。但变来变去，最后发觉自己在回头去讲自己经历过的真实生活中体验过或发生过的事情。</p>
</blockquote>
<blockquote>
<p>如果不感到自身充满力量，就不可能有爱情。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title>排序二叉树转化为双向链表</title>
    <url>/2020/05/24/%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>问题描述：<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>这道题目注意审题，注意双向链表的表头和表尾部是否连接，如果连接就是一个循环双向链表。</p>
<a id="more"></a>

<h3 id="循环双向链表-递归"><a href="#循环双向链表-递归" class="headerlink" title="循环双向链表+递归"></a>循环双向链表+递归</h3><p>思路上很直接，在二叉搜索树的中序遍历基础上，改变当前节点<code>root</code>指针指向，因为我们需要将<code>root-&gt;left</code> 指向前一个顺序遍历的节点，我们用一个指针<code>pre</code>表示当前节点的前一个节点。</p>
<p>解法一<br>递归返回头节点和尾节点，注意递归传递的参数应该是引用类型(<del>不然debug搞死你。。。)</del></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        Node*head=<span class="literal">nullptr</span>,*pre=<span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root,head,pre);</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node*root,Node*&amp;head,Node*&amp;pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left,head,pre);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;root-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            head=root;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;right=root;</span><br><span class="line">            root-&gt;left=pre;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;right,head,pre);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p>大体和上面一样递归，但是递归的时候没有保存头节点,而是在把节点指针顺序改变好之后(实际上这个时候双链表已经建好了）通过链表的反向遍历找到头节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node*pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">auto</span> head=pre;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;left) head=head-&gt;left;</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        root-&gt;left=pre;</span><br><span class="line">        <span class="keyword">if</span>(pre) pre-&gt;right=root;</span><br><span class="line">        pre=root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法3-利用栈非递归中序遍历"><a href="#解法3-利用栈非递归中序遍历" class="headerlink" title="解法3  利用栈非递归中序遍历"></a>解法3  利用栈非递归中序遍历</h3><p>二叉搜索树的中序遍历后结果是一个有序数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; stk;</span><br><span class="line">        Node*pre=<span class="literal">NULL</span>,*head=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(root||stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            root-&gt;left=pre;</span><br><span class="line">            <span class="keyword">if</span>(pre) pre-&gt;right=root;</span><br><span class="line">            pre=root;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        head=pre;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;left) head=head-&gt;left;</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>overload,override,overwrite小结</title>
    <url>/2020/05/23/overload-override-overwrite%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h3 id="overload-override-overwrite小结"><a href="#overload-override-overwrite小结" class="headerlink" title="overload,override,overwrite小结"></a>overload,override,overwrite小结</h3><p>这几个关键字本身没有多大联系，但是因为名字上的关系,造成了一些误解，其次C++里面也没有overwrite这一说法，对应的概念应该为覆盖重写。</p>
<a id="more"></a>

<h4 id="overload"><a href="#overload" class="headerlink" title="overload"></a>overload</h4><p><strong>同一个作用域中</strong>，定义了多个函数名完全相同、参数（类型或者个数）不相同的函数</p>
<p>如何解决命名冲突？<br>根据“作用域+返回类型+函数名+参数列表” 做name tangling。作用域指的是在一个类中定义了不同的重载函数，类本身就标识了一个作用域。</p>
<p>不同的编译器有不同的名字修饰规则，因此很少有链接器能够处理所有编译器产生的目标代码。</p>
<p>名字修饰还有一个很常见的点，在C++代码里面经常看到下面代码，这是为了保证条件编译的代码段按照C语言处理，即不做名字修饰。</p>
<p>如果不加<code>extern C</code>,对下面的一些C库函数做了名字修饰，那么在C runtime libaray将导致链接错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span> <span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span> <span class="params">(<span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">strcmp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span> <span class="params">(<span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>





<p>什么函数不能够被重载?</p>
<ol>
<li>仅仅返回类型不同，不能够做函数重载</li>
<li>成员函数名称以及参数完全相同，仅仅其中一个是static成员函数。</li>
<li>函数参数差别仅在于有无顶层const或volatile</li>
</ol>
<p>注意，用<strong>const 修饰的成员函数是重载</strong>， 因为const 用来修饰成员函数中隐含的this 指针</p>
<p>这里就引入什么是top-level const/volatile</p>
<blockquote>
<p>A top-level const qualifier affects the object itself. Others are only relevant with pointers and references. </p>
</blockquote>
<p><code>char const x = &#39;t&#39;;</code>就是顶层常量 </p>
<p>override 可能存在二义性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转型造成二义性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">float</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>)</span></span>;  </span><br><span class="line">function(<span class="number">3.4</span>);<span class="comment">// 转型 C++中浮点数为double </span></span><br><span class="line">function(<span class="number">34</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//默认形参带来的二义性v</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of x is : "</span> &lt;&lt;x&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> z=<span class="number">12</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of y is : "</span> &lt;&lt;y&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of z is : "</span> &lt;&lt;z&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-override"><a href="#2-override" class="headerlink" title="2.override"></a>2.override</h4><p>子类重新改写父类声明为virtual的函数<br>有几个特点：</p>
<ul>
<li><p>范围不同(作用域不同)</p>
</li>
<li><p>函数签名完全一样(名字，常数列表)</p>
</li>
<li><p>基类函数必须带有virtual 关键字</p>
<p>  C++11 中的 <code>override</code>关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译阶段会报错</p>
</li>
</ul>
<h4 id="3-overwrite"><a href="#3-overwrite" class="headerlink" title="3.overwrite"></a>3.overwrite</h4><p>派生类的函数隐藏了与其同名的基类函数 ，两种情况</p>
<ul>
<li>派生类函数参数与基类不同，不管基类有无virtual</li>
<li>派生类函数参数与基类相同，但是基类没有virtual</li>
</ul>
<p>overwrite 是要被避免的，其行为不是我们预期的，C++11 引入override 关键字就是起这个作用的</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://stackoverflow.com/questions/13880205/is-the-override-keyword-just-a-check-for-a-overridden-virtual-method" target="_blank" rel="noopener">override keyword’s function</a></p>
<p><a href="https://en.wikipedia.org/wiki/Name_mangling" target="_blank" rel="noopener">名字修饰</a></p>
<p><a href="https://stackoverflow.com/questions/3789340/combining-c-and-c-how-does-ifdef-cplusplus-work" target="_blank" rel="noopener">extern c/c++</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>IO复用</title>
    <url>/2020/05/19/IO%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<p>以往服务器等待客户端连接需要阻塞accept(),等待客户端发数据需要阻塞，如果同时有多个客户端发起请求，那么就gg,<br>当然可以通过多线程，多进程来解决，但是开销太大。于是就有了IO多路转接，</p>
<a id="more"></a>
<p>其核心思想时服务器通过内核作为媒介来监听客户端的连接请求，内核阻塞去监听客户端状态，一旦其状态变化，内核就通知<br>服务器去处理</p>
<h3 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><p><code>int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@parm1 :nfds 表示所监听的文件描述符最大值+1</span></span><br><span class="line"><span class="comment">// @parm2,3,4 所监听文件描述符事件(可读/可写/异常)</span></span><br><span class="line"><span class="comment">//@parm5:设置超时限制</span></span><br><span class="line"><span class="comment">//返回值&gt;0：监听的所有集合，总满足条件的总数;==0 超时；&lt;0 错误</span></span><br></pre></td></tr></table></figure>
<h4 id="配套操作"><a href="#配套操作" class="headerlink" title="配套操作"></a>配套操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//判断fd是否在集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//将集合对应位置为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//将集合清0</span></span><br></pre></td></tr></table></figure>
<h4 id="再看文件描述集"><a href="#再看文件描述集" class="headerlink" title="再看文件描述集"></a>再看文件描述集</h4><p>三个文件描述符参数是传入传出参数</p>
<p>举个例子，readfds 监听了{fd1,fd2,fd3,fd4} 对应位图[1111]<br>select返回2，表明有两个文件描述符准备好了,这个时候监听集合可能就变成了[1001] ，因此我们需要轮循才能知道是哪个文件描述符状态发生了改变。</p>
<h4 id="select-详细过程："><a href="#select-详细过程：" class="headerlink" title="select 详细过程："></a>select 详细过程：</h4><ol>
<li><p>当用户 process 调用 select 的时候，select 会将需要监控的 readfds 集合拷贝到内核空间（假设监控的仅仅是 socket 可读），</p>
</li>
<li><p>内核遍历自己监控的 socket sk，挨个调用 sk 的 poll 逻辑以便检查该 sk 是否有可读事件，遍历完所有的 sk 后，如果没有任何一个 sk 可读，那 select 会调用 schedule_timeout 进入 schedule 循环，使得 process 进入睡眠。如果在 timeout 时间内某个 sk 上有数据可读了，或者等待 timeout 了，则调用 select 的 process 会被唤醒，</p>
</li>
<li><p>接下来 select 就是遍历监控的 sk 集合，挨个收集可读事件并返回给用户。</p>
</li>
</ol>
<h4 id="select-缺点"><a href="#select-缺点" class="headerlink" title="select()缺点"></a>select()缺点</h4><ol>
<li>监听的文件描述符上限1024</li>
<li>需要轮循才能知道是哪个文件描述符状态发生了改变，当客户端连接数过多，但是准备就绪的又比较少时，轮循代价比较大</li>
<li>由于监听集合是传入传出参数，因此在调用<code>select()</code>之前需要先保存之前状态</li>
<li>fds集合需要从用户空间拷贝到内核空间的问题，我们希望不需要拷贝</li>
</ol>
<h4 id="select处理完整代码"><a href="#select处理完整代码" class="headerlink" title="select处理完整代码"></a>select处理完整代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> listenfd = createSocket(); <span class="comment">//这里封装了，可以简单理解为将socket(),bind(),listen() 都封装了</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 保存所有的文件描述符</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; fdset;</span><br><span class="line">    fdset.insert(listenfd);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;rfds);</span><br><span class="line">        <span class="comment">// 每次都要重新设置rfds.因为select返回时，rfds被内核改变，里面只保存了就绪的文件描述符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fd : fdset) FD_SET(fd, &amp;rfds);</span><br><span class="line">        <span class="keyword">int</span> ret = select(*fdset.rbegin()+<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> fd : fdset) <span class="comment">//这里就是轮询监听的文件描述符集合，因为使用了集合，就不需要从0-fds.size()+1遍历呢</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 有新的连接</span></span><br><span class="line">                <span class="keyword">if</span> (fd == listenfd &amp;&amp; FD_ISSET(fd, &amp;rfds))</span><br><span class="line">                &#123;</span><br><span class="line"> </span><br><span class="line">                   <span class="keyword">int</span> cfd = accept();</span><br><span class="line">                    <span class="comment">// 添加到 fd_set 结构体，并记录到 set</span></span><br><span class="line">                    FD_SET(cfd, &amp;rfds);</span><br><span class="line">                    fdset.insert(cfd); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//有请求 读数据</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(fd, &amp;rfds))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> lenrecv = <span class="number">-1</span>;</span><br><span class="line">                    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFSIZE);</span><br><span class="line"> </span><br><span class="line">                    lenrecv = recv(fd, buf, BUFSIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (lenrecv &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == lenrecv)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 客户端退出，删除文件描述符，并关闭</span></span><br><span class="line">                        fdset.erase(fd);</span><br><span class="line">                        FD_CLR(fd, &amp;rfds);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"delete connection fd: %d\n"</span>, fd);</span><br><span class="line">                        <span class="built_in">close</span>(fd);</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><code>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</code></p>
<p>poll机制和select类似，通过轮询管理的文件描述符，根据其状态来进行处理。</p>
<ol>
<li>但是poll()没有最大文件描述符数量上限。</li>
<li>fds描述方式和select()不同，使用pollfd()基于链表实现，而fd_set()基于数组<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">   short events;     <span class="comment">/* requested events */</span></span><br><span class="line">   short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="poll与select对比"><a href="#poll与select对比" class="headerlink" title="poll与select对比"></a>poll与select对比</h3><h4 id="功能实现上"><a href="#功能实现上" class="headerlink" title="功能实现上"></a>功能实现上</h4><ul>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>select 会修改描述符，而 poll 不会(请求事件和返回事件分开)</li>
<li>poll 提供了更多的事件类型(POLLIN,POLLOUT,POLLERR,POLLHUP)</li>
</ul>
<h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
<h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>使用场景：连接文件描述符多，但是监听的少，或者说处于就绪态的文件描述符少，使用epoll</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>; <span class="comment">//返回指向内核的红黑树根</span></span><br><span class="line"></span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event*event)；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次(处理红黑树节点时候)，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<blockquote>
<p>为什么不在需要轮循获得准备就绪的fd?<br>因为epoll_wait() 返回的<br><code>struct epoll_event * events</code> 已经包含了就绪的文件描述符,并且该结构体含有fd,以及事件信息<br>常见的处理方式</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">activeEvs</span>[100];</span></span><br><span class="line"><span class="keyword">int</span> n = epoll_wait(efd, activeEvs, kMaxEvents, waitms);<span class="comment">//返回准备就绪的文件描述符个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = activeEvs[i].data.fd; <span class="comment">//提取fd</span></span><br><span class="line">        <span class="keyword">int</span> events = activeEvs[i].events; <span class="comment">//提取返回事件</span></span><br><span class="line">        <span class="keyword">if</span> (events &amp; (EPOLLIN | EPOLLERR)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd == lfd) &#123;</span><br><span class="line">                handleAccept(efd, fd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleRead(efd, fd);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LT-amp-amp-ET"><a href="#LT-amp-amp-ET" class="headerlink" title="LT&amp;&amp;ET"></a>LT&amp;&amp;ET</h4><p>Level Triggered (LT) 水平触发</p>
<p>socket接收缓冲区不为空 有数据可读 读事件一直触发</p>
<p>Edge Triggered (ET) 边沿触发</p>
<p>socket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件</p>
<p>其实就是模拟电路中的上升沿以及水平概念，LT只要有数据就会读，ET只有当缓冲区状态发生改变才会触发。</p>
<p>ET很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h3 id="三种IO复用应用场景"><a href="#三种IO复用应用场景" class="headerlink" title="三种IO复用应用场景"></a>三种IO复用应用场景</h3><h4 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h4><ol>
<li>实时性要求高;select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制</li>
<li>可移植性好</li>
</ol>
<h4 id="poll-1"><a href="#poll-1" class="headerlink" title="poll"></a>poll</h4><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h4 id="epoll-1"><a href="#epoll-1" class="headerlink" title="epoll"></a>epoll</h4><p>适用于：</p>
<ul>
<li>只运行在linux</li>
<li>大量的连接，但是只有少数同时处于就绪态，并且这些连接为长连接</li>
</ul>
<p>不适用：</p>
<ul>
<li>监控的描述符状态变化多，而且都是非常短暂的，因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shared_from_this解决了什么问题</title>
    <url>/2020/06/02/shared-from-this%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<a id="more"></a>

<p>enable_shared_from_this 含义<br>如果一个T类型的对象t,是被std::shared_ptr管理的，且类型T继承自<code>std::enable_shared_from_this</code>，那么T就有个<code>shared_from_this</code>成员函数，这个函数返回一个新的<code>std::shared_ptr</code>的对象，也指向对象t</p>
<p>如果不这么做, 会出现什么问题，看下面一段代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obj</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">get_shr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">ret</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">smart_ptr</span><span class="params">(<span class="keyword">new</span> obj)</span></span>;</span><br><span class="line">    obj&amp; a=*smart_ptr;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;obj&gt; b=a.get_shr(); <span class="comment">//两个智能指针管理的是同一个对象，造成对象两次释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述场景是 对象希望获得管理自己的智能指针，但是直接通过成员函数返回一个<code>shared_ptr</code>,造成了被管理对象的重复删除。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>数据流算法题目小结</title>
    <url>/2020/06/09/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>由于数据是动态的，按照一般的做法，比如遍历，当新数据的加入，处理单个操作的时间复杂度为<code>O(n)</code>,这样往往造成TLE</p>
<p>通过使用合理的数据结构来存储，比如堆，能够将时间复杂度降低到 <code>logn</code></p>
<a id="more"></a>

<h4 id="703-数据流中的第K大元素"><a href="#703-数据流中的第K大元素" class="headerlink" title="703. 数据流中的第K大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">703. 数据流中的第K大元素</a></h4><p>这个本质的思想就是通过小根堆来求第K大元素，通过限制堆大小为k,以及判断堆顶元素与新加入元素val大小关系，将时间复杂度降低到logn.</p>
<p>有一点需要注意的就是做<code>pop()</code> 一定要检查堆是否为空。</p>
<h4 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></h4><p>通过使用两个堆，一个小根堆存放序列中较大的一部分元素，大根堆存放较小的一部分元素，可以形象的把这个结构想象成一个沙漏</p>
<p>通过堆顶元素就能够很方便的得到数据流的中位数。</p>
<p>当新元素val加入如何维护堆?</p>
<ol>
<li>val 先添加到大根堆maxq,  如果maxq.top&gt;minq.top 需要交换两个堆定元素</li>
<li>始终保持maxq.size()&lt;=minq.size()+1 这样才能通过堆顶来求中位数</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>文件系统的持久化</title>
    <url>/2020/06/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>《OSTEP》文件持久化部分阅读笔记</p>
<a id="more"></a>

<h3 id="什么是crash-consistency-problem"><a href="#什么是crash-consistency-problem" class="headerlink" title="什么是crash-consistency problem?"></a>什么是crash-consistency problem?</h3><p>在两次write()之间，系统可能出现异常的断电，崩溃等情况，导致磁盘文件被部分更新。</p>
<p>在系统重启时，文件系统被再次装载，如何解决之前异常崩溃带来的on-disk image inconsistent state 是接下来要讨论的重点</p>
<p>具体来看下磁盘出现不一致的情况</p>
<p>当我们append new data block 到一个文件，至少需要更新3个数据结构:``inode,data block,data bitmap`在更新这三个数据结构的过程中，系统都可能崩溃，在不同的阶段崩溃造成的后果不一样。</p>
<p><img src="https://s1.ax1x.com/2020/06/11/tHFAQx.png" alt="tHFAQx.png"></p>
<p>假设只有一次更新成功</p>
<ul>
<li>data block is updated  不会造成一致性问题，因为没有inode指向更新的data block</li>
<li>inode  造成一致性问题，与bitmap 冲突，同时由于data block没有更新，会读取脏数据。</li>
<li>data bitmap 同上带来一致性问题，同时带来空间泄漏，因为bitmap更新之后，指向的空间不会被系统分配</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-file-system-checker"><a href="#1-file-system-checker" class="headerlink" title="1.file system checker"></a>1.file system checker</h4><p>基本思路是让不一致发生，然后修复它。</p>
<p>但是存在一些问题比如,即使inode 与data bitmap 一致，仍然可能存在读取脏数据<br>其次这种做法最大的问题就是速度太慢！ 需要扫描整个磁盘来检查所有相关的数据结构。</p>
<ol start="2">
<li><h4 id="日志-write-ahead-logging"><a href="#日志-write-ahead-logging" class="headerlink" title="日志(write-ahead logging)"></a>日志(write-ahead logging)</h4></li>
</ol>
<p>在更新磁盘之前，先将当前操作(trananactions) 记录下来，当系统崩溃时候，能够replay。这样做的好处就是能够精准定位崩溃问题，不需要扫描整个磁盘。</p>
<p>具体如何实现</p>
<h5 id="data-log"><a href="#data-log" class="headerlink" title="data log"></a>data log</h5><ol>
<li>Journal write: Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.</li>
<li>Checkpoint: Write the pending metadata and data updates to their final locations in the file system.</li>
</ol>
<p>问题<br>在写日志的时候可能崩溃</p>
<p>改进<br>将写日志操作拆分为两步</p>
<ul>
<li>写日志开始标志+data+inode+bitmap</li>
<li>写日志结束标志</li>
</ul>
<p>这样做的好处在于磁盘能够保证对单个区块(512byte)的原子操作，进而保证对单条日志记录要么成功要么失败。</p>
<p>日志的空间大小有限，一旦日志空间满，之后的transactions 将不能被记录。<br>具体解决方法通过循环日志(类似循环队列) 一旦一个transaction 被check了，系统就释放对应的日志空间</p>
<p>经过上述几个改进，我们现在的做法如下</p>
<ol>
<li><p>Journal write: Write the contents of the transaction (containing TxBand the contents of the update) to the log; wait for these writes to<br> complete.</p>
</li>
<li><p>Journal commit: Write the transaction commit block (containingTxE) to the log; wait for the write to complete; the transaction is now committed.</p>
</li>
<li><p>Checkpoint: Write the contents of the update to their final locations within the file system.</p>
</li>
<li><p>Free: Some time later, mark the transaction free in the journal by updating the journal superblock.</p>
</li>
</ol>
<p>上述解决方案还能进一步优化: 我们将data block 两次写到了磁盘</p>
<h5 id="metadata-log"><a href="#metadata-log" class="headerlink" title="metadata log"></a>metadata log</h5><p>基本操作与之前一样，只是没有将data 写到日志中。</p>
<ol>
<li>Data write: Write data to final location; wait for completion(the wait is optional; see below for details).</li>
<li>Journal metadata write: Write the begin block and metadata to thelog; wait for writes to complete.</li>
<li>Journal commit: Write the transaction commit block (containingTxE) to the log; wait for the write to complete; the transaction (including data) is now committed.</li>
<li>Checkpoint metadata: Write the contents of the metadata updateto their final locations within the file system.</li>
<li>Free: Later, mark the transaction free in journal superblock.</li>
</ol>
<p>先写data 是为了避免脏读，如果先写meta，然后系统崩溃，就会导致读取旧的数据。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口小结</title>
    <url>/2020/06/11/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>滑动窗口可以用来优化一些暴力求解问题，将时间复杂度降低到线性。</p>
<a id="more"></a>

<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h4><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<p>思路</p>
<ul>
<li>先扫描一遍T，把对应的字符及其出现的次数存到 HashMap 中。</li>
<li>然后开始遍历S，就把遍历到的字母对应的 HashMap 中的 value 减一，如果减1后仍大于等于0，cnt 自增1。</li>
<li>如果 cnt 等于T串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是T串中不可缺少的字母(hash表中对应value&gt;0)，那么 cnt 自减1，表示此时T串并没有完全匹配。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t) <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">int</span> len=t.size();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,cnt=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--<span class="built_in">map</span>[s[i]]&gt;=<span class="number">0</span>) cnt++;</span><br><span class="line">            <span class="keyword">while</span>(cnt==len)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.empty()||res.size()&gt;i-j+<span class="number">1</span>) res=s.substr(j,i-j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(++<span class="built_in">map</span>[s[j++]]&gt;<span class="number">0</span>) cnt--;<span class="comment">//移动左边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>进一步理解</strong><br>本来我们是可以开两个哈希表，这里为了节省空间，将其合并，遍历S字符串的时候，哈希表中字符出现的次数可以理解还缺多少个，就可以满足和T字符串匹配。这样一来就能很好理解在移动左边界的判断条件<code>++hash[s[j++]]&gt;0</code> 表示左边界指针移动之后，缺的个数大于0.</p>
<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p><strong>滑动窗口</strong>  思路非常类似上一题76.最小覆盖子串</p>
<p>这个题目的滑动窗口大小固定，因此需要先调整大小，然后添加满足条件的答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> c:p) <span class="built_in">map</span>[c]++;</span><br><span class="line">       <span class="keyword">int</span> total=p.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,cnt=<span class="number">0</span>;j&lt;s.size();j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(--<span class="built_in">map</span>[s[j]]&gt;=<span class="number">0</span>) cnt++; <span class="comment">//移动右指针</span></span><br><span class="line">           <span class="comment">//移动左指针 维护窗口大小为p.size</span></span><br><span class="line">           <span class="keyword">while</span>(j-i+<span class="number">1</span>&gt;total)&#123;</span><br><span class="line">               <span class="keyword">if</span>(++<span class="built_in">map</span>[s[i++]]&gt;<span class="number">0</span>) cnt--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(cnt==total) res.push_back(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
</search>
