<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年度总结</title>
    <url>/2021/01/06/2020-nian-du-zong-jie/</url>
    <content><![CDATA[<h3 id="2020年度总结"><a href="#2020年度总结" class="headerlink" title="2020年度总结"></a>2020年度总结</h3><p>这是我的一次年度小结，从工作，读书等几个角度做了一下年终盘点。</p>
<a id="more"></a>

<h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>校招最终确定了去腾讯，暑假实习转正。 我们组本来有五个实习生，最终去参加转正的只有两人，其他人要么提前走了，要么放弃转正。这么来看我们实习的组并不热门，实际情况也是这样，做云计算基础服务，需要oncall,，经常需要干脏活累活。</p>
<p>但是对于我而言最终决定去腾讯有几点</p>
<ol>
<li>mentor-校长太牛逼.技术好，表达能力强，这也是我所追求的。</li>
<li>腾讯给开出的package十分诱人。话说组长给了我一个ssp这的确是没想到的，当时已经接了网易游戏的两方，本来都在想这以后搞游戏了，最后鹅给了惊喜。我不知道他们是怎么考虑的，实习期间基本就是看代码，输出文档，没有参与到什么实际线上业务。 以后有机会可以去问问校长。</li>
<li>对于行业前景，我其实没有特别的考虑，主要是我对游戏的确没多大兴趣，腾讯这边搞得虽然底层，但是还算熟悉。</li>
</ol>
<h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>今年看了不少书，主要集中12月份在微信读书上看的，说来也奇怪，疫情期间在家里并没有怎么看书，那时候整个人都很焦虑。</p>
<p><strong>《余英时回忆录》</strong> 疫情期间在家看的，没有合适的电子资源，最后看的竖版繁体，当时还找了各种工具倒腾，琢磨怎么把竖版转化为横版，最后放弃了，直接开干。因为看的很慢，所以印象很深刻。</p>
<p><strong>《带一本书去巴黎》，《历史在你我身边》</strong> 林达的散文系列，在大的时代背景下写个人的命运变迁，希特勒的秘书，文革时期的拳王这几个故事对我的触动很大。我对甘地的了解又多了一点，以前一句“圣雄甘地”概括了太多，通过《历史》这本书对甘地和子女，以及“非暴力抵抗”所造成的不好一面有了新的了解。</p>
<p><strong>《蝇王》</strong> 听一起播客提到的，感触不是很大，小孩子在没有规则约束下所展现的恶。</p>
<p><strong>《把自己作为方法》</strong>人类学家项飙的一本访谈录</p>
<blockquote>
<p>Because their identity was defined by competing so intensely with other people, they could not imagine leaving… On the outside, everybody wanted to get in. On the inside, everybody wanted to get out.”</p>
</blockquote>
<p> 彼特-泰勒在<a href="https://www.perell.com/blog/peter-thiel" target="_blank" rel="noopener">模仿竞争</a>中提到的类似表述，“内卷是一场没有退路的竞争”  </p>
<p><strong>《牧羊少年奇幻之旅》</strong> –一本关于follow your heart 的故事书，“读厚书能消磨更多的时间，夜间当枕头用也更舒服。” </p>
<p><strong>《人生中不可不想的事》</strong> 书名看起来是那种鸡汤热血书，但随便翻开一段，都是那种充满了哲学的对话，睡前读上一两页，能够让人心静。</p>
<p>还有一些印象比较深刻的技术书籍， 在实习期间看了《TCP/IP详解 卷1》对tcp的很多细节有了解。</p>
<p><a href="https://hustddl.com/2020/08/05/bing-fa/">操作系统读书笔记</a></p>
<h4 id="观影"><a href="#观影" class="headerlink" title="观影"></a>观影</h4><p>今年印象深刻的有《进击的巨人》，《双层公寓》，《正常人》</p>
<ul>
<li>健康</li>
</ul>
<ol>
<li>暑假在实习期间第一次洗牙，感觉还是很不错的</li>
<li>开学之后，定下了健身计划，和实验室同学一起，现在谈不上练肌肉啥的，身体状态的确比在疫情期间要好很多， 21年还在学校这段时间还是争取长胖点(现在68kg)。</li>
</ol>
<h4 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h4><p>今年播客算是我日常的一部分，基本上每天散步，走路时候都会听一两期。很早就听梁文道的《八分》,马世芳的音乐电台节目等，有一段时间尝试过去听英文播客，但是不是那么轻松自然，听着听着就需要当作学习材料来处理了，英语输入还是没有那么的流畅。</p>
<p>播客能够成为我的日常很大程度在 小宇宙平台的出现，优秀的中文播客推荐+时点评论功能，基本上做到了无摩擦听播客。</p>
<p>看了下20年的收听时长，总共153小时，听的最多的三个《跟宇宙结婚》，《八分》，《随机波动》</p>
<h4 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h4><p>今年后半年有意识地去做一些输出，分享，写下自己对一篇文章，一个播客的总结。 通过输出能够很好地renew 一些尘封的记忆，当把思考转化为文字时候，就会发现一些记忆的模糊，然后主动的recall，这样就把一个个知识孤岛连接起来。看着我印象笔记里面吃灰的笔记，一个个再也没有被打开过，裁剪的文章也来越多，慢慢就变为了一个垃圾堆。</p>
<p>21年我打算继续将  信息输入-&gt; 处理-&gt;输出-&gt;renew 这个流程走下去。</p>
<h3 id="新年flag"><a href="#新年flag" class="headerlink" title="新年flag"></a>新年flag</h3><ol>
<li>强身健体</li>
<li>继续多看书，了解不同行业，继续保有对历史，人文的关注</li>
<li>做一些长期的思考</li>
</ol>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>IO复用</title>
    <url>/2020/05/19/io-fu-yong/</url>
    <content><![CDATA[<p>以往服务器等待客户端连接需要阻塞accept(),等待客户端发数据需要阻塞，如果同时有多个客户端发起请求，那么就gg,<br>当然可以通过多线程，多进程来解决，但是开销太大。于是就有了IO多路转接，</p>
<a id="more"></a>
<p>其核心思想时服务器通过内核作为媒介来监听客户端的连接请求，内核阻塞去监听客户端状态，一旦其状态变化，内核就通知<br>服务器去处理</p>
<h3 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><p><code>int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@parm1 :nfds 表示所监听的文件描述符最大值+1</span></span><br><span class="line"><span class="comment">// @parm2,3,4 所监听文件描述符事件(可读/可写/异常)</span></span><br><span class="line"><span class="comment">//@parm5:设置超时限制</span></span><br><span class="line"><span class="comment">//返回值&gt;0：监听的所有集合，总满足条件的总数;==0 超时；&lt;0 错误</span></span><br></pre></td></tr></table></figure>
<h4 id="配套操作"><a href="#配套操作" class="headerlink" title="配套操作"></a>配套操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//判断fd是否在集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//将集合对应位置为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;<span class="comment">//将集合清0</span></span><br></pre></td></tr></table></figure>
<h4 id="再看文件描述集"><a href="#再看文件描述集" class="headerlink" title="再看文件描述集"></a>再看文件描述集</h4><p>三个文件描述符参数是传入传出参数</p>
<p>举个例子，readfds 监听了{fd1,fd2,fd3,fd4} 对应位图[1111]<br>select返回2，表明有两个文件描述符准备好了,这个时候监听集合可能就变成了[1001] ，因此我们需要轮循才能知道是哪个文件描述符状态发生了改变。</p>
<h4 id="select-详细过程："><a href="#select-详细过程：" class="headerlink" title="select 详细过程："></a>select 详细过程：</h4><ol>
<li><p>当用户 process 调用 select 的时候，select 会将需要监控的 readfds 集合拷贝到内核空间（假设监控的仅仅是 socket 可读），</p>
</li>
<li><p>内核遍历自己监控的 socket sk，挨个调用 sk 的 poll 逻辑以便检查该 sk 是否有可读事件，遍历完所有的 sk 后，如果没有任何一个 sk 可读，那 select 会调用 schedule_timeout 进入 schedule 循环，使得 process 进入睡眠。如果在 timeout 时间内某个 sk 上有数据可读了，或者等待 timeout 了，则调用 select 的 process 会被唤醒，</p>
</li>
<li><p>接下来 select 就是遍历监控的 sk 集合，挨个收集可读事件并返回给用户。</p>
</li>
</ol>
<h4 id="select-缺点"><a href="#select-缺点" class="headerlink" title="select()缺点"></a>select()缺点</h4><ol>
<li>监听的文件描述符上限1024</li>
<li>需要轮循才能知道是哪个文件描述符状态发生了改变，当客户端连接数过多，但是准备就绪的又比较少时，轮循代价比较大</li>
<li>由于监听集合是传入传出参数，因此在调用<code>select()</code>之前需要先保存之前状态</li>
<li>fds集合需要从用户空间拷贝到内核空间的问题，我们希望不需要拷贝</li>
</ol>
<h4 id="select处理完整代码"><a href="#select处理完整代码" class="headerlink" title="select处理完整代码"></a>select处理完整代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> listenfd = createSocket(); <span class="comment">//这里封装了，可以简单理解为将socket(),bind(),listen() 都封装了</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 保存所有的文件描述符</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; fdset;</span><br><span class="line">    fdset.insert(listenfd);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;rfds);</span><br><span class="line">        <span class="comment">// 每次都要重新设置rfds.因为select返回时，rfds被内核改变，里面只保存了就绪的文件描述符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fd : fdset) FD_SET(fd, &amp;rfds);</span><br><span class="line">        <span class="keyword">int</span> ret = select(*fdset.rbegin()+<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> fd : fdset) <span class="comment">//这里就是轮询监听的文件描述符集合，因为使用了集合，就不需要从0-fds.size()+1遍历呢</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 有新的连接</span></span><br><span class="line">                <span class="keyword">if</span> (fd == listenfd &amp;&amp; FD_ISSET(fd, &amp;rfds))</span><br><span class="line">                &#123;</span><br><span class="line"> </span><br><span class="line">                   <span class="keyword">int</span> cfd = accept();</span><br><span class="line">                    <span class="comment">// 添加到 fd_set 结构体，并记录到 set</span></span><br><span class="line">                    FD_SET(cfd, &amp;rfds);</span><br><span class="line">                    fdset.insert(cfd); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//有请求 读数据</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(fd, &amp;rfds))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> lenrecv = <span class="number">-1</span>;</span><br><span class="line">                    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFSIZE);</span><br><span class="line"> </span><br><span class="line">                    lenrecv = recv(fd, buf, BUFSIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (lenrecv &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == lenrecv)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 客户端退出，删除文件描述符，并关闭</span></span><br><span class="line">                        fdset.erase(fd);</span><br><span class="line">                        FD_CLR(fd, &amp;rfds);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"delete connection fd: %d\n"</span>, fd);</span><br><span class="line">                        <span class="built_in">close</span>(fd);</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><code>int poll(struct pollfd *fds, unsigned int nfds, int timeout);</code></p>
<p>poll机制和select类似，通过轮询管理的文件描述符，根据其状态来进行处理。</p>
<ol>
<li>但是poll()没有最大文件描述符数量上限。</li>
<li>fds描述方式和select()不同，使用pollfd()基于链表实现，而fd_set()基于数组<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">   short events;     <span class="comment">/* requested events */</span></span><br><span class="line">   short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="poll与select对比"><a href="#poll与select对比" class="headerlink" title="poll与select对比"></a>poll与select对比</h3><h4 id="功能实现上"><a href="#功能实现上" class="headerlink" title="功能实现上"></a>功能实现上</h4><ul>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>select 会修改描述符，而 poll 不会(请求事件和返回事件分开)</li>
<li>poll 提供了更多的事件类型(POLLIN,POLLOUT,POLLERR,POLLHUP)</li>
</ul>
<h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
<h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>使用场景：连接文件描述符多，但是监听的少，或者说处于就绪态的文件描述符少，使用epoll</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>; <span class="comment">//返回指向内核的红黑树根</span></span><br><span class="line"></span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event*event)；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次(处理红黑树节点时候)，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<blockquote>
<p>为什么不在需要轮循获得准备就绪的fd?<br>因为epoll_wait() 返回的<br><code>struct epoll_event * events</code> 已经包含了就绪的文件描述符,并且该结构体含有fd,以及事件信息<br>常见的处理方式</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">activeEvs</span>[100];</span></span><br><span class="line"><span class="keyword">int</span> n = epoll_wait(efd, activeEvs, kMaxEvents, waitms);<span class="comment">//返回准备就绪的文件描述符个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = activeEvs[i].data.fd; <span class="comment">//提取fd</span></span><br><span class="line">        <span class="keyword">int</span> events = activeEvs[i].events; <span class="comment">//提取返回事件</span></span><br><span class="line">        <span class="keyword">if</span> (events &amp; (EPOLLIN | EPOLLERR)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd == lfd) &#123;</span><br><span class="line">                handleAccept(efd, fd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleRead(efd, fd);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h4 id="LT-amp-amp-ET"><a href="#LT-amp-amp-ET" class="headerlink" title="LT&amp;&amp;ET"></a>LT&amp;&amp;ET</h4><p>Level Triggered (LT) 水平触发</p>
<p>socket接收缓冲区不为空 有数据可读 读事件一直触发</p>
<p>Edge Triggered (ET) 边沿触发</p>
<p>socket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件</p>
<p>其实就是模拟电路中的上升沿以及水平概念，LT只要有数据就会读，ET只有当缓冲区状态发生改变才会触发。</p>
<p>ET很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h3 id="三种IO复用应用场景"><a href="#三种IO复用应用场景" class="headerlink" title="三种IO复用应用场景"></a>三种IO复用应用场景</h3><h4 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h4><ol>
<li>实时性要求高;select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制</li>
<li>可移植性好</li>
</ol>
<h4 id="poll-1"><a href="#poll-1" class="headerlink" title="poll"></a>poll</h4><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h4 id="epoll-1"><a href="#epoll-1" class="headerlink" title="epoll"></a>epoll</h4><p>适用于：</p>
<ul>
<li>只运行在linux</li>
<li>大量的连接，但是只有少数同时处于就绪态，并且这些连接为长连接</li>
</ul>
<p>不适用：</p>
<ul>
<li>监控的描述符状态变化多，而且都是非常短暂的，因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Peter Thiel&#39;s Religion — David Perell</title>
    <url>/2020/12/17/peter-thiel-s-religion-david-perell/</url>
    <content><![CDATA[<h2 id="读《Peter-Thiel’s-Religion-—-David-Perell》有感"><a href="#读《Peter-Thiel’s-Religion-—-David-Perell》有感" class="headerlink" title="读《Peter Thiel’s Religion — David Perell》有感"></a>读《Peter Thiel’s Religion — David Perell》有感</h2><p>转载的一篇文章，分析皮特泰勒的思想，泰勒原来就是PayPal的创始人之一，《0到1》的作者，原文很长，其中有些思想让我印象深刻，比如“模仿学习”的天性，</p>
<blockquote>
<ol>
<li>Don’t copy your neighbors</li>
<li>Time moves forward</li>
<li>The future will be different from the present</li>
</ol>
</blockquote>
<p>以及为什么这样模仿他人创业不会成功，为什么在高强度竞争不会得到高效率产出。</p>
<a id="more"></a>

<blockquote>
<p>“Our Mimetic nature is simultaneously our biggest strength and biggest weakness. When it goes right, imitation is a shortcut to learning. But when it spirals out of control, Mimetic imitation leads to envy, violence, and bitter, ever-escalating violence. “</p>
</blockquote>
<p>人类模仿的天性既是我们的最大优点也是我们最大的缺点，用对了，模仿是学习的捷径。但是一旦模仿失去了控制，模仿将导致人与人之间的嫉妒，暴力。</p>
<blockquote>
<p>“As Peter Thiel recounted:</p>
<p>“When I left after seven months and three days, one of the lawyers down the hall from me said, ‘You know, I had no idea it was possible to escape from Alcatraz.’ Of course that was not literally true, since all you had to do was go out the front door and not come back. But psychologically this was not what people were capable of. Because their identity was defined by competing so intensely with other people, they could not imagine leaving… <strong>On the outside, everybody wanted to get in. On the inside, everybody wanted to get out</strong>.”” </p>
</blockquote>
<p>项飙对内卷有类似表述，<a href="https://m.thepaper.cn/newsDetail_forward_9648585" target="_blank" rel="noopener">人类学家项飙谈内卷：一种不允许失败和退出的竞争</a>。 项飙最开始通过十三邀认识的，温州人，人类学博士，瘦瘦的，穿一件白衬衫。属于年少成名，大学期间发表了《浙江村》属于社区田野调查，我翻了下并没有多大兴趣。。。反倒是最近的一本 <a href="https://book.douban.com/subject/35092383/" target="_blank" rel="noopener">《把自己作为方法》</a> 一口气读完了，单读的主编吴琦(以前一直以为是女的。。。)采访项飙的一些文章集合，读起来没什么压力，有一处印象很深，“我调查时也有这个问题，我不太放松，不太能够调笑戏谑，比较欠缺跟大家打成一片的能力，也是我自己不太满意的地方。这个当然跟我小时候的成长有关系，我老跟我外公在一起，不太跟同龄人玩。我外公不让我跟同龄人玩，因为同龄人都是拉板车的子弟。我记得邻居如果给我东西吃，他表面上会很客气地接受，转身就让我不要吃，觉得不卫生。他也是有两面性的，对外非常客气，内心又可能有一种鄙视，其实对我也有影响，一方面把我变得比较理智，另外一方面使我不太放松。”  这让我想到我的外公。</p>
<p>下面的一些表述也让我产生强烈的感触，但是知道和有勇气去做还是很不一样的，路还很远。</p>
<blockquote>
<p>“真正的英雄不是改变世界，而是改变自己生活的每一天。很遗憾，在现代性之下，“边缘”和“中心”变成一组对立关系，中国人又有那么强的中心情结，觉得边缘的生活不值得过，造成极大的焦虑。”</p>
</blockquote>
<blockquote>
<p>我们在国内写报告，好像就是要高于生活，要写得很拽很正式，脱离生活，如果把吃喝拉撒睡都写进去，好像很不正常。</p>
<p>把自己作为方法：与项飙谈话【牛津大学社会人类学教授项飙，从个人经历切入，回应当下年轻人的精神困境，追索80年代、阶层流动、大学教育、民族与民粹、中国意识等社会议题的新答案】 (项飙)</p>
<p>您在位置 #1013-1014的标注 | 添加于 2020年10月4日星期日 上午12:27:50</p>
</blockquote>
<blockquote>
<p>不要怕边缘，或者知识不够，把自己的不够、天真真实地体现出来，就会很可爱，不要装腔作势</p>
</blockquote>
<blockquote>
<p>Thiel’s companies are governed by Girard’s wisdom. Girard observed that all desires come from other people. When two people want the same scarce object, they fight. In response, as CEO of PayPal, Thiel set up the company structure to eliminate competition between employees. PayPal overhauled the organization chart every three months. By repositioning people, the company avoided most conflicts before they even started. Employees were evaluated on one single criterion, and no two employees had the same one. They were responsible for one job, one metric, and one part of the business. </p>
</blockquote>
<p>这样花大力气调整组织架构来避免内部人员的竞争，值得考虑，但是每一个公司创世的企业文化可能差别很大，不过这种观念以及措施之前真的没有听说过，大开眼界。</p>
<blockquote>
<p>Girard observed that even when you put a group of kids together in a room full of toys, they’ll inevitably desire the same toy instead of finding their own toy to play with. A rivalry will emerge. Human see, human want. </p>
<p>Our capacity for imitation leads to envy. Babies’ interest in a particular toy has less to do with the toy itself and more to do with the fact that the other babies desire the toy. As soon as one child desires the toy, so do the others. Eventually, even though there are many toys available to play with, all the children want the same toy. </p>
</blockquote>
<p>#好故事 人类模仿的天性导致嫉妒</p>
]]></content>
  </entry>
  <entry>
    <title>calsh代理节点time-out</title>
    <url>/2021/01/07/clash-jie-dian-time-out-jie-jue/</url>
    <content><![CDATA[<p><strong>问题</strong></p>
<p>clash 电脑端所有节点time out</p>
<p><strong>分析</strong></p>
<p>电脑端最近才出现了clash 代理节点全部time out ,手机端访问正常，最近的一些操作可能导致网络问题的</p>
<ul>
<li><p>win10 开启了wsl 安装了ubuntu20.20 导致双系统时间不统一</p>
</li>
<li><p>修改hosts 添加了github域名解析(这个我觉得应该没有影响)</p>
</li>
</ul>
<a id="more"></a>

<p>尝试解决方法:</p>
<ol>
<li><p>一开始发现时间是同步的，然后卸载了wsl 中的ubuntu 发现还是不对</p>
</li>
<li><p>关闭了wsl 虚拟网卡，没有效果</p>
</li>
<li><p>开启了cfw(clash for windows)    让所有流量走clash 代理， 这个还是不行</p>
</li>
<li><p>认为是clash windows 客户端问题， 于是换成了v2rayN 更新服务之后， 突然发现电脑时间和手机时间差了4分钟</p>
</li>
<li><p>手动同步windows 时间， clash 节点time out问题解决</p>
</li>
</ol>
<p><strong>回顾</strong></p>
<p>实际上发现win10 上次同步时间成功为2020/12/29 ，这里本身就有问题，当时不够敏锐，一通瞎尝试，最后还是回到了时钟同步这个点，</p>
<blockquote>
<p>时钟同步出问题，为什么会导致服务失效，什么验证机制起作用？</p>
</blockquote>
<p>电脑端自动同步服务还是失败，参考 <a href="https://answers.microsoft.com/zh-hans/windows/forum/windows_10-networking-win_phone/win10%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E5%87%BA/558c1f25-30ce-49b6-88b1-390b6c7e74b6" target="_blank" rel="noopener">win10时间同步出错</a> 问题并没有解决</p>
]]></content>
  </entry>
  <entry>
    <title>bash学习</title>
    <url>/2020/12/10/bash-xue-xi/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="学习bash"><a href="#学习bash" class="headerlink" title="学习bash"></a>学习bash</h3><p> <a href="https://github.com/bobbyiliev/introduction-to-bash-scripting" target="_blank" rel="noopener">introduction-to-bash-scripting</a>的学习笔记 配合 <a href="https://repl.it/languages/bash" target="_blank" rel="noopener">线上bash解释器</a></p>
<p>bash 脚本开头一行 都有 <code>#!/bin/bash</code> 指此脚本使用<strong>/bin/sh</strong>来解释执行，<strong>#!</strong>是特殊的表示符，其后面根的是此解释此脚本的shell的路径, python脚本在开头也有类似的语句， <code>#!/bin/python2</code> or <code>#!/bin/python3</code></p>
<p>创建完一个bash脚本之后，需要通过<code>chmod +x XXX.sh</code> 赋予bash脚本执行权限， 文件的权限可以通过<code>ls -l</code> 查看详细， 用户组，其他，用户都具有自己对文件的权限。</p>
<p>bash 脚本执行可以 通过<code>./XXX.sh</code> 也可以直接指明<code>bash xxx.sh</code>  其中前者指定了sh 文件的路径，<a href="https://unix.stackexchange.com/questions/114300/whats-the-meaning-of-a-dot-before-a-command-in-shell" target="_blank" rel="noopener">参考</a></p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>bash 变量不需要指定类型，直接赋值，解释器动态解释。</p>
<p><strong>变量定义</strong>:</p>
<p><code>name=&quot;DevDojo&quot;</code>  note： 赋值号左右不能又空格，如果平时编码习惯和这个不一样，需要注意下。</p>
<p><strong>变量使用</strong></p>
<p><code>echo ${name}</code> 括号增加可读性。同时变量也可以在表达式中使用，语法与直接使用一样。</p>
<p>bash 语句不像c++需要显式<code>;</code>表示语句结束</p>
<p><strong>用户输入</strong></p>
<p>从命令行读取用户输入</p>
<p><code>read variable</code></p>
<p><strong>外部参数</strong></p>
<p>bash 脚本在运行时候,可以跟可变多的参数,在脚本内部用$1, $2来指代,如下面例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Argument one is <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Argument two is <span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Argument three is <span class="variable">$3</span>"</span></span><br><span class="line"><span class="comment"># excute</span></span><br><span class="line">./arguments.sh dog cat bird</span><br></pre></td></tr></table></figure>

<p>也可以很方便的用 <code>$@</code> 来引用所有的外部参数.</p>
<p>$0表示脚本文件名,一个用处就是在执行完脚本之后,可以用$0获取脚本名,然后做自删除.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The name of the file is: <span class="variable">$0</span> and it is going to be self-</span></span><br><span class="line"><span class="string">deleted."</span></span><br><span class="line">rm -f <span class="variable">$0</span></span><br></pre></td></tr></table></figure>



<p><strong>数组</strong></p>
<p>语法:<code>my_array=(&quot;value 1&quot; &quot;value 2&quot; &quot;value 3&quot; &quot;value 4&quot;)</code>  元素之间用空格隔开</p>
<p>数组引用类似C,  <code>echo ${my_array[1]}</code>  元素起始下标为0</p>
<p>数组长度获取</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">list=(1 2 3 4)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#list[@]&#125;</span>  <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure>



<h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><ul>
<li>算数表达  语法类似, 用英文字母的缩写来表示比较属性, eg. lt(less than) ,eq(equal) …..<ul>
<li>[[ ${arg1} -eq ${arg2} ]]    equal  如果两个变量相同返回true</li>
</ul>
</li>
<li>字符串<ul>
<li>[[ -v ${varname} ]] 变量如果被赋值返回true</li>
<li>[[ -z ${string} ]] 字符串长度为0 为true</li>
<li>[[ -n ${string} ]] 字符串长度不为0</li>
</ul>
</li>
<li>文件表达式 在linux 下面一切都是文件,文件具有不同的类型 比如块文件,字符设备,目录等<ul>
<li>[[ -d ${file} ]]    是否为目录</li>
<li>[[ -x ${file} ]]  文件是否可执行</li>
<li>[[ -L ${file} ]]  文件是否为符号链接</li>
</ul>
</li>
</ul>
<p>有了条件表达式,自然引出了条件语句</p>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p><strong>if-else</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ some_test ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span> &lt;commands&gt;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>



<p><strong>swith 语句</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$some_variable</span> <span class="keyword">in</span></span><br><span class="line">  pattern_1)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">  pattern_2| pattern_3)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    default commands</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>注意点</p>
<ol>
<li>case 语句用关键字<strong>case</strong>开始,引用变量,然后加关键字<strong>in</strong></li>
<li>匹配模式用) 结束</li>
<li>All clauses have to be terminated by adding ;; at the end</li>
<li>默认模式用*匹配</li>
<li>case 语句结束用esac关键字</li>
</ol>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><strong>while</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ your_condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    your_conditions</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>条件表达式都用[] 或者[[]]括起来, <a href="https://stackoverflow.com/questions/3427872/whats-the-difference-between-and-in-bash" target="_blank" rel="noopener">区别</a></p>
<p><strong>until</strong></p>
<p>含义是当条件不为真时候一直运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">until [ your_condition ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    your_commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>overload,override,overwrite小结</title>
    <url>/2020/05/23/overload-override-overwrite-xiao-jie/</url>
    <content><![CDATA[<h3 id="overload-override-overwrite小结"><a href="#overload-override-overwrite小结" class="headerlink" title="overload,override,overwrite小结"></a>overload,override,overwrite小结</h3><p>这几个关键字本身没有多大联系，但是因为名字上的关系,造成了一些误解，其次C++里面也没有overwrite这一说法，对应的概念应该为覆盖重写。</p>
<a id="more"></a>

<h4 id="overload"><a href="#overload" class="headerlink" title="overload"></a>overload</h4><p><strong>同一个作用域中</strong>，定义了多个函数名完全相同、参数（类型或者个数）不相同的函数</p>
<p>如何解决命名冲突？<br>根据“作用域+返回类型+函数名+参数列表” 做name tangling。作用域指的是在一个类中定义了不同的重载函数，类本身就标识了一个作用域。</p>
<p>不同的编译器有不同的名字修饰规则，因此很少有链接器能够处理所有编译器产生的目标代码。</p>
<p>名字修饰还有一个很常见的点，在C++代码里面经常看到下面代码，这是为了保证条件编译的代码段按照C语言处理，即不做名字修饰。</p>
<p>如果不加<code>extern C</code>,对下面的一些C库函数做了名字修饰，那么在C runtime libaray将导致链接错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span> <span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span> <span class="params">(<span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">strcmp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span> <span class="params">(<span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>





<p>什么函数不能够被重载?</p>
<ol>
<li>仅仅返回类型不同，不能够做函数重载</li>
<li>成员函数名称以及参数完全相同，仅仅其中一个是static成员函数。</li>
<li>函数参数差别仅在于有无顶层const或volatile</li>
</ol>
<p>注意，用<strong>const 修饰的成员函数是重载</strong>， 因为const 用来修饰成员函数中隐含的this 指针</p>
<p>这里就引入什么是top-level const/volatile</p>
<blockquote>
<p>A top-level const qualifier affects the object itself. Others are only relevant with pointers and references. </p>
</blockquote>
<p><code>char const x = &#39;t&#39;;</code>就是顶层常量 </p>
<p>override 可能存在二义性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转型造成二义性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">float</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>)</span></span>;  </span><br><span class="line">function(<span class="number">3.4</span>);<span class="comment">// 转型 C++中浮点数为double </span></span><br><span class="line">function(<span class="number">34</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//默认形参带来的二义性v</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of x is : "</span> &lt;&lt;x&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> z=<span class="number">12</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of y is : "</span> &lt;&lt;y&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of z is : "</span> &lt;&lt;z&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-override"><a href="#2-override" class="headerlink" title="2.override"></a>2.override</h4><p>子类重新改写父类声明为virtual的函数<br>有几个特点：</p>
<ul>
<li><p>范围不同(作用域不同)</p>
</li>
<li><p>函数签名完全一样(名字，常数列表)</p>
</li>
<li><p>基类函数必须带有virtual 关键字</p>
<p>  C++11 中的 <code>override</code>关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译阶段会报错</p>
</li>
</ul>
<h4 id="3-overwrite"><a href="#3-overwrite" class="headerlink" title="3.overwrite"></a>3.overwrite</h4><p>派生类的函数隐藏了与其同名的基类函数 ，两种情况</p>
<ul>
<li>派生类函数参数与基类不同，不管基类有无virtual</li>
<li>派生类函数参数与基类相同，但是基类没有virtual</li>
</ul>
<p>overwrite 是要被避免的，其行为不是我们预期的，C++11 引入override 关键字就是起这个作用的</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://stackoverflow.com/questions/13880205/is-the-override-keyword-just-a-check-for-a-overridden-virtual-method" target="_blank" rel="noopener">override keyword’s function</a></p>
<p><a href="https://en.wikipedia.org/wiki/Name_mangling" target="_blank" rel="noopener">名字修饰</a></p>
<p><a href="https://stackoverflow.com/questions/3789340/combining-c-and-c-how-does-ifdef-cplusplus-work" target="_blank" rel="noopener">extern c/c++</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>socket从创建到连接过程小结</title>
    <url>/2020/08/08/socket-cong-chuang-jian-dao-lian-jie-guo-cheng-xiao-jie/</url>
    <content><![CDATA[<p>分析了套接字创建到连接过程中，一些关键的函数调用以及数据结构，同时分析了connect()过程中tcp三次握手状态变化。</p>
<a id="more"></a>

<h3 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h3><h4 id="系统调用流程图"><a href="#系统调用流程图" class="headerlink" title="系统调用流程图"></a>系统调用流程图</h4><p><img src="https://s1.ax1x.com/2020/08/07/aW8ts0.png" alt="aW8ts0.png"></p>
<h4 id="sock-create"><a href="#sock-create" class="headerlink" title="sock_create()"></a>sock_create()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sock_create(family, type, protocol, &amp;sock)</span><br></pre></td></tr></table></figure>



<p><strong>family</strong> </p>
<p>指定了协议族，比较常用的ipv4协议族对应AF_INET，PF_INET。</p>
<p>AF_INET 表示address_family, PF_INET 表示protocol family ，这两者的宏定义是相同的，对于BSD,是<strong>AF</strong>,对于POSIX是<strong>PF</strong>。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX,PF_LOCAL</td>
<td>本地通信</td>
<td>PF_X25</td>
<td>ITU-T X25 / ISO-8208协议</td>
</tr>
<tr>
<td>AF_INET,PF_INET</td>
<td>IPv4 Internet协议</td>
<td>PF_AX25</td>
<td>Amateur radio AX.25</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>IPv6 Internet协议</td>
<td>PF_ATMPVC</td>
<td>原始ATM PVC访问</td>
</tr>
<tr>
<td>PF_IPX</td>
<td>IPX-Novell协议</td>
<td>PF_APPLETALK</td>
<td>Appletalk</td>
</tr>
<tr>
<td>PF_NETLINK</td>
<td>内核用户界面设备</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>type</strong></p>
<p>用于设置套接字通信的类型，主要有SOCKET_STREAM（流式套接字）、SOCK_DGRAM（数据包套接字）等。</p>
<p><strong>protocol</strong></p>
<p>protocol用于制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0。</p>
<p>因此对于一个面向对象的连接，创建一个套接字如下</p>
<p><code>int lfd=socket(AF_INET,SOCK_STREAM,0)</code>;</p>
<p>sock 类型是<code>struct socket</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">    socket_state        state;<span class="comment">//枚举类型 标识了当前socket的状态 eg. SS_CONNECTED, SS_DISCONNECTED</span></span><br><span class="line">    kmemcheck_bitfield_begin(type);</span><br><span class="line">    short           type;<span class="comment">//标识套接字类型 eg.SOCK_STREAM,SOCK_DGRAM</span></span><br><span class="line">    kmemcheck_bitfield_end(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> __<span class="title">rcu</span>  *<span class="title">wq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>     *<span class="title">file</span>;</span><span class="comment">//与套接字对应的文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     *<span class="title">sk</span>;</span><span class="comment">//指向代表下层协议(network layer)数据的sock结构</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>  *<span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="sock-alloc"><a href="#sock-alloc" class="headerlink" title="sock_alloc()"></a>sock_alloc()</h4><p>先分配socket<code>struct socket *sock_alloc(void)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	sock_alloc	-	allocate a socket</span></span><br><span class="line"><span class="comment"> *分配inode，socket 这两者是一一对应的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct socket *<span class="title">sock_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> * <span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	inode = new_inode(sock_mnt-&gt;mnt_sb);<span class="comment">//分配inode</span></span><br><span class="line">	sock = SOCKET_I(inode);<span class="comment">//通过inode得到socket</span></span><br><span class="line"></span><br><span class="line">	inode-&gt;i_mode = S_IFSOCK|S_IRWXUGO;</span><br><span class="line">	inode-&gt;i_sock = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_uid = current-&gt;fsuid;</span><br><span class="line">	inode-&gt;i_gid = current-&gt;fsgid;</span><br><span class="line"></span><br><span class="line">	get_cpu_var(sockets_in_use)++;</span><br><span class="line">	put_cpu_var(sockets_in_use);</span><br><span class="line">	<span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="net-families-gt-create"><a href="#net-families-gt-create" class="headerlink" title="net_families-&gt;create()"></a>net_families-&gt;create()</h4><p>从全局net_families数组中根据下标<code>family</code>取到对应的<code>struct net_proto_family</code>结构pf,然后调用<code>create()</code>  对于ipv4协议而言，对应到<code>net/ipv4/Af_inet.c</code>的<code>inet_create()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((err = net_families[family]-&gt;create(sock, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_module_put;</span><br></pre></td></tr></table></figure>

<p><code>struct net_proto_family</code>定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> = &#123;</span></span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    .create = inet_create,</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>inet_create</strong></p>
<ol>
<li><p>先将struct socket的state设为SS_UNCONNECTED;</p>
</li>
<li><p>根据struct socket的type(eg.SOCK_STREAM), 遍历inetsw[type], 找到对应到protocol的结构体</p>
<p><code>struct inet_protosw</code>定义如下</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is used to register socket interfaces for IP protocols.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two fields form the lookup key.  */</span></span><br><span class="line">	<span class="keyword">unsigned</span> short	 type;	   <span class="comment">/* This is the 2nd argument to socket(2). */</span></span><br><span class="line">	<span class="keyword">int</span>		 protocol; <span class="comment">/* This is the L4 protocol number.  */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span>	 *<span class="title">prot</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span>              capability; <span class="comment">/* Which (if any) capability do</span></span><br><span class="line"><span class="comment">				      * we need to use this socket</span></span><br><span class="line"><span class="comment">				      * interface?</span></span><br><span class="line"><span class="comment">                                      */</span></span><br><span class="line">	<span class="keyword">char</span>             no_check;   <span class="comment">/* checksum on rcv/xmit/none? */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	 flags;      <span class="comment">/* See INET_PROTOSW_* below.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_create</span><span class="params">(struct socket *sock, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">    sock-&gt;state = SS_UNCONNECTED;<span class="comment">//1.</span></span><br><span class="line">    <span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">	list_for_each_rcu(p, &amp;inetsw[sock-&gt;type]) &#123; <span class="comment">//2.inetsw是一个链表数组, key为SOCK_STREAM, SOCK_DGRAM, SOCK_RAW等等.</span></span><br><span class="line">		answer = list_entry(p, struct inet_protosw, <span class="built_in">list</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;<span class="comment">//3.</span></span><br><span class="line">    sk = sk_alloc(PF_INET, GFP_KERNEL,answer_prot-&gt;slab_obj_size, answer_prot-&gt;slab);<span class="comment">//4.</span></span><br><span class="line">    inet = inet_sk(sk);<span class="comment">//5.</span></span><br><span class="line">    sock_init_data(sock, sk);<span class="comment">//6.</span></span><br><span class="line">   <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;init) &#123;</span><br><span class="line">		err = sk-&gt;sk_prot-&gt;init(sk);<span class="comment">//7.</span></span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			sk_common_release(sk);</span><br><span class="line">	&#125;</span><br><span class="line">    	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>将”对应到protocol的结构体”的ops赋给struct socket结构的ops. <code>sock-&gt;ops = answer-&gt;ops;</code></p>
</li>
<li><p>调用sk_alloc, 分配网络子系统核心(net/core)的数据结构struct sock ( 记录family, protocol到sk_family, sk_prot成员 )</p>
</li>
<li><p>将struct sock强转为struct inet_sk(调用inet_sk)</p>
</li>
<li><p>调用sock_init_data(struct socket, struct sock)，用scoket 来初始化sock。</p>
</li>
<li><p>调用sk-&gt;sk_prot-&gt;init, 例如对于TCP, 指向net/ipv4/Tcp_ipv4.c的全局结构体struct proto tcp_port中的tcp_v4_init_sock, 此方法完成该socket在内核网络子系统TCP层的初始化:</p>
</li>
</ol>
<h4 id="sock-map-fd"><a href="#sock-map-fd" class="headerlink" title="sock_map_fd"></a>sock_map_fd</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/socket.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_map_fd</span><span class="params">(struct socket *sock, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fd = get_unused_fd_flags(flags);<span class="comment">//1.</span></span><br><span class="line">  ...</span><br><span class="line">  newfile = sock_alloc_file(sock, flags, <span class="literal">NULL</span>);<span class="comment">//2.</span></span><br><span class="line">  <span class="keyword">if</span> (likely(!IS_ERR(newfile))) &#123;</span><br><span class="line">    fd_install(fd, newfile);<span class="comment">//3.</span></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  sock_map_fd()主要用于对socket的<em>file指针初始化，经过sock_map_fd()操作后，socket就通过其</em>file指针与VFS管理的文件进行了关联，便可以进行文件的各种操作，如read、write、lseek。</p>
<p>sock_map_fd流程如下</p>
<ol>
<li><p>找到一个未使用的文件描述符fd。</p>
</li>
<li><p>为socket分配一个struct file实例。</p>
</li>
<li><p>建立fd到socket file的映射关系，并返回fd给上层。</p>
</li>
</ol>
<p>将struct socket的file设为struct file，struct file的private_data设为struct socket;这样struct socket和struct file便互相关联起来了.</p>
<p><img src="https://s1.ax1x.com/2020/08/07/aW8YMq.png" alt="aW8YMq.png"></p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p><img src="C:%5CUsers%5Cdiliangdeng%5CPictures%5Cimage-20200807150150809.png" alt="image-20200807150150809"></p>
<p>bind()作用是给创建的套接字绑定地址，函数原型以及包含的头文件如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sockaddr 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">               <span class="keyword">sa_family_t</span> sa_family;<span class="comment">// 地址协议族</span></span><br><span class="line">               <span class="keyword">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//sockaddr_in </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    short            sin_family;       <span class="comment">// 2 bytes e.g. AF_INET, AF_INET6</span></span><br><span class="line">    <span class="keyword">unsigned</span> short   sin_port;    <span class="comment">// 2 bytes e.g. htons(3490)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">sin_addr</span>;</span>     <span class="comment">// 4 bytes see struct in_addr, below</span></span><br><span class="line">    <span class="keyword">char</span>             sin_zero[<span class="number">8</span>];     <span class="comment">// 8 bytes zero this if you want to</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bind()中的第二个参数addr类型为struct sockaddr,在实际的socket编程中，我们一般都是将特定类型地址转化为sockaddr，比如将ipv4中绑定地址一般如下操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span> <span class="comment">//地址格式描述</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">   servaddr.sin_family = AF_INET;  <span class="comment">//IPV4</span></span><br><span class="line">   servaddr.sin_port = htons(<span class="number">123</span>); <span class="comment">//端口号</span></span><br><span class="line">   servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//INADDR_ANY一般为0，内核选择IP地址</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(struct sockaddr_in)) == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"bind socket addr failed!\n"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>既有sockaddr,又有sockaddr_in，然后还要转化，看起来多此一举，其实不然，不同的协议族地址可能不一样(eg.ipv6就和ipv4不一样），sockaddr提供了一个统一的地址接口。</p>
<h4 id="sys-bind"><a href="#sys-bind" class="headerlink" title="sys_bind"></a>sys_bind</h4><p>与socket()一样，bind通过系统调用统一接口到了sys_bind</p>
<h4 id="sockfd-lookup-light"><a href="#sockfd-lookup-light" class="headerlink" title="sockfd_lookup_light"></a>sockfd_lookup_light</h4><p>sockfd_lookup_light通过fd来查找sock</p>
<ol>
<li>在当前进程的描述符中通过fd 找到struct file</li>
<li>通过<code>file-&gt;f_dentry-&gt;d_inode</code> 得到inode</li>
<li>通过 <code>SOCKET_I(inode)</code>得到sock</li>
</ol>
<p>这里具体看下如何通过inode得到sock。</p>
<p>SOCKET_I通过调用<code>container_of(inode, struct socket_alloc, vfs_inode)-&gt;socket</code>, vfs_inode类型为inode,作为socket_alloc的数据成员。</p>
<p>container_of的作用就是通过传入inode地址，inode地址作为socket_alloc的第二个数据成员，通过计算相对socket_alloc首地址的偏移，既可以获得socket_alloc地址，即socket地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">define <span class="title">container_of</span><span class="params">(ptr, type, member)</span> <span class="params">(&#123;			</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> typeof( ((type *)<span class="number">0</span>)-&gt;member ) *__mptr = (ptr);	</span></span></span><br><span class="line"><span class="function"><span class="params">        (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> struct socket_alloc </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>move_addr_to_kernel 将地址拷贝到内核空间</li>
<li>ops-&gt;bind; 这个是sys_bind最为重要的一步调用，在创建套接字时候，我们将sock-&gt;ops设定为了与协议类型相关的函数操作集，这里我们具体分析tcp,在TCP协议情况下inet_stream_ops中bind成员函数为inet_bind。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bind, <span class="keyword">int</span>, fd, struct sockaddr __user *, umyaddr, <span class="keyword">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (sock) &#123;</span><br><span class="line">		err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</span><br><span class="line">		<span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			err = security_socket_bind(sock,</span><br><span class="line">						   (struct sockaddr *)&amp;address,</span><br><span class="line">						   addrlen);</span><br><span class="line">			<span class="keyword">if</span> (!err)</span><br><span class="line">				err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">						      (struct sockaddr *)</span><br><span class="line">						      &amp;address, addrlen);<span class="comment">//inet_bind</span></span><br><span class="line">		&#125;</span><br><span class="line">		fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="inet-bind"><a href="#inet-bind" class="headerlink" title="inet_bind"></a>inet_bind</h4><ol>
<li>做了一些检查，比如绑定地址的长度，协议族类型。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*地址长度检验*/</span></span><br><span class="line">	<span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(struct sockaddr_in))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">/*bind地址中协议检查，必须是下面两种情况</span></span><br><span class="line"><span class="comment">	* 1.绑定的地址协议为AF_INET</span></span><br><span class="line"><span class="comment">	* 2.绑定协议为0（AF_UNSPEC）同时地址也为0</span></span><br><span class="line"><span class="comment">	* 否则直接退出inet_bind ,返回地址不支持错误码</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (addr-&gt;sin_family != AF_INET) &#123;</span><br><span class="line">		<span class="comment">/* Compatibility games : accept AF_UNSPEC (mapped to AF_INET)</span></span><br><span class="line"><span class="comment">		 * only if s_addr is INADDR_ANY.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		err = -EAFNOSUPPORT;</span><br><span class="line">		<span class="keyword">if</span> (addr-&gt;sin_family != AF_UNSPEC ||</span><br><span class="line">		    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>inet_addr_type(net, addr-&gt;sin_addr.s_addr); 做了地址类型检查， 地址类型必须是本机，多播，组播中的一个，否则直接返回错误码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*获取根据IP地址得出地址类型</span></span><br><span class="line"><span class="comment">		RTN_LOCAL 本机地址</span></span><br><span class="line"><span class="comment">		RTN_MULTICAST 多播</span></span><br><span class="line"><span class="comment">		RTN_BROADCAST 广播</span></span><br><span class="line"><span class="comment">		RTN_UNICAST</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	chk_addr_ret = inet_addr_type(net, addr-&gt;sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">	err = -EADDRNOTAVAIL;</span><br><span class="line">	<span class="keyword">if</span> (!net-&gt;ipv4_sysctl_ip_nonlocal_bind &amp;&amp;</span><br><span class="line">	    !(inet-&gt;freebind || inet-&gt;transparent) &amp;&amp;</span><br><span class="line">	    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY) &amp;&amp;</span><br><span class="line">	    chk_addr_ret != RTN_LOCAL &amp;&amp;</span><br><span class="line">	    chk_addr_ret != RTN_MULTICAST &amp;&amp;</span><br><span class="line">	    chk_addr_ret != RTN_BROADCAST)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取端口号，并且对保留端口做访问权限检查。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">err = -EACCES;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3.要绑定的端口小于1024时候，要求运行该应用程序的为超级权限</span></span><br><span class="line"><span class="comment">* 否则返回并报权限不运行的错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp;</span><br><span class="line">    !ns_capable(net-&gt;user_ns, CAP_NET_BIND_SERVICE))</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>bind动作发生在TCP三次握手之前，此时TCP状态应该是CLOSE且没有绑定过其他端口</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;inet_num)</span><br><span class="line">	<span class="keyword">goto</span> out_release_sock;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>端口号能否被绑定检查,端口没有被使用返回0，否则返回非0。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">		inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">		err = -EADDRINUSE;</span><br><span class="line">		<span class="keyword">goto</span> out_release_sock;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>更新<code>sk_userlocks</code>标记，表明本地地址和端口已经绑定</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line"><span class="keyword">if</span> (inet-&gt;inet_rcv_saddr)</span><br><span class="line">		sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;</span><br><span class="line">	<span class="keyword">if</span> (snum)</span><br><span class="line">		sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;</span><br><span class="line">	inet-&gt;inet_sport = htons(inet-&gt;inet_num);<span class="comment">//端口绑定</span></span><br></pre></td></tr></table></figure>



<h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>客户端主动发起连接，调用connect</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>connect最后调用系统调用sys_connect</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_connect</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr __user *uservaddr, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="keyword">char</span> address[MAX_SOCK_ADDR];</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup(fd, &amp;err);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	err = move_addr_to_kernel(uservaddr, addrlen, address);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">	err = sock-&gt;ops-&gt;<span class="built_in">connect</span>(sock, (struct sockaddr *) address, addrlen,</span><br><span class="line">				 sock-&gt;file-&gt;f_flags);</span><br><span class="line">out_put:</span><br><span class="line">	sockfd_put(sock);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找sock,将地址从用户空间拷贝内核空间，这些操作与bind()分析一样， 这里不再赘述，主要看下 <code>sock-&gt;ops-&gt;connect</code></p>
<p>对于ipv4这个family来说,type为<code>SOCK_STREAM，</code>sock-&gt;ops指向inet_stream_ops，sock-&gt;ops-&gt;connect指向inet_stream_ops的connect, 即<code>inet_stream_connect</code>.</p>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="https://s1.ax1x.com/2020/08/07/ahrMnO.png" alt="ahrMnO.png"></p>
<ol>
<li>调用ip_route_connect进行寻路, 取得struct rtable，目的是为了确定下一跳目的地址</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tmp = ip_route_connect(&amp;rt, nexthop, inet-&gt;saddr,</span><br><span class="line">			       RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,</span><br><span class="line">			       IPPROTO_TCP,</span><br><span class="line">			       inet-&gt;sport, usin-&gt;sin_port, sk);</span><br><span class="line"><span class="keyword">if</span> (!inet-&gt;opt || !inet-&gt;opt-&gt;srr)</span><br><span class="line">		daddr = rt-&gt;rt_dst;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置套接字状态为SYN_SENT</li>
<li>调用<code>tcp_v4_hash_connect(sk)</code></li>
</ol>
<p>这一步的目的是绑定端口，并且将套接字插入到bind链表，哈希链表以port为关键字，将地址相同的串在一个链表上(哈希冲突)。</p>
<p>这一步之前source port可能还为0(对于client端调用socket后直接调用connect不经过bind的情况, source port为0).所以该方法会生成一个随机的source port, 赋给struct inet_sk的inet_sport成员</p>
<ol>
<li><code>ip_route_newports</code> 分配完端口后，再查一次路由</li>
<li>生成初始序列号ISN</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secure_tcp_sequence_number(inet-&gt;saddr,inet-&gt;daddr,inet-&gt;sport,usin-&gt;sin_port);</span><br></pre></td></tr></table></figure>

<ol>
<li><code>tcp_connect()</code>构造SYN，将连接数据包发送出去</li>
</ol>
<ul>
<li><code>buff = alloc_skb(MAX_TCP_HEADER + 15, sk-&gt;sk_allocation);</code> 分配skb</li>
<li><code>TCP_SKB_CB(buff)-&gt;flags = TCPCB_FLAG_SYN;</code>设置syn 标志</li>
<li><code>__skb_queue_tail(&amp;sk-&gt;sk_write_queue, buff);</code> 将构建好的skb添加到套接字对应的写队列</li>
<li><code>tcp_transmit_skb(sk, skb_clone(buff, GFP_KERNEL));</code>  tcp层实际的处理和传输过程</li>
<li><code>tcp_reset_xmit_timer(sk, TCP_TIME_RETRANS, tp-&gt;rto);</code>   设定syn超时重传</li>
</ul>
<blockquote>
<p>我们说connect() 调用时候发送SYN, 在返回之前回复对方ACK ,在代码中体现?</p>
</blockquote>
<p>客户端发送syn之后，阻塞在<code>inet_wait_for_connect()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">inet_wait_for_connect</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DEFINE_WAIT(wait);</span><br><span class="line"></span><br><span class="line">	prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Basic assumption: if someone sets sk-&gt;sk_err, he _must_</span></span><br><span class="line"><span class="comment">	 * change state of the socket from TCP_SYN_*.</span></span><br><span class="line"><span class="comment">	 * Connect() does not allow to get error notifications</span></span><br><span class="line"><span class="comment">	 * without closing the socket.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="comment">//循环检查状态变化</span></span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">		release_sock(sk);</span><br><span class="line">		timeo = schedule_timeout(timeo);</span><br><span class="line">		lock_sock(sk);</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current) || !timeo)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		prepare_to_wait(sk-&gt;sk_sleep, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">	&#125;</span><br><span class="line">	finish_wait(sk-&gt;sk_sleep, &amp;wait);</span><br><span class="line">	<span class="keyword">return</span> timeo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端在收到SYN+ACK之后，调用流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp_v4_rcv→tcp_v4_do_rcv→tcp_rcv_state_process→tcp_rcv_synsent_state_process</span><br></pre></td></tr></table></figure>

<p>在函数tcp_rcv_state_process中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> TCP_SYN_SENT:</span><br><span class="line">        tp-&gt;rx_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">        tcp_mstamp_refresh(tp);</span><br><span class="line">        <span class="comment">//进入tcp_rcv_synsent_state_process处理</span></span><br><span class="line">        queued = tcp_rcv_synsent_state_process(sk, skb, th);</span><br><span class="line">        <span class="keyword">if</span> (queued &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> queued;</span><br><span class="line">        <span class="comment">/* Do step6 onward by hand. */</span></span><br><span class="line">        tcp_urg(sk, skb, th);</span><br><span class="line">        __kfree_skb(skb);</span><br><span class="line">        tcp_data_snd_check(sk);</span><br><span class="line">        retur</span><br></pre></td></tr></table></figure>

<p>在tcp_rcv_synsent_state_process中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查ACK的有效性</span></span><br><span class="line">tcp_ack(sk, skb, FLAG_SLOWPATH);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果ack有效,则完成连接，将状态兄TCP_SYN_SENT-&gt;TCP_ESTABLISHED</span></span><br><span class="line">tcp_finish_connect(sk, skb);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//发送ack</span></span><br><span class="line"> tcp_send_ack(sk);</span><br></pre></td></tr></table></figure>

<p>tcp_finish_connect将连接状态设为TCP_ESTABLISHED，然后唤醒之前阻塞在<code>inet_wait_for_connect()</code>  的进程，至此connet()完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_finish_connect</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    tcp_set_state(sk, TCP_ESTABLISHED); <span class="comment">/* 在这里设置为连接已建立的状态 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (! sock_flag(sk, SOCK_DEAD)) &#123;</span><br><span class="line">        sk-&gt;sk_state_change(sk); <span class="comment">/* 指向sock_def_wakeup，会唤醒调用connect()的进程，完成连接的建立 */</span></span><br><span class="line">        sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT); <span class="comment">/* 如果使用了异步通知，则发送SIGIO通知进程可写 */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/18609397/whats-the-difference-between-sockaddr-sockaddr-in-and-sockaddr-in6" target="_blank" rel="noopener"><a href="https://stackoverflow.com/questions/18609397/whats-the-difference-between-sockaddr-sockaddr-in-and-sockaddr-in6" target="_blank" rel="noopener">What’s the difference between sockaddr, sockaddr_in, and sockaddr_in6?</a></a></p>
<p><a href="https://vcpu.me/bind/" target="_blank" rel="noopener">bind</a></p>
<p><a href="https://johnhx.github.io/2017/05/11/LinuxKernel-Connect-flow/" target="_blank" rel="noopener">Linux内核网络子系统源码分析(2) – connect系统调用</a></p>
<p><a href="https://blog.csdn.net/zhangskd/article/details/45508569" target="_blank" rel="noopener">Socket层实现系列 - connect()的实现_zhangskd的专栏-CSDN博客_inet_csk_wait_for_connect</a></p>
<p><a href="https://e-mailky.github.io/2017-01-14-tcp-connect" target="_blank" rel="noopener">socket建立连接 sys_connect</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shared_from_this解决了什么问题</title>
    <url>/2020/06/02/shared-from-this-jie-jue-liao-shi-me-wen-ti/</url>
    <content><![CDATA[<a id="more"></a>

<p>enable_shared_from_this 含义<br>如果一个T类型的对象t,是被std::shared_ptr管理的，且类型T继承自<code>std::enable_shared_from_this</code>，那么T就有个<code>shared_from_this</code>成员函数，这个函数返回一个新的<code>std::shared_ptr</code>的对象，也指向对象t</p>
<p>如果不这么做, 会出现什么问题，看下面一段代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obj</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">get_shr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">ret</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;obj&gt; <span class="title">smart_ptr</span><span class="params">(<span class="keyword">new</span> obj)</span></span>;</span><br><span class="line">    obj&amp; a=*smart_ptr;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;obj&gt; b=a.get_shr(); <span class="comment">//两个智能指针管理的是同一个对象，造成对象两次释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述场景是 对象希望获得管理自己的智能指针，但是直接通过成员函数返回一个<code>shared_ptr</code>,造成了被管理对象的重复删除。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>tcp40ms延迟问题分析</title>
    <url>/2020/08/23/tcp40ms-yan-chi-wen-ti-fen-xi/</url>
    <content><![CDATA[<a id="more"></a>

<p><strong>背景</strong></p>
<p>tcp抓包发现服务端回复ack存在40ms左右延迟</p>
<p><img src="https://s1.ax1x.com/2020/08/17/dmqEqK.png" alt="dmqEqK.png"></p>
<p><strong>问题排查过程</strong></p>
<p>通过查阅资料发现tcp40ms延迟不是一个偶然的现象。先给出结论：<strong>客户端开启nagle算法+服务端延迟ack</strong>，延迟ack的超时时间为40ms。</p>
<p>先介绍下重要的概念</p>
<p><strong>delay ack</strong></p>
<p>在TCP建立连接之后，最开始的数据交互是处于quick ack mode,顾名思义就是当对端收到数据立马就会回复ack。在接下来的数据交互过程中，服务端仍然执行快速ack,服务端然后往对端发送交互数据，此时系统探测到了这样一种交互行为，于是开启ping pong mode。服务端开启了ping pong mode之后，收到数据不会立马回复对端ack,而是在回复响应数据时候带上ack,这样减少了网络中的包量。但是如果服务端在延时ack时间都没有响应客户端的请求就可能出现短暂的响应延迟。</p>
<p><img src="https://s1.ax1x.com/2020/08/17/dmqAr6.png" alt="dmqAr6.png"></p>
<p><strong>nagle算法</strong></p>
<p>Nagle算法的<strong>基本定义</strong>是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</p>
<p>Nagle算法的规则（tcp_output.c文件里tcp_nagle_check函数注释）：</p>
<p>（1）如果包长度达到MSS，则允许发送；</p>
<p>（2）如果该包含有FIN，则允许发送；</p>
<p>（3）设置了TCP_NODELAY选项，则允许发送；</p>
<p>（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；</p>
<p>（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。</p>
<p>有了上面的知识铺垫，我们具体分析下客户端开启nagle,服务端处于delay ack 状态下，客户端不同大小数据请求下延时情况。</p>
<ol>
<li>当客户端请求数据小于mss大小</li>
</ol>
<p>假设客户端之前的数据已经全部被ack了，此时发送一个新的数据请求，小于mss,对端服务器在收到数据之后，不会立马回复ack,但是在delay ack超时之前能够回复响应数据，顺带就把ack发过去了，所以不会出现我们说的40ms延迟。</p>
<ol start="2">
<li>客户端请求数据大于mss</li>
</ol>
<p>由于请求数据大于mss,一个包装不下这么多数据，tcp会将数据分成小包发送，在发送第一个小包之后，服务端延迟ack,同时由于数据不全，服务端不能立即响应，于是就在等待延迟ack超时，同时客户端这边开启了nagle，之前发送的数据包还没有被ack,待发送的数据包小于mss，于是也进入等待，这样一来双方都处于等待，进入了短暂的”死锁“。</p>
<p><strong>解决方案</strong></p>
<p>有了上面的分析，我们可以从两个方向来考虑如何解决40ms延迟。</p>
<ol>
<li><p>服务端关闭延迟ack ；<code>echo 1 &gt; /proc/sys/net/ipv4/tcp_no_delay_ack</code></p>
</li>
<li><p>客户端关闭nagle；通过设置<code>TCP_NODELAY</code>来实现</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>stringstream 处理字符串</title>
    <url>/2020/05/20/stringstream-chu-li-zi-fu-chuan/</url>
    <content><![CDATA[<p>在刷leetcode 过程中，C++一直没有比较好的方法来分割字符串，尤其对于带有很明显的分隔符比如<code>.,\</code>,等</p>
<p>我一般的做法都是用两个下标来标识一段子字符串，然后<code>substr()</code>来做进一步处理。</p>
<p>最近学习了用<code>stringstream</code>来处理字符串，类似<code>iosteam,fsteam</code>,使得操作<code>string</code>就像操作输入流一样。</p>
<a id="more"></a>

<h4 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a></h4><p><strong>思路</strong></p>
<p>对于文件路径有很明显的分隔符<code>/</code>，类似的对于IP地址分隔符<code>.</code></p>
<ul>
<li>用输入字符串来初始化<code>stringstream</code>对象</li>
<li>while循环提取子字符串，根据情况判断</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">is</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> res,temp;</span><br><span class="line">        <span class="keyword">while</span>(getline(is,temp,<span class="string">'/'</span>))&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;"temp:    "&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="string">""</span>||temp==<span class="string">"."</span>) <span class="comment">// 处理// /./情况</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="string">".."</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.size())st.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span> st.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:st)&#123;</span><br><span class="line">            res+=<span class="string">"/"</span>+str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.empty()) <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>下面的snippet code 用来处理类似<code>&quot;dog cat mouse ...&quot;</code>字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">raw</span><span class="params">(str)</span></span>;</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">     <span class="built_in">string</span> line;</span><br><span class="line">     <span class="keyword">while</span> (raw &gt;&gt; line) strs.push_back(line);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《Factluness》阅读笔记</title>
    <url>/2021/01/20/factluness-yue-du-bi-ji/</url>
    <content><![CDATA[<p>《Factluness》开篇给了11个选择题，用来测试人们对这个世界存在的认知偏差。作者通过一系列数据说明简单的将这个世界分为发展&amp;&amp;发达，贫穷&amp;&amp;富有早已经不合适了，于是作者提出了一个概念:按照收入水平将世界人口分为四个等级，现阶段大部分人处于第二，第三等级。</p>
<p>这本书比较好读，有明确的问题导向， 每一个大章节最后都会有总结，但作者给出的一些数据和在非洲国家的亲身经历让我深思。</p>
<a id="more"></a>



<p><strong>一分为二看待问题会出什么问题</strong></p>
<ul>
<li><p>从1965年到2017年，这期间人们生活水平发生了巨大变化，已经不能简单的用发达，发展国家来分类，75%的人口，生活在中等收入国家中，不是穷国，也不是富国，而是介于二者之间的一种生活水平。</p>
</li>
<li><p>对事实忽略带来的机会损失</p>
</li>
</ul>
<p>对事实的忽略将错失巨大的商业机会，以卫生巾为例，很多公司在欧洲饱和市场做细分领域的开发， 比如探寻在为穿比基尼泳装的妇女们提供更薄的卫生巾，但是却忽视了活在收入水平第四级的三亿处于月经期的妇女服务，而没有去拓展收入水平更低的新市场。</p>
<p><strong>以偏概全</strong></p>
<ul>
<li>想当然的归纳带来的危险</li>
</ul>
<p>作者和学生去印度一个医院实地调查，当他学生差点赶不上电梯时候，用脚去拦住快要关闭的电梯，最后被电梯卡住。在瑞典，所有的电梯门上都有传感器。如果探测到门之间有东西的话，电梯门会自动打开。这位印度医生非常疑惑地看着我说：“但是你怎么知道这种先进的设备每次都可以正常工作呢？”我的回答显得很愚蠢，我说：“嗯，在我印象里好像每一次都管用。可能设备在出厂的时候经过了严格的检测吧。”他看起来并不太相信我说的话，他说：“你们国家的生活太安全了，使得其他国家都显得很危险。”</p>
<p>这一点的确让我惊讶，很多生活中想当然的情况换一个环境就不是这样了。</p>
<ul>
<li>NGO项目查看不同收入水平阶级的生活方式对比</li>
</ul>
<p><a href="https://www.gapminder.org/dollar-street/?lng=zh-CN&topic=make-up&regions=as" target="_blank" rel="noopener">dollarstreet</a>通过对比相同的主题（eg。家园，牙刷等)下，看下不同生活水平的人差别有多大。 处于同一收入阶层的人即使在不同国家，生活方式是差不多的。同一国家不同收入阶级的生活方式差别很大。</p>
<p>作者下面提到的避免以偏盖全方法，同样适用于软件工程领域。</p>
<ul>
<li>适用于软件测试的方法<ul>
<li>注意大多数； 99%和51%区别很大</li>
<li>注意极端案例(corner case),这个很好理解，一些边界条件</li>
<li>不要把自己放在中心位置，也不要假设他人是傻子，比如下面这个例子</li>
</ul>
</li>
</ul>
<p>突尼斯可能看到很多盖到一半的房子，初看觉得当地人没有规划，很懒。但实际情况是，对于当地人而言，去银行贷款很难，同时保存现金很不安全（可能贬值或者被偷），单个的屯砖也可能被偷。于是他们用钱去买砖慢慢盖房子。这恰巧体现了当地人的智慧。</p>
<blockquote>
<p>世界总的趋势是变好还是变坏？</p>
</blockquote>
<p>心理学上人们对悲观负面情绪更加敏感，存在下面几点原因</p>
<ol>
<li>记忆存在美好滤镜，人们回忆起童年很多时候都美化了记忆，实际情况可能没这么好</li>
<li>新闻对于负面新闻的选择报道</li>
<li>悲观被感性情绪主导</li>
</ol>
<p>但作者从统计数据来看， 世界总的贫困人口数最近20年减少了一半，平均寿命也有了大幅提升。</p>
<p>解决之道”不是我们要多看一些正面的新闻来对冲负面新闻带来的影响，因为那将会带来另一种自我欺骗的、自我安慰的、误导性的偏见。”这让我想到方可成提到的<strong>连接与共情</strong>观点，通过主动释放善意，不消极的认为这个世界就是一个丛林法则。 这方面可以订阅下他=最近的一个项目 微博账号“放晴公园”</p>
<p><strong>直线思维</strong></p>
<p>书中提到联合国的人口预估报告，认为2100年儿童人口将和现在数目基本一致，维持在20亿左右。</p>
<p>这似乎与我们直观认识不符合。毕竟现在总人口还在缓慢增长估计到2100年将到100亿。 这是为什么？</p>
<ul>
<li>过去几十年妇女生育人均数目大幅度下降从1965年的5-&gt;2.5/人</li>
<li>增长的人口主要是由现在小孩变为的成年人</li>
</ul>
<p>作者为了阐述很多数据分布不一定符合直线思维，举了一些有意思的案例</p>
<ul>
<li>滑梯曲线</li>
</ul>
<p>女性人均生育数</p>
<ul>
<li>正态分布(驼峰曲线)</li>
</ul>
<p>一个有意思的案例关于蛀牙情况分布，第一级人们没钱买糖，第四级人们牙齿健康水平得到了提升，比如他们会去定期洗牙等，反而是处于第二，三级的人蛀牙率比较高。机动车事故也符合同样的逻辑。</p>
<ul>
<li>指数曲线； 常见的流行病感染</li>
</ul>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>内存虚拟化</title>
    <url>/2020/08/01/nei-cun-xu-ni-hua/</url>
    <content><![CDATA[<p>《OSTEP》 内存虚拟化部分小结</p>
<a id="more"></a>

<h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><blockquote>
<p>为什么引入了虚拟地址?</p>
</blockquote>
<ul>
<li>使得编程简单，每个应用进程有自己很大一片的地址空间，不用担心代码,变量存放到哪里</li>
<li>提供了进程之间的保护和隔离；如果我们直接操控物理内存，那么很可能由于进程一个不小心override导致其他进程崩溃</li>
</ul>
<p>举个例子两个进程A,B 都有自己的地址空间，eg. 对0x100访问，由于虚拟地址的映射他们对应的物理地址不同。</p>
<blockquote>
<p>设计一套虚拟内存需要满足满足那些目标?</p>
</blockquote>
<ol>
<li><p>透明； 对于编程者而言，我们应该是感知不到虚拟地址到物理地址之间的转化，操作系统和硬件在后面帮我们做了地址转化的这些工作</p>
</li>
<li><p>高效； 引入虚拟内存，空间角度上来看使用额外很多的内存来存储辅助数据结构，时间上不能导致程序运行变慢</p>
</li>
<li><p><strong>保护/隔离</strong>；这个我觉得是最为重要的，程序装载到内存中不能够影响到其他进程。</p>
<p>具体来看，虚拟内存实现机制，分段，分页下如何做进程间保护?</p>
</li>
</ol>
<h4 id="简单地址翻译"><a href="#简单地址翻译" class="headerlink" title="简单地址翻译"></a>简单地址翻译</h4><p>作者先做了一些假设，对虚拟内存系统设计做了一些简化，然后慢慢放宽条件，逐渐模拟一个真实场景下的虚拟内存系统。这样能够让读者循序渐进体会到系统设计面临的问题，然后慢慢引入新的方案来改进。</p>
<p> 一开始作者假设</p>
<ol>
<li>虚拟地址空间连续存放到物理内存</li>
<li>地址空间大小不超过物理内存&amp;&amp;每个进程地址空间相同</li>
</ol>
<h5 id="硬件支持地址翻译"><a href="#硬件支持地址翻译" class="headerlink" title="硬件支持地址翻译"></a>硬件支持地址翻译</h5><p>在上述假设下，有了基于硬件支持的动态重定位来做地址翻译通过硬件寄存器支持 base+limit </p>
<p>地址转化： <code>physical address = virtual address + base</code></p>
<p>limit用来做权限保护，如果虚拟地址超出了limit，程序将终止。</p>
<p>之前经常听到的MMU,用来做地址转化的硬件单元，这里提到的base,limit寄存器就是MMU的一部分，当然后面为了做更加复杂的地址翻译，MMU还有一些其他硬件的支持。</p>
<p>从操作系统角度，基于上述虚拟内存的实现方案，有几个问题要解决</p>
<ul>
<li>进程创建时，分配与地址空间对应的物理内存</li>
<li>当进程结束时，回收内存</li>
<li>进程切换，上下文保存；这里只需要保存一对base-limit寄存器</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>base+bound 的地址转化方案</p>
<p><strong>优点</strong></p>
<ul>
<li><p>在硬件支持下起来很高效快速</p>
</li>
<li><p>提供了进程间的保护隔离</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<p>- 进程空间的整个映射到内存导致了内部碎片(heap,stack)</p>
<h4 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h4><p>基于单个base-limit寄存器将整个地址空间存到了内存造成了内存的浪费，我们分析主要的原因在于，stack,和heap的不确定，基于此，我们为什么不能够在单对寄存器的基础上，对code,data,stack,heap 都分配一对寄存器</p>
<p><img src="https://s1.ax1x.com/2020/07/31/a1UDsg.png" alt="a1UDsg.png"></p>
<p>我们经常见到的段错误(segment fault)就是访问非法地址，超出了bound的范围。</p>
<p>段表的引入带来了一个问题，如何确定访问哪一个段对应的寄存器?</p>
<p>显示的做法时用虚拟地址前几个bit来标识，如下图</p>
<p><img src="https://s1.ax1x.com/2020/07/31/a1Uwz8.png" alt="a1Uwz8.png"></p>
<p>分段机制下地址转化伪码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get top 2 bits of 14-bit VA</span></span><br><span class="line"><span class="comment">//Bounds[] 段表</span></span><br><span class="line">Segment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT <span class="comment">//确定是哪一个段</span></span><br><span class="line"><span class="comment">// now get offset</span></span><br><span class="line">Offset= VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"><span class="keyword">if</span> (Offset &gt;= Bounds[Segment])<span class="comment">//边界检查</span></span><br><span class="line">	RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	PhysAddr = Base[Segment] + Offset</span><br><span class="line">	Register = AccessMemory(PhysAddr)</span><br></pre></td></tr></table></figure>



<p>按段加载还有一个好处使得段共享成为可能，比如将代码段设为只读，进程仍然认为访问的是私有地址空间，这样也不会破坏进程间的隔离。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>好处：</p>
<ul>
<li><p>减少了内部碎片,内存浪费</p>
</li>
<li><p>代码段等可以共享</p>
</li>
</ul>
<p>问题：</p>
<ul>
<li><p>大小不一的段可能导致外部碎片</p>
</li>
<li><p>内存不能做到按需分配</p>
</li>
</ul>
<p>产生外部碎片的原因在于，之前按照整个地址空间加载，并且进程地址空间大小一致，这样就可以将内存看作是一个大的数组，每次分配都是一个slot单位，现在按照段分配，虽然避免了内部碎片产生，但是由于每个段大小不一样，在内存的频繁分配与释放，就可能产生外部碎片，一些小的内存块就不能够得到利用。</p>
<h4 id="空闲物理内存管理"><a href="#空闲物理内存管理" class="headerlink" title="空闲物理内存管理"></a>空闲物理内存管理</h4><p>我们在C中分配释放内存如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>会发现当我们释放内存时候，只是给了起始地址，没有指定大小，那么系统怎么知道要释放多少了?</p>
</blockquote>
<p>分配器用额外的头部信息来记录分配内存的大小，魔数用来做完整性检查。因此当我们申请N字节大小内存，实际分配了N+sizeof(header)</p>
<p><img src="https://s1.ax1x.com/2020/07/31/a1UBQS.png" alt="a1UBQS.png"></p>
<h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><blockquote>
<p> free memory is first conceptually thought of as one big space of size 2N. When a request for memory is made, the search for free space recursively divides free space by two until a block that is big enough to accommodate the request is found (and a further split into two would result in a space that is too small).</p>
</blockquote>
<h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>我们说分段导致了外部碎片产生，根本原因在于段的大小不一，分页机制通过将地址空间划分为固定大小的地址单元(eg.4k)来解决这个问题。</p>
<p>每个进程有自己的一个页表，记录了虚拟页号和物理页号的对应关系。常见的地址映射如下</p>
<p>​                                               <img src="https://s1.ax1x.com/2020/07/31/a1UzOe.png" alt="a1UzOe.png"></p>
<p>实现页机制有几个问题</p>
<blockquote>
<p>1.页表存在哪里?</p>
<p>2.每一个页表项具体有什么内容?</p>
</blockquote>
<p>对于32bit地址空间，假设一个页表项4byte, 整个地址空间页表需要4M，每个进程有自己的页表，因为页表很大，不可能像段机制那样通过CPU的寄存器来存，因此我们的页表是直接存到内存里面的，刚刚分析一个页表就是4M,这个很恐怖，如果有上百个进程，光是页表就消耗了几百兆内存，因此这一部分后面是需要优化的。</p>
<p>X86下一个页表项的内容如下，有几个flag需要注意下</p>
<ul>
<li>P：存在位。为1表示页表或者页位于内存中。否则，表示不在内存中，必须先予以创建或者从磁盘调入内存后方可使用。</li>
<li>R/W：读写标志。为1表示页面可以被读写，为0表示只读。当处理器运行在0、1、2特权级时，此位不起作用。页目录中的这个位对其所映射的所有页面起作用。</li>
<li>U/S：用户/超级用户标志。为1时，允许所有特权级别的程序访问；为0时，仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用。</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/31/a1UxyD.png" alt="a1UxyD.png"></p>
<p>由于页表位于内存，带来的后果就是我们对于一条指令的执行将额外增加一次内存访问(地址翻译)，伪码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"></span><br><span class="line"><span class="comment">// Form the address of the page-table entry (PTE)</span></span><br><span class="line">PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE)) <span class="comment">//ptbr 页表起始地址 存在寄存器里面</span></span><br><span class="line"><span class="comment">// Fetch the PTE</span></span><br><span class="line">PTE = AccessMemory(PTEAddr)v<span class="comment">//一次内存访问得到物理地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if process can access the page</span></span><br><span class="line"><span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">	RaiseException(SEGMENTATION_FAULT)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">	RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// Access is OK: form physical address and fetch it</span></span><br><span class="line">offset= VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset</span><br><span class="line">Register = AccessMemory(PhysAddr) <span class="comment">//二次内存访问</span></span><br></pre></td></tr></table></figure>

<h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>好处：</p>
<ul>
<li><p>固定大小内存单元，避免外部碎片</p>
</li>
<li><p>相对分段内存使用灵活</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>页表占用内存过大</p>
</li>
<li><p>访问太慢(相比直接内存访问，多一次内存访问)</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>OSTEP</tag>
      </tags>
  </entry>
  <entry>
    <title>人体上肢自然运动数据采集</title>
    <url>/2021/01/20/ren-ti-shang-zhi-yun-dong-shu-ju-cai-ji/</url>
    <content><![CDATA[<p>实验室现有的数据集数量有限，局限于人体日常功能运动，比如摸头，摸嘴等。为了扩充人体上肢运动数据集，于是设计了下面的实验方案，这里记录下执行过程中遇到的一些工程问题。</p>
<a id="more"></a>

<p>基本思路是通过离散人上肢可达操作空间，然后采点，多次测量人手掌中心到采样点的运动轨迹，但空间中直接采点测量存在较大难度，精度也达不到要求，于是通过引入协作机器人UR5来辅助定位，在编写好程序之后，能够适应不同受试者臂长，并且能够做到对空间中点随机采样。</p>
<p>示意图如下</p>
<p><img src="https://raw.githubusercontent.com/ddl-hust/imagebed/master/20210120145436.png" alt="image-20210120145435979"></p>
<p>坐标系原点O与实验对象利手侧肩部盂肱关节旋转中心对齐，双肩连线为X轴，盂肱关节旋转中心的铅垂线为Z轴，Y轴垂直于冠状面并指向实验对象正前方，只讨论Y轴正半轴，也就是冠状面以前部分的工作空间。以球极坐标描述实验工作区各点，以实验对象臂长AL为半径作为工作空间边界，目标点位于以0.5AL,0.7AL,0.9AL为半径的半球面上，r的取值分别是0.5AL,0.7AL,0.9AL。</p>
<p>在XOY平面上定义手腕与盂肱关节旋转中心连线和Y轴夹角为方位角，手腕与盂肱关节旋转中心连线与Z轴夹角为俯仰角 。通过三个参数$\gamma$ ,$\theta$,$r$ 来表示腕关节中心在球面坐标系下表达。</p>
<p><strong>实现流程</strong></p>
<ol>
<li>用vicon测量人体肩关节中心与jUR5基座中心相对姿态</li>
<li>以人体肩关节为中心，臂长为参数，离散操作空间采样点</li>
<li>将采样点按照相邻顺序，序列化“一条线” 目的为了减少机械臂在相邻采样点关节运动范围。</li>
<li>处理UR5多组反解，优选不与机架存在干涉的解 并且尽量减少相邻两次运动中关节角移动</li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>需要注意的是第4步我们使用了第三方库得到UR5所有的8组反解， 这个库用到了ikfast，因此依赖Egien，如果系统没有安装，记得添加上。</p>
</li>
<li><p>其次反解库对C++做了封装，提供matlab接口，因此还需要安装C++-mex编译器。</p>
</li>
<li><p>我们之所以手动做反解，不用UR5自带的反解器是因为我们一开始的确是发送操作空间指令，即给定目标点位姿。但是在实际执行中发现在相邻两次运动中，即使目标点距离很近，但是由于UR5存在多组反解，这就可能导致两次运动中关节角实际变换特别大，超出了关节角限制</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title>多抓鱼采访</title>
    <url>/2020/12/28/duo-zhua-yu-cai-fang/</url>
    <content><![CDATA[<ul>
<li>多抓鱼和咸鱼区别？</li>
</ul>
<p>咸鱼更像是一个平台，一个流量入口，对于商品的质量没有过多的把控，当然这也是一种商业模式，通过动态调整容错率，用户的信用来优化。 但是多抓鱼是负责品控的，对于什么书卖不卖有自己的逻辑，同时也会对回收的书做消毒等后期处理，提升整个交易的体验感。</p>
<p>“可能因为多抓鱼是做书的，所以大家对我们经常有一种误解，觉得我们是一家卖情怀的公司，但事实上真不是这样的，我们是一家正经的商业公司。虽然我们的员工都很喜欢看书，也非常喜欢逛二手店，但是我们觉得，想要把一件事情做好，就一定要有一个良好的商业模式在背后支撑，这样才可以走得比较长远，而不是用爱来发电。”</p>
<p><strong>为什么做多抓鱼</strong>？</p>
<ul>
<li><p>猫助自己大学期间对文化产品需求很高，同时没什么钱，于是在毕业季做起了摆摊。</p>
</li>
<li><p>解决交易信用，解决交易摩擦；用定价系统解决了交易效率的问题，用翻新的技术解决了交易信用的问题</p>
</li>
<li><p>因为我们的员工非常相信一句话：一家书店的气质是由它不卖什么书决定的</p>
</li>
<li><p>二手物品往往有它自己的故事，它都带着上一个主人的回忆，这也是多抓鱼名字的来源，是一个法语单词，déjà vu</p>
</li>
<li><p>安全感不会是你的年薪带给你的，就像曾经的我那样。安全感其实是通过你的创造带给你的</p>
</li>
<li><p>猫助的职业路径从搜狐-&gt;知乎-&gt;阿里，合伙创始人陈托前知乎商业产品负责人、豆瓣社区开发负责人</p>
</li>
</ul>
<blockquote>
<p>“当时的打工让我感受到很多虚无的光环，大公司的title、夸张的年薪，这些跟「你是谁」「你想在世界上做什么」完全没有关系的世俗定位让我很迷失，我很害怕失去这种定位带来的安全感。”</p>
</blockquote>
<p><strong>多抓鱼的定价策略</strong></p>
<p><img src="https://raw.githubusercontent.com/ddl-hust/imagebed/master/20201228114008.png" alt=""></p>
<ul>
<li>确定几类书不收</li>
<li>一开始人工判断书收不收，慢慢积累数据集，通过人工智能来判断。</li>
<li>定价通过多抓鱼内部数据，根据市场供求关系动态变化</li>
</ul>
<p><strong>shownotes</strong></p>
<p><a href="https://www.yixi.tv/h5/speech/667/" target="_blank" rel="noopener">一席采访多抓鱼CEO猫助</a></p>
<p><a href="https://www.listennotes.com/zh-hans/podcasts/%E4%B8%89%E4%BA%94%E7%8E%AF/no26-%E8%B7%9F%E5%A4%9A%E6%8A%93%E9%B1%BC%E7%9A%84%E7%8C%AB%E5%8A%A9%E8%81%8A%E8%81%8A%E4%BA%8C%E6%89%8B%E7%94%9F%E6%84%8F%E5%92%8C%E5%88%9B%E4%B8%9A%E6%80%81%E5%BA%A6-VlHYyDs2f1p/" target="_blank" rel="noopener">三五环</a></p>
]]></content>
  </entry>
  <entry>
    <title>哈希专题</title>
    <url>/2021/01/06/ha-xi/</url>
    <content><![CDATA[<p>用哈希表(hash table) 常见的场景是用空间换时间</p>
<ol>
<li><p>如果求解决方案或者数量，存的一般就是XXX-&gt;数量的映射，eg.<a href="#560-和为k的子数组">560.</a></p>
</li>
<li><p>如果求的是最长最短等性质 一般存的就是XXX-&gt;下标的映射 <a href="#525.连续数组">525.连续数组</a></p>
</li>
</ol>
<a id="more"></a>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a>560. 和为K的子数组</h3><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">原题链接</a></p>
<p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数</p>
<p>一开始拿到这个题目,想到通过双指针找连续子序列和的方法来做,但是这个题目还是不一样的.<br>但是之前的题目是</p>
<blockquote>
<p>输入一个正数s，打印出所有和为s的连续<strong>正数序列</strong>（至少含有两个数）。<br>例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1～5、4～6和7～8。</p>
</blockquote>
<p>这里有明显的单调性,当移动 i 时,如果此时sum&gt;k,那么就只能够向右移动j,所以我们才能够用双指针来做!!!</p>
<p>一个感悟:题目做多了容易将很多细微的差别搞混了,同时也很容易乱用方法,没有别的办法,多总结.</p>
<p>首先看一下暴力做法<br>两重循环,预处理一下前缀和</p>
<p>为什么能优化，起始这个最开始的想法来自于<code>lc2.sum2</code> 通过hash 空间换时间 来查找之前出现元素的个数</p>
<p>今天学习了一个更加巧妙的方法 前缀和+哈希</p>
<p>具体思路:<br>我们很熟悉了 如何去求一段区间和 [l,r]=s[r]-s[l-1]</p>
<p>我们现在需要求的是和为k的区间个数<code>cnt</code>,如果我们将右区间和<code>sum</code>固定 那么<code>cnt==sum-k</code>的个数</p>
<p>通过哈希表来存储这样一个键值对{前缀和,出现次数个数}</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span> &gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//初始前缀和等于0的子串个数为1</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            sum+=c;</span><br><span class="line">            res+=<span class="built_in">map</span>[sum-k];</span><br><span class="line">            <span class="built_in">map</span>[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="594-最长和谐子序列"><a href="#594-最长和谐子序列" class="headerlink" title="594. 最长和谐子序列"></a>594. 最长和谐子序列</h3><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</p>
<p>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<hr>
<p>解法1.两次扫描</p>
<p>思路:</p>
<ul>
<li>hash 统计每个数字出现次数</li>
<li>如果 num+1 在哈希中, 取max(res,hash[num]+hash[num+1])</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums) hash[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.count(c+<span class="number">1</span>)) res=max(res,hash[c]+hash[c+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>解法2. 单次扫描</p>
<p>思路</p>
<p>在之前的基础上改进，假设遍历到数字c,查找哈希表 统计<code>c+1</code>，<code>c-1</code>出现次数，取结果较大值</p>
<p>这个思路可行在于 ，把问题转化为了以ith结尾的数字c 其最长和谐子序列长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            hash[c]++;</span><br><span class="line">            <span class="keyword">if</span>(hash.count(c+<span class="number">1</span>)) res=max(res,hash[c]+hash[c+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(hash.count(c<span class="number">-1</span>)) res=max(res,hash[c]+hash[c<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a>205. 同构字符串</h3><h4 id="解法1-hash统计第一次出现的字符位置"><a href="#解法1-hash统计第一次出现的字符位置" class="headerlink" title="解法1.hash统计第一次出现的字符位置"></a>解法1.hash统计第一次出现的字符位置</h4><h4 id="解法2-双射"><a href="#解法2-双射" class="headerlink" title="解法2.双射"></a>解法2.双射</h4><p>两个哈希表存char-&gt;char<br>我们要判断字母之间是否一一对应，即判断 ss 中的相同字母是否对应到 tt 中的相同字母，且 tt 中的相同字母是否对应到 ss 中的相同字母。</p>
<p>我们用两个哈希表分别存储 ss 到 tt 和 tt 到 ss 的映射关系。<br>然后从前往后扫描字符串，判断相同字符是否都映射到相同字符。</p>
<p>时间复杂度分析：哈希表的插入、查找操作的时间复杂度是 O(1)，两个字符串均只扫描一遍，所以总时间复杂度是 O(n)。</p>
<h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a>290. 单词规律</h3><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>思路同<a href="#205-同构字符串">lc205</a> 一样 ,两种方法都可以</p>
<ol>
<li>哈希表存字符(单词)第一次出现的位置</li>
<li>哈希表分别存 单词-&gt;字符 字符-&gt;单词映射关系</li>
</ol>
<p>这里新学到了一点 利用<code>stringstream</code>将”dog cat cat dog” 处理成vector<string></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">raw</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="keyword">while</span> (raw &gt;&gt; <span class="built_in">line</span>) strs.push_back(<span class="built_in">line</span>);</span><br></pre></td></tr></table></figure>

<p>完整代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;line) vec.push_back(line);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; hash1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">char</span>&gt; hash2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pattern.size()!=vec.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pattern.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hash1.count(pattern[i])) hash1[pattern[i]]=vec[i];</span><br><span class="line">            <span class="keyword">if</span>(!hash2.count(vec[i]))  hash2[vec[i]]=pattern[i];</span><br><span class="line">            <span class="keyword">if</span>(hash1[pattern[i]]!=vec[i]||hash2[vec[i]]!=pattern[i]) <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.acwing.com/solution/content/335/" target="_blank" rel="noopener">https://www.acwing.com/solution/content/335/</a></p>
<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p>
<p>面试题经常考</p>
<h4 id="解法1-hash-sort"><a href="#解法1-hash-sort" class="headerlink" title="解法1.hash+sort"></a>解法1.hash+sort</h4><p>这个思路很直接</p>
<ul>
<li>先用hash table 统计词频</li>
<li>将hash 转化为vector 进行排序(降序)</li>
<li>返回前k个元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums) <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:<span class="built_in">map</span>) vec.push_back(&#123;c.second,c.first&#125;);</span><br><span class="line">        sort(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),greater&lt;pii&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            res.push_back(vec[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法2-hash-优先队列"><a href="#解法2-hash-优先队列" class="headerlink" title="解法2. hash+优先队列"></a>解法2. hash+优先队列</h4><ul>
<li><p>topk （前k大）用小根堆，维护堆大小不超过 k 即可。每次压入堆前和堆顶元素比较，如果比堆顶元素还小，直接扔掉，否则压入堆。检查堆大小是否超过 k，如果超过，弹出堆顶。复杂度是<code>nlogk</code></p>
</li>
<li><p>避免使用大根堆，因为你得把所有元素压入堆，复杂度是 nlogn，而且还浪费内存。如果是海量元素，那就挂了。<br>[</p>
</li>
</ul>
<p><strong>求前 k 大，用小根堆，求前 k 小，用大根堆</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) hash[x] ++;</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,greater&lt;pii&gt;&gt; qu; <span class="comment">//建立小根堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:hash)&#123;</span><br><span class="line">            qu.push(&#123;c.second,c.first&#125;);</span><br><span class="line">            <span class="keyword">if</span>(qu.<span class="built_in">size</span>()&gt;k) qu.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(qu.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.push_back(qu.top().second);</span><br><span class="line">            qu.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="面试题50-第一个只出现一次的字符"><a href="#面试题50-第一个只出现一次的字符" class="headerlink" title="面试题50. 第一个只出现一次的字符"></a>面试题50. 第一个只出现一次的字符</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p>
<p>这个算是旧题重写</p>
<p>一下还没转过来，老想着hash 无序呀，怎么找第一个出现次数为1的字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s) <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s) <span class="keyword">if</span>(<span class="built_in">map</span>[c]==<span class="number">1</span>) <span class="keyword">return</span> c;  <span class="comment">//hash虽然无序  按照字符串的顺序遍历就ok，map是无序的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="增强版-字节流动态查找-tag-queue"><a href="#增强版-字节流动态查找-tag-queue" class="headerlink" title="增强版 字节流动态查找  [-tag queue]"></a>增强版 字节流动态查找  [-tag queue]</h4><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。</p>
<p>例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是’g’。</p>
<p>当从该字符流中读出前六个字符<code>”google”</code>时，第一个只出现一次的字符是’l’。</p>
<p>如果当前字符流没有存在出现一次的字符返回#字符。</p>
<p><strong>时间复杂度</strong> 均摊O(n)</p>
<p>思路<br>为什么能想到?<br>如果还是按照上上一题的做法,那么每查找一次就是O(n)，查找n次就是O(n^2)<br>于是我们需要优化, 一般这种优化不是双指针利用单调性就是用一些特殊的数据结构比如单调队列，单调栈</p>
<p>这道题目能用到单调性的原因:</p>
<p>假设我们有一个指针<code>index</code>指向第一次出现次数为1的元素,<strong>当我们再插入元素,index 只可能往后走，不可能往前走</strong><br>反正法: 如果index 可以往前走， 根据其含义,就违背了<code>index</code>指向的当前位置为第一次出现次数为1的元素</p>
<p>用一个hash 记录出现的次数<br>queue<char> 按照流的顺序来保存<br>维护这样一个队列: 队首就是第一次出现一次的字符,一旦不满足要求,就pop队首</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;<span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; qu;</span><br><span class="line"><span class="comment">//动态插入维护一个queue</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(++<span class="built_in">map</span>[ch]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(qu.<span class="built_in">size</span>()&amp;&amp;<span class="built_in">map</span>[qu.front()]&gt;<span class="number">1</span>) qu.pop(); <span class="comment">//队列不为空&amp;&amp;队首元素出现的次数&gt;1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> qu.push(ch);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a>525. 连续数组</h3><p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）</p>
<p>思路</p>
<ol>
<li>将问题转化为求区间和为0 的最长值： 具体做法 遇到0加-1</li>
<li>开一个哈希表存储前缀和sum-&gt;index 映射 ,即第一次出现这个前缀和的下标</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//问题在转化为 求最长连续子数组和为0</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">// 前缀和-&gt;首次出现下标</span></span><br><span class="line">        <span class="built_in">map</span>[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            s+=nums[i]?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.count(s)) res=<span class="built_in">max</span>(res,i-<span class="built_in">map</span>[s]); <span class="comment">//</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">map</span>[s]=i; <span class="comment">//如果不存在说明这个前缀和第一次出现 记录下</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




<h3 id="349-350-数组交集"><a href="#349-350-数组交集" class="headerlink" title="349/350. 数组交集"></a>349/350. 数组交集</h3><p>349.给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1:</p>
<p>输入:<code>nums1 = [1,2,2,1], nums2 = [2,2]</code><br>输出: [2]<br>350 输出[2,2]</p>
<p>选择合适的数据结构是解决问题的关键</p>
<p>对于349. 输出的每个元素是唯一的 数据结构用<code>unordered_set</code></p>
<p>350 输出的元素可能重复, 选用<code>unordered_multiset</code><br>注意在<code>mutli</code>里面如何删除一个特定的元素，而不是将其所有都删除</p>
<p>迭代器删除特定的元素， 就好像string 里面的erase() 可以范围删除(输入迭代器范围),也可以删除单个元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums1) st.insert(c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.count(c))&#123;</span><br><span class="line">                <span class="keyword">auto</span> it=st.<span class="built_in">find</span>(c); <span class="comment">//查找迭代器</span></span><br><span class="line">                res.push_back(c);</span><br><span class="line">                st.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h3 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a>187. 重复的DNA序列</h3><p>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来查找 DNA 分子中所有出现超过一次的 10 个字母长的序列（子串）。</p>
<p>示例：</p>
<p>输入：<code>s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</code><br>输出：<code>[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]</code><br><strong>思路</strong><br>遍历字符串s, 提取长度为10的子串str,依次存到哈希表中,如果 <code>++hash[str]==2</code> 就找到了一个满足要求的子串</p>
<p>这个处理真的很妙,++res==2 找到了满足要求的解，但是又不会重复将解push，省去了后面去重.</p>
<h3 id="554-砖墙"><a href="#554-砖墙" class="headerlink" title="554. 砖墙"></a>554. 砖墙</h3><p>这个题目就绕了一点,需要做一下问题的转化 将穿过最少砖块转化为最大砖块重合</p>
<p>还有一点特别要<strong>注意你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</strong></p>
<p><strong>思路</strong><br>对砖块的每一行, 求到当前砖块的前缀和,哈希表存前缀和-&gt;出现次数 映射<br>前缀和出现次数最多表示每一行在当前位置重合的砖块最多</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastBricks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; wall)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;<span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> blocks:wall)&#123;</span><br><span class="line">            <span class="keyword">int</span> s=<span class="number">0</span>; <span class="comment">//求每一行的前缀和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;blocks.<span class="built_in">size</span>();i++)&#123; <span class="comment">//i+1&lt;size 避免沿着墙的右边缘</span></span><br><span class="line">                s+=blocks[i];</span><br><span class="line">                res=<span class="built_in">max</span>(res,++<span class="built_in">map</span>[s]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wall.<span class="built_in">size</span>()-res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></h3><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p>
<ul>
<li>为啥<code>hash[0]=-1</code></li>
</ul>
<p>这是用哈希表存储val-&gt;index 套路做法</p>
<p>原因在于  区间<code>[l,r]</code>和为<code>s[r]-s[l-1]</code>  当<code>r==l==0</code>  即  <code>nums[0]=s[0]-s[-1]</code>  所以有<code>s[-1]=0</code> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash; <span class="comment">// state code-&gt;index</span></span><br><span class="line">        hash[<span class="number">0</span>]=<span class="number">-1</span>; </span><br><span class="line">        <span class="built_in">string</span> nums=<span class="string">"aeiou"</span>;</span><br><span class="line">        <span class="keyword">int</span> st=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==nums[j])&#123;</span><br><span class="line">                    st^=<span class="number">1</span>&lt;&lt;j;<span class="comment">//异或 1^1=0 0^1=1 不进位加法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// cout&lt;&lt;"i:"&lt;&lt;i&lt;&lt;"  state code:"&lt;&lt;st&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(hash.count(st))  res=max(res,i-hash[st]); <span class="comment">// 表示区间段 st为0 即元音出现次数为偶数</span></span><br><span class="line">            <span class="keyword">else</span> hash[st]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>回忆围棋</title>
    <url>/2021/01/23/hui-yi-wei-qi/</url>
    <content><![CDATA[<p>回顾到今年三月看到的一篇文章<a href="https://weibo.com/ttarticle/p/show?id=2309404475844541153439#_0" target="_blank" rel="noopener">《<strong>一个时代的退隐——李世石退役的纪念</strong> 》</a>，作者李喆疫情期间困在武汉，作为国手在微博上写一些自己的随想，围棋见解。我非常喜欢李的文字，优美又充满哲学般的深思。比如下面这段</p>
<a id="more"></a>

<blockquote>
<p>“毫无疑问，李世石是一位创造感极强的棋士，他的棋谱中充斥着将棋局引入陌生领域的激情，时而选择在悬崖峭壁上跳跃翻腾，时而自降于黑暗地底寻一点灵明，不满足于在既定的航线上平稳前行，宁愿冒着暗礁冰山的风险驶向前所未见的风景。因此当他在退役前夕说出 “我将围棋视为艺术，我心中的围棋是两个人齐心协力创造一部作品” 时，我们也就不应感到丝毫意外了。而他的退役，与韩国棋院的不和解当然是一种外力，而内在更深刻的原因，还是在于围棋 AI 对他作为棋士的创造感的冲击。”</p>
</blockquote>
<p>我很小就和围棋接触过，甚至还短暂下过围棋，起因是家里面有一个很大的玻璃围棋，晶莹透亮，最开始是作为我无聊玩具，后来长大了能认字，发现家里书架上为数不多的书中有好几本围棋相关的书，一本是讲南朝鲜传奇棋手曹薰铉的围棋生涯，还有几本小册子讲围棋定式之类的。我爸年轻时代有一股围棋之风， 吴清源，聂卫平那些人当时都是神话般的人物。</p>
<p>吴清源这个名字我在锵锵三人行经常听到，原因是他们请的嘉宾江铸久妻子是吴清源弟子，吴被称作“昭和棋圣”，宇宙流下法极具观赏性，同时新布局开启了一个新的时代。有一个趣事记得很清楚，吴小时候在北京层下棋就小有名气，于是被叫去陪段祺瑞下棋，别人都让着段， 吴年少不知，沉迷围棋，赢了段，丝毫不给面子。但是段祺瑞仍然每个月给吴清源100大洋养着他，所以看来军阀也不是像书里面说的十足的恶。</p>
<p>围棋的高深我是一直没有体会到的，但是之后很长时间还是会对这个话题感兴趣，围棋少年动画片，《天龙八部》里面虚竹破珍珑棋局，吴清源的纪录片，以及现在李喆，柯洁的一些动态。说起他们两个人，简直截然不同，李的围棋成就没有柯高，但我觉得在下棋中他找到了新的世界，后来去念了哲学，关于”围棋究竟更偏向艺术还是竞技” 李肯定是偏向艺术的。柯洁打破了我对围棋选手固有的认识，印象里面棋手都是温文尔雅，强调”不显”，但是柯我很喜欢的一点就是他展现了一个人除了作为棋手，同时更多作为一个年轻人的一面，李和柯是完全不一样的，但不妨碍他们同时存在。</p>
<p><strong>shownotes</strong></p>
<p>木遥录的一期播客谈李喆写的<a href="https://farmostwood.fireside.fm/6" target="_blank" rel="noopener">《<strong>一个时代的退隐</strong> 》</a></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>套接字选项小结</title>
    <url>/2020/08/24/tao-jie-zi-xuan-xiang-xiao-jie/</url>
    <content><![CDATA[<p>总结影响网络收发包的一些套接字选项，对一些概念可能理解不对，希望大家多多指教。后面会持续更新ing。</p>
<a id="more"></a>

<p>[TOC]</p>
<h3 id="套接字属性设置"><a href="#套接字属性设置" class="headerlink" title="套接字属性设置"></a><strong>套接字属性设置</strong></h3><hr>
<p>通过setsockopt我们可以设置套接字的一些属性，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val,<span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>level</code> 参数设定的套接字属性使用范围，<code>SOL_SOCKET</code>表示用于通用套接字，<code>IPPROTO_TCP</code> 用于tcp协议，<code>IPPROTO_IP</code> 用于IP协议。</p>
<p>下表是《APUE》中给出的一些通用套接字设置选项</p>
<p><img src="https://s1.ax1x.com/2020/08/07/ahtjHI.png" alt="ahtjHI.png"></p>
<h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><blockquote>
<p>为什么需要保活?</p>
</blockquote>
<p>在tcp连接双方，建立连接之后，很长时间没有交换数据，在这种长时间没有数据交换情况下，双方不知道对方状态，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些TCP连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用TCP的保活报文来实现。</p>
<ol>
<li>探测连接的对端是否存活</li>
</ol>
<p>在应用交互的过程中，可能存在以下几种情况：</p>
<ol>
<li><p>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来 2小时再复位。</p>
</li>
<li><p>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP没有响应。服务器将不能够收到对探查的响应，并在<strong>75s</strong>后超时。服务器总共发送<strong>10个</strong>这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</p>
</li>
<li><p><strong>客户主机崩溃并已经重新启动</strong>。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。</p>
</li>
<li><p>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。</p>
</li>
</ol>
<p>​     利用保活探测功能，可以探知这种对端的意外情况，从而保证在意外发生时，可以释放半打开的TCP连接。</p>
<ol start="2">
<li><p><strong>防止中间设备因超时删除连接相关的连接表</strong></p>
<p>中间设备如防火墙等，会为经过它的数据报文建立相关的连接信息表，并为其设置一个超时时间的定时器，如果超出预定时间，某连接无任何报文交互的中间设备会将该连接信息从表中删除，在删除后，再有应用报文过来时，中间设备将丢弃该报文，从而导致应用出现异常，这个交互的过程大致如下图所示：</p>
</li>
</ol>
<p>默认情况下tcp的保活是关闭的,需要我们自己打开。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">optval = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, optlen);</span><br></pre></td></tr></table></figure>



<p><strong>全局修改探测活参数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo <span class="number">600</span> &gt; /proc/sys/net/ipv4/tcp_keepalive_time <span class="comment">//超时时间</span></span><br><span class="line">echo <span class="number">60</span> &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl <span class="comment">//探测报文发送间隔</span></span><br><span class="line">echo <span class="number">20</span> &gt; /proc/sys/net/ipv4/tcp_keepalive_probes <span class="comment">//探测报文发送次数</span></span><br></pre></td></tr></table></figure>

<p><strong>通过系统调用对单个进程修改</strong></p>
<p>对应到的几个套接字选项如下</p>
<p><strong>TCP_KEEPCNT</strong>: 对应到探测报文发送次数；</p>
<p><strong>TCP_KEEPINTVL</strong>: 探测报文发送间隔</p>
<p><strong>TCP_KEEPIDLE</strong>: 超时时间</p>
<blockquote>
<p>TCP层的保活和应用层保活对比</p>
</blockquote>
<p><code>KeepAlive</code>通过定时发送探测包来探测连接的对端是否存活， 但通常也会许多在业务层面处理的，他们之间的特点：</p>
<ul>
<li>TCP自带的<code>KeepAlive</code>使用简单，发送的数据包相比应用层心跳检测包更小，仅提供检测连接功能</li>
<li>应用层心跳包不依赖于传输层协议，无论传输层协议是TCP还是UDP都可以用</li>
<li>应用层心跳包可以定制，可以应对更复杂的情况或传输一些额外信息</li>
<li><code>KeepAlive</code>仅代表连接保持着，而心跳包往往还代表客户端可正常工作</li>
</ul>
<h3 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a><strong>SO_LINGER</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>对应的<code>val</code>是一个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">　　<span class="keyword">int</span> l_onoff; <span class="comment">//开关 0:关闭</span></span><br><span class="line">　　<span class="keyword">int</span> l_linger;<span class="comment">//延迟关闭时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个简单的使用例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">lin</span>&#123;</span><span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">setsockopt(fd,SOL_SOCKET,SO_SOCKET,&amp;lin);</span><br></pre></td></tr></table></figure>

<p>linger打开与否，以及不同时间的设置，可能导致不同的关闭结果。</p>
<p>三种断开方式：</p>
<ol>
<li>l_onoff = 0; l_linger忽略</li>
</ol>
<p>close()立刻返回，底层会将未发送完的数据发送完成后再释放资源，即优雅退出。</p>
<ol start="2">
<li>l_onoff != 0; l_linger = 0;</li>
</ol>
<p>close()立刻返回，但不会发送未发送完成的数据，而是通过一个RST包强制的关闭socket描述符，即强制退出。</p>
<ol start="3">
<li>l_onoff != 0; l_linger &gt; 0;</li>
</ol>
<p>close()不会立刻返回，内核会延迟一段时间，这个时间就由l_linger的值来决定。如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，close()会返回正确，socket描述符优雅性退出。否则，close()会直接返回错误值，未发送数据丢失，socket描述符被强制性退出</p>
<h4 id="SO-LINGER实现原理"><a href="#SO-LINGER实现原理" class="headerlink" title="SO_LINGER实现原理"></a>SO_LINGER实现原理</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> SO_LINGER:</span><br><span class="line">			<span class="keyword">if</span>(optlen&lt;<span class="keyword">sizeof</span>(ling)) &#123;</span><br><span class="line">				ret = -EINVAL;	<span class="comment">/* 1003.1g */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">...</span><br><span class="line">			<span class="keyword">if</span> (!ling.l_onoff)<span class="comment">//没有打开linger</span></span><br><span class="line">				sock_reset_flag(sk, SOCK_LINGER);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> (BITS_PER_LONG == <span class="number">32</span>)</span><br><span class="line">				<span class="keyword">if</span> (ling.l_linger &gt;= MAX_SCHEDULE_TIMEOUT/HZ)</span><br><span class="line">					sk-&gt;sk_lingertime = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">					sk-&gt;sk_lingertime = ling.l_linger * HZ;<span class="comment">//设置linger时间</span></span><br><span class="line">				sock_set_flag(sk, SOCK_LINGER);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>程序调用函数close()关闭套接口时，与此相关的函数调用路径如下：<code>sys_close() -&gt; filp_close() -&gt; fput() -&gt; __fput() -&gt; sock_close() -&gt; sock_release() -&gt; inet_release() -&gt; tcp_close()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_release</span><span class="params">(struct socket *sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk) &#123;</span><br><span class="line">		<span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Applications forget to leave groups before exiting */</span></span><br><span class="line">		ip_mc_drop_socket(sk);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If linger is set, we don't return until the close</span></span><br><span class="line"><span class="comment">		 * is complete.  Otherwise we return immediately. The</span></span><br><span class="line"><span class="comment">		 * actually closing is done the same either way.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If the close is due to the process exiting, we never</span></span><br><span class="line"><span class="comment">		 * linger..</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		timeout = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp;</span><br><span class="line">		    !(current-&gt;flags &amp; PF_EXITING))</span><br><span class="line">			timeout = sk-&gt;sk_lingertime;</span><br><span class="line">		sock-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">		sk-&gt;sk_prot-&gt;<span class="built_in">close</span>(sk, timeout);<span class="comment">//对应到tcp_close</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tcp-close"><a href="#tcp-close" class="headerlink" title="tcp_close()"></a><code>tcp_close()</code></h4><p>当一个套接口正在或已经被关闭，如果在其接收队列有未读数据（不管是在关闭前就已收到的，或者还是在关闭后新到达的），那么此时就需给对端发送一个RST数据包,对应到下面一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data_was_unread) &#123;<span class="comment">//接受区还有数据没有被读完</span></span><br><span class="line">	<span class="comment">/* Unread data was tossed, zap the connection. */</span></span><br><span class="line">	NET_INC_STATS_USER(LINUX_MIB_TCPABORTONCLOSE);</span><br><span class="line">	tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">	tcp_send_active_reset(sk, GFP_KERNEL);<span class="comment">//发送RST</span></span><br></pre></td></tr></table></figure>



<p>如果linger结构体的字段<code>l_onoff</code>为1,而<code>l_linger</code>为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp; !sk-&gt;sk_lingertime) &#123;</span><br><span class="line">		<span class="comment">/* Check zero linger _after_ checking for unread data. */</span></span><br><span class="line">		sk-&gt;sk_prot-&gt;<span class="built_in">disconnect</span>(sk, <span class="number">0</span>); <span class="comment">//直接丢掉所有接收数据并且直接断开连接，具体也就是发送RST数据包，清空相关接收队列</span></span><br><span class="line">		NET_INC_STATS_USER(LINUX_MIB_TCPABORTONDATA);</span><br></pre></td></tr></table></figure>

<p>下面就是对应正常四次挥手关闭流程，</p>
<p>先调用函数<code>tcp_close_state()</code>切换状态，判断是否需要发送FIN数据包（eg.如果当前还处于<code>TCP_SYN_SENT</code>状态，连接尚未完全建立，自然就不用发送FIN数据包），如果需要发送FIN数据包则调用<code>tcp_send_fin()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">....... </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tcp_close_state(sk)) &#123;</span><br><span class="line">		tcp_send_fin(sk);</span><br><span class="line">	&#125;</span><br><span class="line"> sk_stream_wait_close(sk, timeout);</span><br></pre></td></tr></table></figure>

<h4 id="tcp-send-fin"><a href="#tcp-send-fin" class="headerlink" title="tcp_send_fin"></a><strong>tcp_send_fin</strong></h4><p>深入到发送fin内部来看，</p>
<p>如果发送队列还有数据，那么直接将取出末尾数据包，设置FIN。否则分配一个新的skb,最后调用函数<code>__tcp_push_pending_frames() -&gt; tcp_write_xmit()</code>发送数据包。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_send_fin</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = <span class="title">skb_peek_tail</span>(&amp;<span class="title">sk</span>-&gt;<span class="title">sk_write_queue</span>);</span> <span class="comment">//取出末尾数据包</span></span><br><span class="line">	<span class="keyword">int</span> mss_now;</span><br><span class="line">	</span><br><span class="line">	mss_now = tcp_current_mss(sk, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_send_head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		TCP_SKB_CB(skb)-&gt;flags |= TCPCB_FLAG_FIN;<span class="comment">//</span></span><br><span class="line">		TCP_SKB_CB(skb)-&gt;end_seq++;</span><br><span class="line">		tp-&gt;write_seq++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Socket is locked, keep trying until memory is available. */</span></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			skb = alloc_skb(MAX_TCP_HEADER, GFP_KERNEL);</span><br><span class="line">			<span class="keyword">if</span> (skb)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in">yield</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Reserve space for headers and prepare control bits. */</span></span><br><span class="line">		skb_reserve(skb, MAX_TCP_HEADER);</span><br><span class="line">		skb-&gt;csum = <span class="number">0</span>;</span><br><span class="line">		TCP_SKB_CB(skb)-&gt;flags = (TCPCB_FLAG_ACK | TCPCB_FLAG_FIN);</span><br><span class="line">		TCP_SKB_CB(skb)-&gt;sacked = <span class="number">0</span>;</span><br><span class="line">		skb_shinfo(skb)-&gt;tso_segs = <span class="number">1</span>;</span><br><span class="line">		skb_shinfo(skb)-&gt;tso_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */</span></span><br><span class="line">		TCP_SKB_CB(skb)-&gt;seq = tp-&gt;write_seq;</span><br><span class="line">		TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + <span class="number">1</span>;</span><br><span class="line">		tcp_queue_skb(sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line">	__tcp_push_pending_frames(sk, tp, mss_now, TCP_NAGLE_OFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sk-stream-wait-close"><a href="#sk-stream-wait-close" class="headerlink" title="sk_stream_wait_close"></a><strong>sk_stream_wait_close</strong></h4><p>这是一个阻塞等待函数，参数timeout指示了等待的时间（单位为时钟滴答）。</p>
<p>while循环的退出点有两处</p>
<ul>
<li><p>当前进程收到信号或时间超时（timeout）</p>
</li>
<li><p>sk_wait_event()</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sk_stream_wait_close</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">		DEFINE_WAIT(wait);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			prepare_to_wait(sk-&gt;sk_sleep, &amp;wait,</span><br><span class="line">					TASK_INTERRUPTIBLE);</span><br><span class="line">			<span class="keyword">if</span> (sk_wait_event(sk, &amp;timeout, !sk_stream_closing(sk)))<span class="comment">// 退出点1</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">while</span> (!signal_pending(current) &amp;&amp; timeout); <span class="comment">//退出点2</span></span><br><span class="line">		finish_wait(sk-&gt;sk_sleep, &amp;wait);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此我们结合源码大致搞清楚了SO_LINGER选项的设置对TCP连接关闭的影响。</p>
<h3 id="SO-REUSEPORT-amp-amp-SO-REUSEADDR"><a href="#SO-REUSEPORT-amp-amp-SO-REUSEADDR" class="headerlink" title="SO_REUSEPORT&amp;&amp;SO_REUSEADDR"></a>SO_REUSEPORT&amp;&amp;SO_REUSEADDR</h3><p>SO_REUSEADDR和SO_REUSEPORT主要是影响socket绑定ip和port的成功与否。有几点绑定规则主要注意下<br> <strong>规则1</strong>：socket可以指定绑定到一个特定的ip和port，例如绑定到192.168.0.11:9000上；<br> <strong>规则2</strong>：同时也支持通配绑定方式，即绑定到本地”any address”（例如一个socket绑定为 0.0.0.0:21，那么它同时绑定了所有的本地地址）；<br> <strong>规则3</strong>：默认情况下，任意两个socket都无法绑定到相同的源IP地址和源端口</p>
<h4 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a><strong>SO_REUSEADDR</strong></h4><p><strong>1、改变了通配绑定时处理源地址冲突的处理方式</strong></p>
<p>so_reuseaddr作用在于允许一个socket 绑定了统配地址+port， 另外一个套接字绑定具体地址+相同端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SO_REUSEADDR       socketA        socketB       Result</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">  ON&#x2F;OFF       192.168.0.1:21   192.168.0.1:21    Error (EADDRINUSE)</span><br><span class="line">  ON&#x2F;OFF       192.168.0.1:21      10.0.0.1:21    OK</span><br><span class="line">  ON&#x2F;OFF          10.0.0.1:21   192.168.0.1:21    OK</span><br><span class="line">   OFF             0.0.0.0:21   192.168.1.0:21    Error (EADDRINUSE)</span><br><span class="line">   OFF         192.168.1.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br><span class="line">   ON              0.0.0.0:21   192.168.1.0:21    OK</span><br><span class="line">   ON          192.168.1.0:21       0.0.0.0:21    OK</span><br><span class="line">  ON&#x2F;OFF           0.0.0.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br></pre></td></tr></table></figure>

<p><strong>2、改变了系统对处于TIME_WAIT状态的socket绑定地址的处理</strong></p>
<p>处于time-wait 状态下的套接字需要等待2msl 才能重新使用其绑定的端口与地址，设置了so_reuseaddr没有此限制</p>
<h4 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a><strong>SO_REUSEPORT</strong></h4><ol>
<li>允许将多个socket绑定到相同的地址和端口，前提每个socket绑定前都需设置</li>
<li>linux内核在处理SO_REUSEPORT socket的集合时，进行了简单的负载均衡操作，即对于UDP socket，内核尝试平均的转发数据报，对于TCP监听socket，内核尝试将新的客户连接请求(由accept返回)平均的交给共享同一地址和端口的socket(监听socket)。</li>
</ol>
<p>通过设置套接字的SO_REUSEPORT能够用来解决epoll_wait存在的惊群问题，把监听描述符添加到epoll监听事件，多个子进程都epoll_wait阻塞等待，由内核来做负载均衡，这样就避免了当实践发生时同时惊醒多个工作进程，添加了SO_REUSEPORT的模型如下:</p>
<img src="https://s1.ax1x.com/2020/08/13/azw6DU.png" alt="azw6DU.png" style="zoom:80%;" />




<h3 id="TCP-CORK"><a href="#TCP-CORK" class="headerlink" title="TCP_CORK"></a>TCP_CORK</h3><p>tcp_cork与tcp_nodelay 以及nagle 容易搞混，这里我们结合他们的应用场景以及代码来理清楚。</p>
<p><strong>nagle算法</strong></p>
<p>大致思想：</p>
<p>为了提高网络吞吐量，如果发送小数据包，那么20字节包头的负担太大，于是通过将小数据包累积到一个MSS长度再发出来。</p>
<p>同样影响小包发送的套接字选项:<strong>TCP_NODELAY，TCP_CORK</strong></p>
<p>Nagle算法的<strong>基本定义</strong>是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</p>
<p>Nagle算法的规则（tcp_output.c文件里tcp_nagle_check函数注释）：</p>
<p>（1）如果包长度达到MSS，则允许发送；</p>
<p>（2）如果该包含有FIN，则允许发送；</p>
<p>（3）设置了TCP_NODELAY选项，则允许发送；</p>
<p>（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；</p>
<p>（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。</p>
<p><code>TCP_NODELAY</code>是禁用Nagle算法，即数据包立即发送出去，而选项TCP_CORK与此相反，可以认为它是Nagle算法的进一步增强，即阻塞数据包发送，具体点说就是：TCP_CORK选项的功能类似于在发送数据管道出口处插入一个“塞子”，使得发送数据全部被阻塞，直到取消TCP_CORK选项（即拔去塞子）或被阻塞数据长度已超过MSS才将其发送出去。举个对比示例，比如收到接收端的ACK确认后，Nagle算法可以让当前待发送数据包发送出去，即便它的当前长度仍然不够一个MSS，但选项TCP_CORK则会要求继续等待。</p>
<h4 id="TCP-CORK的应用场景"><a href="#TCP-CORK的应用场景" class="headerlink" title="TCP_CORK的应用场景"></a>TCP_CORK的应用场景</h4><p>TCP_CORK选项的作用主要是阻塞小数据发送，服务器处理一个客户端请求，发送的响应数据包括响应头和响应体两部分，利用TCP_CORK选项就能让这两部分数据一起发送。</p>
<p>按照之前的分析，设置了CORK之后，有几种可能数据会被发送</p>
<ul>
<li>通过setoptsock关闭TCP_CORK这个选项。</li>
<li>socket阻塞的数据大于MSS。</li>
<li>自从堵上塞子写入第一个字节开始，已经经过200ms。</li>
<li>socket被关闭。</li>
</ul>
<p>一旦满足上面的任何一个条件，TCP就会将数据发送出去。对于Server来说，发送HTTP响应既要发送尽量少的segment，同时又要保证低延迟，那么需要在写完数据后显式取消设置<code>TCP_CORK</code>选项，让数据立即发送出去：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> state = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, &amp;state, <span class="keyword">sizeof</span>(state)); <span class="comment">//开启cork</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(http_resp_header);</span><br><span class="line">sendfile(sockfd, fd, &amp;off, len); <span class="comment">//阻塞</span></span><br><span class="line"></span><br><span class="line">state = <span class="number">0</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_CORK, &amp;state, <span class="keyword">sizeof</span>(state)); <span class="comment">//关闭cork</span></span><br></pre></td></tr></table></figure>





<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.lenky.info/archives/2013/02/2220" target="_blank" rel="noopener">Socket选项系列之SO_LINGER</a></p>
<p><a href="http://senlinzhan.github.io/2017/02/10/Linux的TCP-CORK/" target="_blank" rel="noopener">Nagle 算法与 TCP socket 选项 TCP_CORK</a></p>
<p><a href="https://juejin.im/post/6844903878819840008" target="_blank" rel="noopener">https://juejin.im/post/6844903878819840008</a></p>
<p><a href="https://blog.biezhi.me/2017/08/talk-tcp-keepalive.html" target="_blank" rel="noopener">https://blog.biezhi.me/2017/08/talk-tcp-keepalive.html</a></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串专题</title>
    <url>/2021/01/06/zi-fu-chuan/</url>
    <content><![CDATA[<p>校招期间刷题做的一些笔记，主要配合leetcode, acwing平台使用。<br>这些题目是20年疫情期间一个一个做的，一开始啥也不会，acwing的一些视频对我算法学习帮助很大。<br>最近在回顾很多东西，发的日记，印象笔记里面的笔记，这些算法题现在没啥兴趣做了，但是我觉得以后有一天总还是要用得上的。</p>
<a id="more"></a>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h3><p>主要思想：滑动窗口，双指针</p>
<p>数据结构：set，map 可以通过map优化性能，更加快速更新左边界</p>
<p>使用set 通过insert(),erease()来更新集合元素</p>
<h4 id="方法1-set"><a href="#方法1-set" class="headerlink" title="方法1.set"></a>方法1.set</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">set</span>.count(s[i])) &#123;</span><br><span class="line">                <span class="built_in">set</span>.erase(s[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>.insert(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(ans&lt;<span class="built_in">set</span>.<span class="built_in">size</span>()) ans=<span class="built_in">set</span>.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2-map"><a href="#方法2-map" class="headerlink" title="方法2.map"></a>方法2.map</h4><p>参考acwing 提供了一种类似写法, 用哈希表存字符出现次数，当字符个数大于2即出现重复字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; ma;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    ma[s[i]]++;</span><br><span class="line">    <span class="keyword">while</span>(s[i]&gt;<span class="number">1</span>) ma[s[j++]]--;</span><br><span class="line">    res=<span class="built_in">max</span>(res,j-i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="CountandSay"><a href="#CountandSay" class="headerlink" title="CountandSay"></a>CountandSay</h3><p>是一道老题目了<br>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<ul>
<li><ol>
<li>1</li>
</ol>
</li>
<li><ol start="2">
<li>11</li>
</ol>
</li>
<li><ol start="3">
<li>21</li>
</ol>
</li>
<li><ol start="4">
<li>1211</li>
</ol>
</li>
<li><ol start="5">
<li>111221</li>
</ol>
</li>
</ul>
<ul>
<li><p>1 被读作 “one 1” (“一个一”) , 即 11。</p>
</li>
<li><p>11 被读作 “two 1s” (“两个一”）, 即 21。</p>
</li>
<li><p>21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。</p>
</li>
<li><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p>
</li>
</ul>
<p>解题思路：</p>
<ul>
<li>外层按照给定层次n 迭代</li>
<li>内层对当前层次处理每一个字符，统计其个数</li>
</ul>
<p>要点：</p>
<ul>
<li>数字转化为字符 通过加‘0’ 或者 to_string</li>
<li>边界处理<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"1"</span>);</span><br><span class="line">       <span class="built_in">string</span> res=<span class="string">"1"</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="built_in">string</span> buf;</span><br><span class="line">           <span class="keyword">int</span> str_len=res.<span class="built_in">size</span>();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str_len;j++)&#123;</span><br><span class="line">               <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">while</span>(res[j]==res[j+<span class="number">1</span>]&amp;&amp;j+<span class="number">1</span>&lt;str_len)&#123;</span><br><span class="line">                   j++;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;</span><br><span class="line">               buf.push_back(count+<span class="string">'0'</span>);</span><br><span class="line">               buf.push_back(res[j]);</span><br><span class="line">           &#125;</span><br><span class="line">           res=buf;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>考点：<br> 无序字符串排序+哈希表<br> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; hash_map;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> str: strs)&#123;</span><br><span class="line">          <span class="built_in">string</span> key=str;</span><br><span class="line">          sort(key.<span class="built_in">begin</span>(),key.<span class="built_in">end</span>());</span><br><span class="line">          hash_map[key].push_back(str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> c: hash_map)&#123;</span><br><span class="line">          res.push_back(c.second);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="151-翻转字符串中的单词-时间O-n-空间O-1"><a href="#151-翻转字符串中的单词-时间O-n-空间O-1" class="headerlink" title="151. 翻转字符串中的单词 时间O(n) 空间O(1)"></a>151. 翻转字符串中的单词 时间O(n) 空间O(1)</h3><p>给定一个字符串，逐个翻转字符串中的每个单词。<br>比如说：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p>
<p>如果是翻转整个的字符串呢？</p>
<p>解题思路：</p>
<ul>
<li>先翻转字符串中的每一个单词</li>
<li>在翻转整个字符串</li>
</ul>
<p>技能点</p>
<ul>
<li>遍历去除字符串开始空格</li>
<li>从字符串提取单个单词，处理，注意index的边界判定</li>
<li>思想in-place 替代字符串<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s[i]==<span class="string">' '</span>) i++; <span class="comment">//去除连续空格</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()==i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span>(s[j]!=<span class="string">' '</span>&amp;&amp;j&lt;s.<span class="built_in">size</span>())j++;</span><br><span class="line">            reverse(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">begin</span>()+j);</span><br><span class="line">            <span class="keyword">if</span>(index) s[index++]=<span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j) s[index++]=s[i++]; <span class="comment">// 这个很巧妙 in-place </span></span><br><span class="line">        &#125;</span><br><span class="line">        s.erase(s.<span class="built_in">begin</span>()+index,s.<span class="built_in">end</span>()); <span class="comment">// 可能有多余空格情况</span></span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>联想</strong><br>这个题目起始也可以用来去除字符串中的空格，面试时候经常考察。<br>要求</p>
<ol>
<li>去除字符串开始所有空格，中间的连续空格只保存一个，末尾的空格全部去除<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    <span class="keyword">while</span>(s[i]==<span class="string">' '</span>) i++;</span><br><span class="line">    <span class="keyword">if</span>(i==s.<span class="built_in">size</span>()) <span class="keyword">break</span>; <span class="comment">//为了防止已经到末尾加上空格</span></span><br><span class="line">    <span class="keyword">if</span>(index) s[index++]=<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i]!=<span class="string">' '</span>)s[index++]=s[i++];</span><br><span class="line">&#125;</span><br><span class="line">s.erase(k);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="165-版本号比较"><a href="#165-版本号比较" class="headerlink" title="165. 版本号比较"></a>165. 版本号比较</h3><p>难点: </p>
<ul>
<li>前导0的处理</li>
</ul>
<p>提取符合特定要求的子字符串模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j=i;</span><br><span class="line"><span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>()&amp;&amp;s[j]!=<span class="string">'.'</span>) j++;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cplusplus.com/reference/cstdlib/atoi/?kw=atoi" target="_blank" rel="noopener">atoi() 函数用法</a><br><a href="http://www.cplusplus.com/reference/string/string/substr/" target="_blank" rel="noopener">substring()用法</a><br>完整参考代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s1.<span class="built_in">size</span>()|| j&lt;s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i,y=j;</span><br><span class="line">            <span class="keyword">while</span>(x&lt;s1.<span class="built_in">size</span>()&amp;&amp;s1[x]!=<span class="string">'.'</span>) x++;</span><br><span class="line">            <span class="keyword">while</span>(y&lt;s2.<span class="built_in">size</span>()&amp;&amp;s2[y]!=<span class="string">'.'</span>) y++;</span><br><span class="line">            <span class="keyword">int</span> a=(x==i)?<span class="number">0</span>:atoi(s1.substr(i,x-i).c_str());</span><br><span class="line">            <span class="keyword">int</span> b=(y==j)?<span class="number">0</span>:atoi(s2.substr(j,y-j).c_str());</span><br><span class="line">            i=x+<span class="number">1</span>; <span class="comment">//jump .</span></span><br><span class="line">            j=y+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>两个字符串，两个数组通过<code>while(s1.size()||s2.size())</code>来控制循环流</p>
<h3 id="929-独特的电子邮件地址"><a href="#929-独特的电子邮件地址" class="headerlink" title="929. 独特的电子邮件地址"></a>929. 独特的电子邮件地址</h3><p>思路：</p>
<ul>
<li>分离本地和域名</li>
<li>按照+，.规则来处理本地</li>
<li>链接成新的邮件地址 存入到unordered_set<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; hash_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> email:emails)&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(email[i]!=<span class="string">'@'</span>) i++;</span><br><span class="line">            <span class="built_in">string</span> local =email.substr(<span class="number">0</span>,i);</span><br><span class="line">            <span class="built_in">string</span> prefix=email.substr(i+<span class="number">1</span>,email.<span class="built_in">size</span>()-i);</span><br><span class="line">            <span class="built_in">string</span> newlocal;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c: local)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">'+'</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(c!=<span class="string">'.'</span>) newlocal+=c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> s=newlocal+<span class="string">'@'</span>+prefix;</span><br><span class="line">            hash_set.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash_set.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
小技巧</li>
<li>substr() 默认位置到 end() 因此在提取domin 的时候可以简写为<code>email.sub(i+1);</code></li>
<li>在寻找‘@’ 可以通过 string.find()  <a href="http://www.cplusplus.com/reference/string/string/find/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/string/string/find/</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(c==<span class="string">'+'</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(c!=<span class="string">'.'</span>) newlocal+=c;</span><br></pre></td></tr></table></figure>
<p>这个是有顺序的，第二次写的时候给疏忽了。</p>
<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h3><p>思路： 暴力枚举 时间复杂度 O(n*n)</p>
<ul>
<li>以中心点 分为奇偶向两边扩展<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">// 对奇数长度</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j=i,k=i;j&gt;=<span class="number">0</span>&amp;&amp;k&lt;s.<span class="built_in">size</span>()&amp;&amp;s[k]==s[j];j--,k++)</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">size</span>()&lt;k-j+<span class="number">1</span>) res=s.substr(j,k-j+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i,k=i+<span class="number">1</span>;j&gt;=<span class="number">0</span>&amp;&amp;k&lt;s.<span class="built_in">size</span>()&amp;&amp;s[k]==s[j];j--,k++)</span><br><span class="line">             <span class="keyword">if</span>(res.<span class="built_in">size</span>()&lt;k-j+<span class="number">1</span>) res=s.substr(j,k-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="在这里总结下判断回文字符串的几种常见方法"><a href="#在这里总结下判断回文字符串的几种常见方法" class="headerlink" title="在这里总结下判断回文字符串的几种常见方法"></a>在这里总结下判断回文字符串的几种常见方法</h4></li>
</ul>
<ol>
<li>双指针从首尾向中间靠拢</li>
<li>从中间向两边，但是需要注意考虑奇偶情况，如果仅仅只是判断单个的字符串是否满足回文<br>这样来做是划不来的，调用<code>reverse()</code>直接将字符串翻转比较</li>
</ol>
<p>2020年2月11日</p>
<h3 id="6-Z字形变换"><a href="#6-Z字形变换" class="headerlink" title="6. Z字形变换"></a>6. Z字形变换</h3><p>这道题目描述有点长，属于一找规律的题目</p>
<p>关键规律：行数 n<br>自己画一下 Z图发现 首尾行为等差数列 2(n-1)<br>其他行为 两个交错的等差数列 第二个等差数列的首相需要注意下<br>以及对于边界条件的判断 n==1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//rule 1 for begin row and end</span></span><br><span class="line">            <span class="keyword">if</span>(!i||i==n<span class="number">-1</span>) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j+=<span class="number">2</span>*(n<span class="number">-1</span>))  res+=s[j];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i,k=<span class="number">2</span>*(n<span class="number">-1</span>)-i; j &lt; s.<span class="built_in">size</span>()||k&lt;s.<span class="built_in">size</span>(); j+=<span class="number">2</span>*(n<span class="number">-1</span>),k+=<span class="number">2</span>*(n<span class="number">-1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;s.<span class="built_in">size</span>()) res+=s[j];</span><br><span class="line">                <span class="keyword">if</span>(k&lt;s.<span class="built_in">size</span>()) res+=s[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="208-前缀树-trie"><a href="#208-前缀树-trie" class="headerlink" title="208.前缀树(trie)"></a>208.前缀树(trie)</h3><p>这个概念之前没有接触过<br>基本数据结构</p>
<ul>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。<br>以该题为例 都是小写字母 则有26个子节点</li>
</ul>
<p>每个字符串需要有一个标志结尾，考虑上述因素定义如下数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">bool</span> is_end;</span><br><span class="line">        node* son[<span class="number">26</span>];</span><br><span class="line">        node()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) son[i]=<span class="literal">NULL</span>;</span><br><span class="line">            is_end=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;*root;</span><br></pre></td></tr></table></figure>
<p>开始写的时候对面向对象的知识都丢了，不记得怎么来 new 一个对象。。。</p>
<h3 id="trie-基础"><a href="#trie-基础" class="headerlink" title="trie 基础"></a>trie 基础</h3><p>目的：高效存储和查找字符串集合</p>
<p>特点：要么都是小写，大写，或者数字</p>
<p>使用数组来实现trie基本操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>; <span class="comment">//表示从根节点开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ ) <span class="comment">//str[i] 作为判断条件 因为 字符串以`0`结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>; <span class="comment">//求孩子下标index</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<span class="comment">//如果孩子不存在分配新的节点，类比new ，注意是前置++</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ; <span class="comment">//表示插入字符串个数++</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>trie 不仅能用来存储字符串，也能够存储0-1bit,如下面例子</p>
<h3 id="421-数组中两个数的最大异或值"><a href="#421-数组中两个数的最大异或值" class="headerlink" title="421. 数组中两个数的最大异或值"></a><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">421. 数组中两个数的最大异或值</a></h3><p>不要觉得构建字典树麻烦，能对时间性能有很大提升。</p>
<p>思路</p>
<p>按整数从高位到低位异或比较，在字典树中查找最大的异或对</p>
<p>这里看起来比较复杂的点在于trie的构建，需要自己定义数据结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    node*son[<span class="number">2</span>];</span><br><span class="line">    node()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) son[i]=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        trie()&#123;</span><br><span class="line">            root =<span class="keyword">new</span> node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将元素插入到字典树</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> p=root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> path=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!p-&gt;son[path]) p-&gt;son[path]=<span class="keyword">new</span> node();</span><br><span class="line">                p=p-&gt;son[path];</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//查找x 对应的异或最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p=root;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> path=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;son[!path]) &#123;<span class="comment">//优先选相反位 这样异或值最大</span></span><br><span class="line">                res=res*<span class="number">2</span>+!path;</span><br><span class="line">                 p=p-&gt;son[!path]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">             res=res*<span class="number">2</span>+path;</span><br><span class="line">             p=p-&gt;son[path];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        node* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        trie t;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            t.insert(nums[i]);</span><br><span class="line">            res=max(res,nums[i]^t.find(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析，树的查找时间复杂度为logn, 循环n次，所以整个的时间复杂度为nlogn, 但是题目里面的要求是<strong>O(n)， 如何进一步优化</strong></p>
<h3 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">1371. 每个元音包含偶数次的最长子字符串</a></h3><p>给你一个字符串 s，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’，在子字符串中都恰好出现了偶数次。</p>
<p>解题思路: 哈希表+状态压缩+前缀和</p>
<p>将5个元音字母出现次数的奇偶视为一种状态，一共有32种状态，不妨使用一个整数代表状态，第0位为1表示a出现奇数次，第一位为1表示e出现奇数次……以此类推。仅有状态0符合题意。</p>
<p>而如果子串[0，i]与字串[0,j]状态相同，那么字串[i+1,j]的状态一定是0，因此可以记录每个状态第一次出现的位置，此后再出现该状态时相减即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">//前缀和-&gt;第一次出现</span></span><br><span class="line">        <span class="built_in">map</span>[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">string</span> p=<span class="string">"aeiou"</span>;</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==p[j])&#123;</span><br><span class="line">                    mask^=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.count(mask)) res=max(res,i-<span class="built_in">map</span>[mask]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">map</span>[mask]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="227-基本计算器-II-加减乘除表达式"><a href="#227-基本计算器-II-加减乘除表达式" class="headerlink" title="227. 基本计算器 II(加减乘除表达式)"></a>227. 基本计算器 II(加减乘除表达式)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s=s+<span class="string">"+0"</span>; <span class="comment">//数据预处理防止  最后一个运算符可能用不到</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign=<span class="string">'+'</span>; <span class="comment">//前一个字符 这里由于+/- 优先级最低 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(s[i]&lt;=<span class="string">'9'</span>&amp;&amp;s[i]&gt;=<span class="string">'0'</span>) num=num*<span class="number">10</span>+s[i]-<span class="string">'0'</span>; <span class="comment">//可能出现符号溢出</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'/'</span>||s[i]==<span class="string">'*'</span>||s[i]==<span class="string">'+'</span>||s[i]==<span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sign==<span class="string">'+'</span>) nums.push(num);</span><br><span class="line">                <span class="keyword">if</span>(sign==<span class="string">'-'</span>)nums.push(-num);</span><br><span class="line">                <span class="keyword">if</span>(sign==<span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> t=nums.top();</span><br><span class="line">                    nums.pop();</span><br><span class="line">                    nums.push(t*num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign==<span class="string">'/'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> t=nums.top();</span><br><span class="line">                    nums.pop();</span><br><span class="line">                    nums.push(t/num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign=s[i];</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;nums.top()&lt;&lt;endl;</span></span><br><span class="line">            res+=nums.top();</span><br><span class="line">            nums.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《把自己作为方法:与项飙谈话》整理</title>
    <url>/2021/01/22/ba-zi-ji-zuo-wei-fang-fa/</url>
    <content><![CDATA[<ul>
<li><p>项飙小时候和外公住在一起，他们家隔壁是一个暗娼，附近大一点的孩子就趴在木墙缝隙中看，声音都听得见。这个性启蒙真的比较直接，比起我当时在新华书店看啥《三言二拍》直接多了。</p>
</li>
<li><p>项谈到自己做调查时候不够放松，缺少和大家打成一片的能力，这和他小时候经常和外公玩有关系。外公对外非常客气，但内心可能又是一种鄙视。</p>
</li>
<li><p>一个理论不至于新旧，正确与否，关键在于是否具有可沟通性，能够调动对方的积极性，那么这个理论就是革命性的</p>
</li>
<li><p><strong>真正的英雄不是改变世界，而是改变自己生活的每一天</strong></p>
<p>当下边缘与中心变为对立概念，中国人自古就有很强的中心情节，觉得边缘生活不值得过，造成极大焦虑。传统儒家文化通过意识上的“内在化”来处理边缘与中心问题，地方与中央不是等级化关系，有高有低，而是像月照千湖，每一个湖都有自己的月亮 #example</p>
</li>
<li><p>不要怕边缘，怕知识不够，天真真实地体现出来，就会很可爱，不要装腔作势。</p>
</li>
<li><p>高平子孙子高准和胡适说他要继承“为天地立心，为生民立命，为往圣继绝学，为万世开太平”，胡适用他一套英国实证主义来反问他”到底怎么叫为天地立心”，这些都是情感表达，没有着落，没有价值。英国实证主义的代表罗素，应该是来过中国，胡适可能受他影响比较大。</p>
</li>
<li><p>杜赞奇对项影响比较大，缘起杜对彭湃感兴趣，彭老家在海丰，就是五条人的故乡，五条人有首歌《彭啊湃》还提到了彭湃。彭作为地主阶级却反叛自己阶级，回家搞土地革命这让杜赞奇感到不可思议。</p>
</li>
<li><p>再谈乡绅，好的人民代表就是现代社会的乡绅，但现在人大代表按照职业划分，代表和被代表之间的关系疏远，那么代表如何这群人利益理解清楚？</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>并发</title>
    <url>/2020/08/05/bing-fa/</url>
    <content><![CDATA[<p>《OSTEP》线程并发小结</p>
<a id="more"></a>

<h4 id="理解多线程为什么会有竞争状态问题"><a href="#理解多线程为什么会有竞争状态问题" class="headerlink" title="理解多线程为什么会有竞争状态问题"></a>理解多线程为什么会有竞争状态问题</h4><p>多线程对共享资源访问，可能不是原子操作，导致不确定结果。</p>
<h4 id="条件量使用"><a href="#条件量使用" class="headerlink" title="条件量使用"></a>条件量使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<p>wait 操作传入参数除了条件变量还有锁，这样做的目的是为了把进程休眠同时释放锁。否则其他线程就没法获得锁，唤醒休眠线程。</p>
<p>下面代码做线程之间同步存在什么问题</p>
<ol>
<li>spin 忙等待浪费cpu</li>
</ol>
<p>但是这个能够实现线程之间同步操作么?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局标志变量</span></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//thread A</span></span><br><span class="line"><span class="keyword">while</span>(flag==<span class="number">0</span>); <span class="comment">//spin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//thread B singal</span></span><br><span class="line">flag=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h4 id="锁的设计"><a href="#锁的设计" class="headerlink" title="锁的设计"></a>锁的设计</h4><p>在设计锁之前，有几个指标能够来衡量设计方案的好坏。</p>
<ol>
<li><p>能否实现互斥</p>
</li>
<li><p>公平性(防止饥饿）</p>
</li>
<li><p>实现锁带来的额外负担</p>
</li>
</ol>
<p>最直接的想法是通过关闭中断来实现互斥，竞态条件下执行结果的不稳定，就是因为线程执行过程中被打断，调度。我们通过关闭中断，就能够实现对资源的互斥访问，但是这个在实际情况不太可能实现(多CPU,以及关闭中断带来的巨大风险)。</p>
<h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p>通过硬件支持的同步原语来实现互斥，首先我们看一个没有原子操作的互斥锁方案</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span> <span class="keyword">int</span> flag; &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">	mutex-&gt;flag = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>);<span class="comment">// TEST the flag spin-wait (do nothing)</span></span><br><span class="line">	mutex-&gt;flag = <span class="number">1</span>;<span class="comment">// now SET it!</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>上述方案的问题在于检查flag和设置flag不是原子操作，可能存在一种情况线程A执行完while()然后被调度，导致两个线程都获得锁。</p>
<p>改进方案如下</p>
<p>CAS（compare and swap）一种原子操作，</p>
<p>bool CAS(V, A,B) // 检查现有V 是否与A== 如果== 将V设置为B 同时返回true</p>
<p><strong>自旋锁伪码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CAS（compare <span class="keyword">and</span> swap）一种原子操作，</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAS</span><span class="params">(V, A,B)</span> <span class="comment">// 检查现有V 是否与A== 如果==  将V设置为B 同时返回true</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">自旋锁伪码实现</span><br><span class="line"><span class="keyword">bool</span> flag =<span class="literal">false</span>; <span class="comment">//锁为true 表示被占用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!CAS(flag,<span class="literal">false</span>,<span class="literal">true</span>));</span><br><span class="line"><span class="comment">//do-something</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//release lock</span></span><br><span class="line">flag=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure>



<p>自旋锁虽然能够实现对临界区的互斥访问，但是带来了性能问题，spin通过忙等待形式去获取锁，导致了CPU资源的浪费。</p>
<p>比如场景：单核cpu运行多个线程</p>
<p>线程1获得lock进入临界区,然后被打断，线程2被调度，一直自旋等待锁被释放。</p>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h5><p>针对上述问题，一种解决方法是通过主动放弃CPU，当线程发现锁被占用，主动将自己的状态由RUNNING-&gt;READY， 避免了自旋等待占用CPU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!CAS(flag,<span class="literal">false</span>,<span class="literal">true</span>)) <span class="built_in">yield</span>();</span><br></pre></td></tr></table></figure>

<p>yield 带来的问题</p>
<ol>
<li><p>大量的上下文切换操作</p>
</li>
<li><p>仍然没有解决饥饿问题</p>
</li>
</ol>
<h5 id="sleep队列"><a href="#sleep队列" class="headerlink" title="sleep队列"></a>sleep队列</h5><p>无论自旋，还是yield， 调度器的选择很多，导致了资源的浪费。如果线程发现自己暂时不能获取锁，将自己休眠，就带来了效率提升。</p>
<p>下面实现代码还是很巧妙的</p>
<ul>
<li>guard作用: 用于自旋等待变量</li>
</ul>
<p>相比于自旋等待整个临界区，gaurd的获取和释放间隔很短；eg.多核CPU, 当一个进程A拿到gaurd,然后另一个进程B被调度，此时B就拿不到gaurd，自旋等待，但是由于A临界区代码很短，很快A就会释放gaurd.</p>
<ul>
<li>unlock()中， 唤醒线程之后，没有将flag设置为0</li>
</ul>
<p>这么做的原因是线程被唤醒之后，可以看作是从park（）返回，此时线程没有拿到guard,锁没有释放就直接传递给了被唤醒线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line">	<span class="keyword">int</span> guard;</span><br><span class="line">	<span class="keyword">queue_t</span> *q;</span><br><span class="line">	&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">	m-&gt;flag= <span class="number">0</span>;</span><br><span class="line">	m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">	queue_init(m-&gt;q);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">		m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired</span></span><br><span class="line">		m-&gt;guard = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">		queue_add(m-&gt;q, gettid());</span><br><span class="line">		m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">		park(); <span class="comment">//线程休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">	<span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">		m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock (for next thread!)</span></span><br><span class="line">	m-&gt;guard = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于锁的数据结构"><a href="#基于锁的数据结构" class="headerlink" title="基于锁的数据结构"></a>基于锁的数据结构</h4><h5 id="并发链表设计"><a href="#并发链表设计" class="headerlink" title="并发链表设计"></a>并发链表设计</h5><p>关键在于数据结构的定义，节点如何定义(int, node*) ，链表怎么定义(锁+链表头)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// basic node structure</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basic list structure (one used per list)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">list_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">node_t</span> * head;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Init</span><span class="params">(<span class="keyword">list_t</span> * L)</span> </span>&#123;</span><br><span class="line">    L-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_init(&amp;L-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(<span class="keyword">list_t</span> * L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">node_t</span> * <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>)); <span class="comment">//先分配节点，只有在更新全局资源时候加锁，而不是一上来就全部加锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"malloc"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// fail</span></span><br><span class="line">    &#125;</span><br><span class="line">	pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">new</span>-&gt;key = key;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = L-&gt;head;</span><br><span class="line">    L-&gt;head = <span class="keyword">new</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表查找需要加锁么? 不涉及到全局变量的修改，但是如果不加锁，一个线程在修改正在查找的链表，也会导致race condition</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Lookup</span><span class="params">(<span class="keyword">list_t</span> * L, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">node_t</span> * curr = L-&gt;head;</span><br><span class="line">    <span class="keyword">int</span> rv=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line">            rv=<span class="number">0</span>;<span class="comment">//返回0 表示找到</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rv;  <span class="comment">// faulure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="并发哈希表"><a href="#并发哈希表" class="headerlink" title="并发哈希表"></a>并发哈希表</h5><p>有了这个基础，设计并发哈希表就很简单，通过拉链方法来避免哈希冲突</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUCKETS (101)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hash_Init</span><span class="params">(<span class="keyword">hash_t</span> * H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUCKETS; i++) &#123;</span><br><span class="line">        List_Init(&amp;H-&gt;lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Insert</span><span class="params">(<span class="keyword">hash_t</span> * H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash_Lookup</span><span class="params">(<span class="keyword">hash_t</span> * H, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucket = key % BUCKETS;</span><br><span class="line">    <span class="keyword">return</span> List_Lookup(&amp;H-&gt;lists[bucket], key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><blockquote>
<p>什么是信号量?</p>
<p>信号量和条件变量区别</p>
</blockquote>
<p>信号量用来做lock,也能够用来做条件变量，关键在于信号量的初始化。</p>
<p>信号量=变量+操作</p>
<p><strong>信号量操作伪码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *s)</span> </span>&#123;</span><br><span class="line">	decrement the value of semaphore s by one</span><br><span class="line">	wait <span class="keyword">if</span> value of semaphore s is negative</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *s)</span> </span>&#123;</span><br><span class="line">	increment the value of semaphore s by one</span><br><span class="line">	<span class="keyword">if</span> there are one <span class="keyword">or</span> more threads waiting, wake one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>信号量做二元锁</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> m;</span><br><span class="line">sem_init(&amp;m, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// initialize semaphore to 1</span></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line"><span class="comment">// critical section here</span></span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure>

<p><strong>信号量做条件变量</strong></p>
<p>下面代码目的是同步父子进程，父进程等待子进程结束。</p>
<p>注意条件变量被初始化为0，分两个情况考虑，如果子进程被创建之后先执行，sem_post将信号量+1,父进程执行sem_wait正常返回；如果父进程先执行，sem-1小于0，父进程被挂起，子进程执行，将sem+1，然后唤醒父进程。 所以符合我们预定执行顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">sem_post(&amp;s); <span class="comment">// signal here: child is done</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	sem_init(&amp;s, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"parent: begin\n"</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> c;</span><br><span class="line">	Pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">	sem_wait(&amp;s); <span class="comment">// wait here for child</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"parent: end\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>



<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>允许多个读，一个写，第一个读者自动获得写锁，最后一个读锁释放，写锁也释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">sem_t</span> lock;</span><br><span class="line">    <span class="keyword">sem_t</span> <span class="built_in">write</span>;</span><br><span class="line">    <span class="keyword">int</span> readers;</span><br><span class="line">&#125; rw_lock;</span><br><span class="line"></span><br><span class="line">init(rw_lock*m)&#123;</span><br><span class="line">    sem_init(m-&gt;lock,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    sem_init(m-&gt;<span class="built_in">write</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    m-&gt;readers=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_acquire_read</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_wait(m-&gt;lock);</span><br><span class="line">    m-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span>(m-&gt;readers==<span class="number">1</span>) sem_wait(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">    sem_post(m-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_release_read</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_wait(m-&gt;lock);</span><br><span class="line">    m-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span>(m-&gt;readers==<span class="number">0</span>) sem_post(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">    sem_post(m-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_acquire_write</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_wait(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rw_acquire_write</span><span class="params">(rw_lock*m)</span></span>&#123;</span><br><span class="line">    sem_post(m-&gt;<span class="built_in">write</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据流算法题目小结</title>
    <url>/2020/06/09/shu-ju-liu-suan-fa-ti-mu-xiao-jie/</url>
    <content><![CDATA[<p>由于数据是动态的，按照一般的做法，比如遍历，当新数据的加入，处理单个操作的时间复杂度为<code>O(n)</code>,这样往往造成TLE</p>
<p>通过使用合理的数据结构来存储，比如堆，能够将时间复杂度降低到 <code>logn</code></p>
<a id="more"></a>

<h4 id="703-数据流中的第K大元素"><a href="#703-数据流中的第K大元素" class="headerlink" title="703. 数据流中的第K大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">703. 数据流中的第K大元素</a></h4><p>这个本质的思想就是通过小根堆来求第K大元素，通过限制堆大小为k,以及判断堆顶元素与新加入元素val大小关系，将时间复杂度降低到logn.</p>
<p>有一点需要注意的就是做<code>pop()</code> 一定要检查堆是否为空。</p>
<h4 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></h4><p>通过使用两个堆，一个小根堆存放序列中较大的一部分元素，大根堆存放较小的一部分元素，可以形象的把这个结构想象成一个沙漏</p>
<p>通过堆顶元素就能够很方便的得到数据流的中位数。</p>
<p>当新元素val加入如何维护堆?</p>
<ol>
<li>val 先添加到大根堆maxq,  如果maxq.top&gt;minq.top 需要交换两个堆定元素</li>
<li>始终保持maxq.size()&lt;=minq.size()+1 这样才能通过堆顶来求中位数</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>最长上升子序列</title>
    <url>/2020/05/27/zui-chang-shang-sheng-zi-xu-lie/</url>
    <content><![CDATA[<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<a id="more"></a>

<h3 id="解法1-动态规划"><a href="#解法1-动态规划" class="headerlink" title="解法1.动态规划"></a>解法1.动态规划</h3><p><strong>时间复杂度O($n^2$)</strong></p>
<p><strong>思路</strong></p>
<p><code>f[i]</code>表示以ith字符结尾的最长上升子序列长度</p>
<p>这道题难在状态转移的求解<br><code>f[i]=max(f[i-1],f[i-2],......)+1</code>  前提条件是 f[j]&lt;f[i] 才能构成上升子序列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            f[i]=<span class="number">1</span>; <span class="comment">//表示只含当前字符的序列长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i]) f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:f) res=<span class="built_in">max</span>(res,c);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法2-直接构造最长上升子序列"><a href="#解法2-直接构造最长上升子序列" class="headerlink" title="解法2  直接构造最长上升子序列"></a>解法2  直接构造最长上升子序列</h3><p>时间复杂度 $O(nlogn)$</p>
<p>开一个辅助数组 <code>f[i]</code> 表示最长上升子序列长度为<code>i+1</code> 中最小结尾值</p>
<p>eg. [1,2,4] ,[1,2,3]两个子序列长度都为3， 但是第一个子序列结尾值3&lt;4 ，于是 f[2]=3;</p>
<p>这里面的思路背景是 在dp解法中  f[i]=max(f[j]+1)  nums[j] 越小 那么对nums[i]限制就越小</p>
<p>两个最长上升子序列长度相同 那么子序列尾部值越小 越有可能构建成更加长的子序列</p>
<p>由于构造的辅助数组一定单调上升，因此可以通过二分查找来做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size(),len=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> p=lower_bound(f.begin(),f.end(),c)-f.begin(); </span><br><span class="line">            <span class="keyword">if</span>(p==f.size()) f.push_back(c);<span class="comment">//查找元素比辅助数组最大值还要大</span></span><br><span class="line">            <span class="keyword">else</span> f[p]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最好是通过一个 toy example 来给给面试官讲这个思路。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序二叉树转化为双向链表</title>
    <url>/2020/05/24/pai-xu-er-cha-shu-zhuan-hua-wei-shuang-xiang-lian-biao/</url>
    <content><![CDATA[<p>问题描述：<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>这道题目注意审题，注意双向链表的表头和表尾部是否连接，如果连接就是一个循环双向链表。</p>
<a id="more"></a>

<h3 id="循环双向链表-递归"><a href="#循环双向链表-递归" class="headerlink" title="循环双向链表+递归"></a>循环双向链表+递归</h3><p>思路上很直接，在二叉搜索树的中序遍历基础上，改变当前节点<code>root</code>指针指向，因为我们需要将<code>root-&gt;left</code> 指向前一个顺序遍历的节点，我们用一个指针<code>pre</code>表示当前节点的前一个节点。</p>
<p>解法一<br>递归返回头节点和尾节点，注意递归传递的参数应该是引用类型(<del>不然debug搞死你。。。)</del></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        Node*head=<span class="literal">nullptr</span>,*pre=<span class="literal">nullptr</span>;</span><br><span class="line">        dfs(root,head,pre);</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node*root,Node*&amp;head,Node*&amp;pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left,head,pre);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;root-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            head=root;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;right=root;</span><br><span class="line">            root-&gt;left=pre;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;right,head,pre);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p>大体和上面一样递归，但是递归的时候没有保存头节点,而是在把节点指针顺序改变好之后(实际上这个时候双链表已经建好了）通过链表的反向遍历找到头节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node*pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">auto</span> head=pre;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;left) head=head-&gt;left;</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        root-&gt;left=pre;</span><br><span class="line">        <span class="keyword">if</span>(pre) pre-&gt;right=root;</span><br><span class="line">        pre=root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法3-利用栈非递归中序遍历"><a href="#解法3-利用栈非递归中序遍历" class="headerlink" title="解法3  利用栈非递归中序遍历"></a>解法3  利用栈非递归中序遍历</h3><p>二叉搜索树的中序遍历后结果是一个有序数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; stk;</span><br><span class="line">        Node*pre=<span class="literal">NULL</span>,*head=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(root||stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            root-&gt;left=pre;</span><br><span class="line">            <span class="keyword">if</span>(pre) pre-&gt;right=root;</span><br><span class="line">            pre=root;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        head=pre;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;left) head=head-&gt;left;</span><br><span class="line">        head-&gt;left=pre;</span><br><span class="line">        pre-&gt;right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口小结</title>
    <url>/2020/06/11/hua-dong-chuang-kou-xiao-jie/</url>
    <content><![CDATA[<p>滑动窗口可以用来优化一些暴力求解问题，将时间复杂度降低到线性。</p>
<a id="more"></a>

<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h4><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<p>思路</p>
<ul>
<li>先扫描一遍T，把对应的字符及其出现的次数存到 HashMap 中。</li>
<li>然后开始遍历S，就把遍历到的字母对应的 HashMap 中的 value 减一，如果减1后仍大于等于0，cnt 自增1。</li>
<li>如果 cnt 等于T串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是T串中不可缺少的字母(hash表中对应value&gt;0)，那么 cnt 自减1，表示此时T串并没有完全匹配。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t) <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">int</span> len=t.size();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,cnt=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--<span class="built_in">map</span>[s[i]]&gt;=<span class="number">0</span>) cnt++;</span><br><span class="line">            <span class="keyword">while</span>(cnt==len)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.empty()||res.size()&gt;i-j+<span class="number">1</span>) res=s.substr(j,i-j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(++<span class="built_in">map</span>[s[j++]]&gt;<span class="number">0</span>) cnt--;<span class="comment">//移动左边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>进一步理解</strong><br>本来我们是可以开两个哈希表，这里为了节省空间，将其合并，遍历S字符串的时候，哈希表中字符出现的次数可以理解还缺多少个，就可以满足和T字符串匹配。这样一来就能很好理解在移动左边界的判断条件<code>++hash[s[j++]]&gt;0</code> 表示左边界指针移动之后，缺的个数大于0.</p>
<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p><strong>滑动窗口</strong>  思路非常类似上一题76.最小覆盖子串</p>
<p>这个题目的滑动窗口大小固定，因此需要先调整大小，然后添加满足条件的答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> c:p) <span class="built_in">map</span>[c]++;</span><br><span class="line">       <span class="keyword">int</span> total=p.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,cnt=<span class="number">0</span>;j&lt;s.size();j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(--<span class="built_in">map</span>[s[j]]&gt;=<span class="number">0</span>) cnt++; <span class="comment">//移动右指针</span></span><br><span class="line">           <span class="comment">//移动左指针 维护窗口大小为p.size</span></span><br><span class="line">           <span class="keyword">while</span>(j-i+<span class="number">1</span>&gt;total)&#123;</span><br><span class="line">               <span class="keyword">if</span>(++<span class="built_in">map</span>[s[i++]]&gt;<span class="number">0</span>) cnt--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(cnt==total) res.push_back(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>文件系统的持久化</title>
    <url>/2020/06/11/wen-jian-xi-tong-de-chi-jiu-hua/</url>
    <content><![CDATA[<p>《OSTEP》文件持久化部分阅读笔记</p>
<a id="more"></a>

<h3 id="什么是crash-consistency-problem"><a href="#什么是crash-consistency-problem" class="headerlink" title="什么是crash-consistency problem?"></a>什么是crash-consistency problem?</h3><p>在两次write()之间，系统可能出现异常的断电，崩溃等情况，导致磁盘文件被部分更新。</p>
<p>在系统重启时，文件系统被再次装载，如何解决之前异常崩溃带来的on-disk image inconsistent state 是接下来要讨论的重点</p>
<p>具体来看下磁盘出现不一致的情况</p>
<p>当我们append new data block 到一个文件，至少需要更新3个数据结构:<code>inode,data block,data bitmap</code>在更新这三个数据结构的过程中，系统都可能崩溃，在不同的阶段崩溃造成的后果不一样。</p>
<p><img src="https://s1.ax1x.com/2020/06/11/tHFAQx.png" alt="tHFAQx.png"></p>
<p>假设只有一次更新成功</p>
<ul>
<li>data block is updated  不会造成一致性问题，因为没有inode指向更新的data block</li>
<li>inode  造成一致性问题，与bitmap 冲突，同时由于data block没有更新，会读取脏数据。</li>
<li>data bitmap 同上带来一致性问题，同时带来空间泄漏，因为bitmap更新之后，指向的空间不会被系统分配</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-file-system-checker"><a href="#1-file-system-checker" class="headerlink" title="1.file system checker"></a>1.file system checker</h4><p>基本思路是让不一致发生，然后修复它。</p>
<p>但是存在一些问题比如,即使inode 与data bitmap 一致，仍然可能存在读取脏数据<br>其次这种做法最大的问题就是速度太慢！ 需要扫描整个磁盘来检查所有相关的数据结构。</p>
<ol start="2">
<li><h4 id="日志-write-ahead-logging"><a href="#日志-write-ahead-logging" class="headerlink" title="日志(write-ahead logging)"></a>日志(write-ahead logging)</h4></li>
</ol>
<p>在更新磁盘之前，先将当前操作(trananactions) 记录下来，当系统崩溃时候，能够replay。这样做的好处就是能够精准定位崩溃问题，不需要扫描整个磁盘。</p>
<p>具体如何实现</p>
<h5 id="data-log"><a href="#data-log" class="headerlink" title="data log"></a>data log</h5><ol>
<li>Journal write: Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.</li>
<li>Checkpoint: Write the pending metadata and data updates to their final locations in the file system.</li>
</ol>
<p>问题<br>在写日志的时候可能崩溃</p>
<p>改进<br>将写日志操作拆分为两步</p>
<ul>
<li>写日志开始标志+data+inode+bitmap</li>
<li>写日志结束标志</li>
</ul>
<p>这样做的好处在于磁盘能够保证对单个区块(512byte)的原子操作，进而保证对单条日志记录要么成功要么失败。</p>
<p>日志的空间大小有限，一旦日志空间满，之后的transactions 将不能被记录。<br>具体解决方法通过循环日志(类似循环队列) 一旦一个transaction 被check了，系统就释放对应的日志空间</p>
<p>经过上述几个改进，我们现在的做法如下</p>
<ol>
<li><p>Journal write: Write the contents of the transaction (containing TxBand the contents of the update) to the log; wait for these writes to<br> complete.</p>
</li>
<li><p>Journal commit: Write the transaction commit block (containingTxE) to the log; wait for the write to complete; the transaction is now committed.</p>
</li>
<li><p>Checkpoint: Write the contents of the update to their final locations within the file system.</p>
</li>
<li><p>Free: Some time later, mark the transaction free in the journal by updating the journal superblock.</p>
</li>
</ol>
<p>上述解决方案还能进一步优化: 我们将data block 两次写到了磁盘</p>
<h5 id="metadata-log"><a href="#metadata-log" class="headerlink" title="metadata log"></a>metadata log</h5><p>基本操作与之前一样，只是没有将data 写到日志中。</p>
<ol>
<li>Data write: Write data to final location; wait for completion(the wait is optional; see below for details).</li>
<li>Journal metadata write: Write the begin block and metadata to thelog; wait for writes to complete.</li>
<li>Journal commit: Write the transaction commit block (containingTxE) to the log; wait for the write to complete; the transaction (including data) is now committed.</li>
<li>Checkpoint metadata: Write the contents of the metadata updateto their final locations within the file system.</li>
<li>Free: Later, mark the transaction free in journal superblock.</li>
</ol>
<p>先写data 是为了避免脏读，如果先写meta，然后系统崩溃，就会导致读取旧的数据。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《禅与摩托车维修艺术》阅读笔记</title>
    <url>/2021/01/20/shan-yu-mo-tuo-che-wei-xiu-yi-zhu/</url>
    <content><![CDATA[<blockquote>
<p>理性的幽灵悬浮在空中，我决定去一探究竟</p>
</blockquote>
<a id="more"></a>


<ul>
<li>谈科学研究现状</li>
</ul>
<blockquote>
<p>在科学的殿堂里有许多深宅大院……有各种人住在其中，而他们住在这儿的动机也是形形色色，五花八门。有些人倾心于科学是因为有优越的智力，科学成了他们独有的活动，在其中他们得到了生动的经验，也满足了他们的野心。有一些人则完全是为了实用的目的，而将自己思考的产物献在祭坛上。如果上帝派来的天使将上面两种人从殿里驱逐出去，那么殿里显然会空旷许多，但是里面仍然会住着一批古今人物……如果殿里本来只住着前述两种人，那么如今的它就只不过是一座空木屋，只有四处攀爬的蔓草……那些得到天使青睐的人……有些古怪、沉默和孤独，除了同是不受欢迎的人之外，彼此之间少有相似之处。</p>
</blockquote>
<p>这不仅仅适用于科学研究领域的现状，当下计算机甚至各行各业，大部分人都谈不上真正热爱，只想讨饭吃，但是一个推动一个行业前进的可能就只是前面那1%的少数人</p>
<ul>
<li>谈少有人走的路</li>
</ul>
<blockquote>
<p>“好像我们身后山谷里的那些人，大部分望着灵性的高峰，但是一生从来不曾攀上去过，只是听听别人的经验就已经满足，而自己不愿意花费任何心血。另一些人则是靠着有经验的向导，他们知道最安全的路，因而能够顺利到达他们的目的地。但是还有另外一批人，不但没有经验，而且不太相信别人的经验，想要走出自己的路。其中很少有人能成功，但是总有一些靠着自己的意志、运气，还有上天的恩典而做到了。那些成功的人要比别人明白，其实登山并没有唯一或是固定的路线，有多少这样的人就有多少条路。”</p>
</blockquote>
<p>古人之观于天地、山川、草木、虫鱼、鸟兽，往往有得，以其求思之深而无不在也。夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！</p>
<ul>
<li>谈教育</li>
</ul>
<blockquote>
<p>这个学生最大的问题就是，因为多年来胡萝卜和鞭子的教育方式，造成了他思考上的惰性。就好像一头驴子：“如果你不打我，我就不工作。”如果没有人鞭打他，他就不会努力工作。而训练他去拉的文明的车子，很可能就会因此而走慢了一点。</p>
</blockquote>
<blockquote>
<p>于是他就会回到没有分数也没有学位的学校里，这时他变了，不再为分数而来，而是为了追求真正的知识。他不需要别人强迫他去学习，他的动力来自于内在。这个时候，他就是一个自由的人，他不需要许多规章制度的督促。事实上，如果老师上课的态度松懈，他倒可能会唐突地问许多问题去督促老师。他来这儿是要学东西的，并且付了钱，那么老师们最好也不要懈怠。</p>
</blockquote>
<blockquote>
<p>他真正的想法是，这些规则是作品写好之后才归纳出来的，作者不是依照这些原则来写作的。他最后终于确信，这些学生想模仿的作家，根本就没有所谓的原则，只是把他们认为对的东西写下来，然后再回头看看是否有问题，如果修辞不妥，可以再修“</p>
</blockquote>
<p>这一点我深以为然，写作技巧层面的东西，一开始都没有那么重要，切记不要做过早优化(<strong>premature optimization is the root of all evil</strong>)， 写作，写播客，刷题等等一开始都需要先搞起来，没有原始积累，谈技巧都是耍流氓。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议栈收包过程小结</title>
    <url>/2020/08/05/wang-luo-xie-yi-zhan-shou-bao-guo-cheng-xiao-jie/</url>
    <content><![CDATA[<p>linux网络协议栈学习小结</p>
<a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>下面的包分析基于下面的TCP/IP四层协议栈，内核代码基于2.6版本。</p>
<p><img src="https://s1.ax1x.com/2020/08/08/a42rFO.png" alt="a42rFO.png"></p>
<h3 id="发包过程"><a href="#发包过程" class="headerlink" title="发包过程"></a>发包过程</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层是数据包发送起始点， 应用进程通过套接字API发起写系统调用。对套接字做读写操作，和对普通文件做读写操作相似，在linux中万物皆是文件。</p>
<p>常用的写套接字API如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>send</code>,<code>write</code>,<code>writev</code>只能用于面向连接的套接字(SO_STREAM)。</p>
<p><code>writev()</code>可以指定一系列的缓冲区，收集要写的数据，使可以安排数据保存在多个缓冲区中，然后同时写出去，从而避免出现Nagle和延迟ACK算法的相互影响，起到类似”gather write”的效果。 </p>
<p><strong>struct iovec</strong>结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *iov_base; <span class="comment">/*基本地址指针，指向缓冲区*/</span></span><br><span class="line"><span class="keyword">size_t</span> iov_len; <span class="comment">/*指定缓冲区长度*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的套接字API接口处理流程相似</p>
<ul>
<li>输入参数都是描述符，我们需要将<code>fd-&gt; struct sock</code>。</li>
<li>创建消息头部，套接字控制信息(uid,pid,…)</li>
</ul>
<p>无论我们通过<code>write</code>还是<code>sendmsg</code>等写操作，最后都会到<code>sock_senmsg()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">iocb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> <span class="title">siocb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	init_sync_kiocb(&amp;iocb, <span class="literal">NULL</span>);</span><br><span class="line">	iocb.<span class="keyword">private</span> = &amp;siocb;</span><br><span class="line">	ret = __sock_sendmsg(&amp;iocb, sock, msg, <span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">if</span> (-EIOCBQUEUED == ret)</span><br><span class="line">		ret = wait_on_sync_kiocb(&amp;iocb);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__sock_sendmsg()做了一些安全检查之后，会调用协议相关的消息发送函数<code>sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size)</code>，协议相关的 操作集在套接字创建过程通过type,family初始化。举个例子，如果是一个TCP套接字，那么实际将调用tcp_sendmsg,如果是一个UDP套接字，将调用udp_sendmsg。</p>
<h4 id="套接字接口层"><a href="#套接字接口层" class="headerlink" title="套接字接口层"></a>套接字接口层</h4><p>我们在实际做网络通信过程中，一般需要经过这几个步骤</p>
<ul>
<li>通过<code>socket()</code>创建套接字</li>
<li><code>bind()</code>绑定套接字</li>
<li><code>listen()</code>监听套接字</li>
</ul>
<p>这里详细参考我的这篇文章   <a href="https://hustddl.com/2020/08/08/socket%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%B0%8F%E7%BB%93/#more">socket从创建到连接过程小结</a></p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>TCP 栈简要过程：</p>
<ol>
<li><p>tcp_sendmsg 函数会首先检查已经建立的 TCP connection 的状态，然后获取该连接的 MSS，开始 segement 发送流程。</p>
</li>
<li><p>构造 TCP 段的 playload：它在内核空间中创建该 packet 的 sk_buffer 数据结构的实例 skb，从 userspace buffer 中拷贝 packet 的数据到 skb 的 buffer。</p>
</li>
<li><p>构造 TCP header。</p>
</li>
<li><p>计算 TCP 校验和（checksum）和 顺序号 （sequence number）。 </p>
<p>TCP 校验和是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现 TCP 首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则 TCP 段会被直接丢弃。TCP 校验和覆盖 TCP 首部和 TCP 数据。</p>
</li>
<li><p>发到 IP 层处理：调用 IP handler 句柄 ip_queue_xmit，将 skb 传入 IP 处理流程。</p>
</li>
</ol>
<hr>
<p>具体到一些细节</p>
<p><strong>tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,size_t size)</strong></p>
<p>按照之前的分析，<strong>sock_sendmsg</strong>最终调用<strong>tcp_sendmsg</strong>,我们知道TCP是一个面向连接的协议，因此在发送数据之前，内核会检查TCP的连接状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Wait for a connection to finish. */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT))</span><br><span class="line">	<span class="keyword">if</span> ((err = sk_stream_wait_connect(sk, &amp;timeo)) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以发现，如果连接尚未建立，不处于<strong>ESTABLISHED</strong>或者<strong>CLOSE_WAIT</strong>状态，那么进程进行睡眠，等待三次握手的完成。被动关闭方收到FIN,处于CLOSE_WAIT状态，此时处于半关闭状态，仍然可以发数据(不要错看成TIME-WAIT)了。</p>
<h5 id="tcp建立连接"><a href="#tcp建立连接" class="headerlink" title="tcp建立连接"></a>tcp建立连接</h5><p>在传输数据之前，tcp作为面向连接的协议，需要先通过三次握手来建立连接。篇文章是很好的 <a href="http://www.leviathan.vip/2018/08/09/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-TCP%E5%8D%8F%E8%AE%AE-1/" target="_blank" rel="noopener">参考</a></p>
<p><img src="http://www.leviathan.vip/2018/08/09/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-TCP%E5%8D%8F%E8%AE%AE-1/tcp_3.png" alt="Imgur"></p>
<h5 id="tcp-senmsg"><a href="#tcp-senmsg" class="headerlink" title="tcp_senmsg"></a>tcp_senmsg</h5><p>一旦连接建立好，<code>tcp_sendmsg()</code>先做了发包之前的准备工作，比如获取<code>mss(maxium segment size)</code>,mss规定了一次发送的最大数据大小，mss的值一般为1460byte,因为数据链路层的MTU一般为1500byte,mss加上tcp，ip头部即得到MTU。</p>
<p>具体到发送数据，这里<strong>第一次涉及到用户空间数据到内核空间的拷贝</strong>， 内核先分配<code>struct sk_buff</code>。 如果skb的线性数据区还有剩余空间，就复制用户进程数据到线性数据区中,如果线性区域使用完，就使用分页区域， 通过<code>skb copy to page</code>拷贝用户空间的数据到skb的分页中，同时计算校验和。</p>
<h5 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h5><p>这里看下sk_buff中线性区域和非线性区域具体细节。</p>
<p>有四个指针，标识线性区域，（head,end)表示分配的缓存范围，(data,tail)表示实际数据的范围。head指针和end指针指向的位置一直都不变，对于数据的变化和协议信息的添加都是通过data指针和tail指针的改变来表现的。</p>
<p>sk_buff中有几个长度很容易搞混，这里梳理一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sk_buff-&gt;data_len ;分片中数据的长度，即是分片结构体中page指向的数据区长度</span><br><span class="line">sk_buff-&gt;len;当前缓冲区中数据块的大小的总长度,即线性缓存长度+data_len</span><br><span class="line">sk_buff-&gt;truelen;  缓冲区的总长度，包括sk_buff结构和数据部分 即 sk_buff-&gt;len+sizeof(sk_buff)</span><br></pre></td></tr></table></figure>

<p>下面的图大致描述了sk_buff结构</p>
<p><img src="https://s1.ax1x.com/2020/07/13/UYKpCt.png" alt="UYKpCt.png"></p>
<h5 id="tcp-transmit-skbs"><a href="#tcp-transmit-skbs" class="headerlink" title="tcp_transmit_skbs"></a><strong>tcp_transmit_skbs</strong></h5><p><strong>tcp_sendmsg</strong>最终通过调用<code>tcp_transmit_skb</code> 将数据包传到IP层。这里面主要做了这几件事情。首先，sk_buff是没有头部信息的，我们需要自己构造TCP头部，包含了源端口，目的端口，序列号等。与头部相关的数据结构为<code>struct scphdr</code>,定义如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line">	__u16	source;</span><br><span class="line">	__u16	dest;</span><br><span class="line">	__u32	seq;</span><br><span class="line">	__u32	ack_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LITTLE_ENDIAN_BITFIELD)</span></span><br><span class="line">	__u16	res1:<span class="number">4</span>,</span><br><span class="line">		doff:<span class="number">4</span>,</span><br><span class="line">		fin:<span class="number">1</span>,</span><br><span class="line">		syn:<span class="number">1</span>,</span><br><span class="line">		rst:<span class="number">1</span>,</span><br><span class="line">		psh:<span class="number">1</span>,</span><br><span class="line">		ack:<span class="number">1</span>,</span><br><span class="line">		urg:<span class="number">1</span>,</span><br><span class="line">		ece:<span class="number">1</span>,</span><br><span class="line">		cwr:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__BIG_ENDIAN_BITFIELD)</span></span><br><span class="line">	__u16	doff:<span class="number">4</span>,</span><br><span class="line">		res1:<span class="number">4</span>,</span><br><span class="line">		cwr:<span class="number">1</span>,</span><br><span class="line">		ece:<span class="number">1</span>,</span><br><span class="line">		urg:<span class="number">1</span>,</span><br><span class="line">		ack:<span class="number">1</span>,</span><br><span class="line">		psh:<span class="number">1</span>,</span><br><span class="line">		rst:<span class="number">1</span>,</span><br><span class="line">		syn:<span class="number">1</span>,</span><br><span class="line">		fin:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>	<span class="meta-string">"Adjust your &lt;asm/byteorder.h&gt; defines"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	</span></span><br><span class="line">	__u16	window;</span><br><span class="line">	__u16	check;</span><br><span class="line">	__u16	urg_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现结构体的布局和大小端是有关系的，但是只涉及到标志位。</p>
<h5 id="字节序和比特序"><a href="#字节序和比特序" class="headerlink" title="字节序和比特序"></a>字节序和比特序</h5><p>先问自己一个问题</p>
<blockquote>
<p> 上述代码如果不添加条件编译语句，为什么不具有移植性?</p>
</blockquote>
<p>字节序的最小单位是1个字节，位域的最小单位是一个位域字段。</p>
<p>位域，也就是变量后面跟上冒号接数字表示这个变量占几个比特位的这种字段，比如：__u16    res1:4这表示ihl只占用了4个比特位。由于位域并不固定几个比特位，所以系统没法提供基于位域的大小端转换函数(htons,htonl.etc)。</p>
<p>之所以offset以及FIN等标志位要按照大端，小端字节序判断，就是为了使得主机无论是大端还是小端，offset相对fin标志位总是处于内存低地址处。</p>
<p><a href="https://yizhi.ren/2016/11/14/bitorder/" target="_blank" rel="noopener">位域</a></p>
<p>在<code>tcp_transmit_skb</code> 中实际填充tcp头部的过程如下，将seq,ack_seq做了主机字节序到网络字节序的转化。计算tcp头部检验和。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">th-&gt;source		= inet-&gt;sport;</span><br><span class="line">th-&gt;dest		= inet-&gt;dport;</span><br><span class="line">th-&gt;seq			= htonl(tcb-&gt;seq);</span><br><span class="line">th-&gt;ack_seq		= htonl(tp-&gt;rcv_nxt);</span><br><span class="line">th-&gt;check		= <span class="number">0</span>;</span><br><span class="line">th-&gt;urg_ptr		= <span class="number">0</span>;</span><br><span class="line">tp-&gt;af_specific-&gt;send_check(sk, th, skb-&gt;len, skb);<span class="comment">// 计算tcp头部校验和</span></span><br></pre></td></tr></table></figure>

<p>具体看下检验和是如何计算的，发现除了用到tcp头部的信息，还有用到发送端，接收端的ip地址，这么做的目的是因为TCP头部不包含这些信息，为了提高检验能力，我们在计算checksum时，人为的加上一个”伪首部”，伪首部并不会在网络中传输。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_v4_send_check</span><span class="params">(struct sock *sk, struct tcphdr *th, <span class="keyword">int</span> len,struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_HW) &#123;</span><br><span class="line">		th-&gt;check = ~tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr, <span class="number">0</span>);</span><br><span class="line">		skb-&gt;csum = offsetof(struct tcphdr, check);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		th-&gt;check = tcp_v4_check(th, len, inet-&gt;saddr, inet-&gt;daddr,</span><br><span class="line">					 csum_partial((<span class="keyword">char</span> *)th,</span><br><span class="line">						      th-&gt;doff &lt;&lt; <span class="number">2</span>,</span><br><span class="line">						      skb-&gt;csum));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终通过调用<code>queue_xmit</code>将待发送数据添加到待发送队列。 发送队列的具体位置如下图</p>
<img src="https://user-gold-cdn.xitu.io/2019/4/19/16a35787afe2efd7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="消息发送" style="zoom:80%;" />

<h4 id="IP层"><a href="#IP层" class="headerlink" title="IP层"></a>IP层</h4><p>对于单播发包，函数调用的流程图如下：</p>
<p><img src="https://s1.ax1x.com/2020/08/05/ayf6uF.png" alt="ayf6uF.png"></p>
<p>上图可以看到，当 L4 层有数据包待发送时，对于TCP包它将调用<code>ip_queue_xmit</code>它们将这些包交由<code>NETFILTER（ LOLACL_OUT）</code>处理后，然后交给 dst_output，这会根据是多播或单播选择合适的发送函数。如果是单播，它会调用 ip_output()，然后是 <code>ip_finish_output()</code>，这个函数主要是检查待发送的数据包大小是否超过 MTU，如果是，则要首先调用 <code>ip_fragment()</code>将其分片，然后再传给 <code>ip_finish_output2()</code>,由它交给链路层处理了。  </p>
<p>IP层在TCP数据包的基础上，主要做下面几件事情</p>
<ul>
<li>构建IP头部</li>
<li>路由查询以及维护TTL(time to live)</li>
<li>包分片</li>
<li>Netfilter与iptabels做防火墙过滤</li>
</ul>
<p>如果数据包发送的目的端是本机应用程序，那么数据包将不经过底层协议栈，直接到接收方的TCP层。</p>
<h5 id="分片细节"><a href="#分片细节" class="headerlink" title="分片细节"></a><strong>分片细节</strong></h5><p>总的思路就是当L4层传过来的包大于MTU,通过循环，每次分配一个skb，然后将原来skb里面的IP头部部分数据拷贝到新分配的skb中，不同分片的标识号是一样的，不同之处在分片中起始数据相对原始报文的偏移，以及<code>MF(more fregment)</code>等一些标志位。</p>
<p>这里主要关注不同分片IP头部中offset如何设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* linux-2.6.11\net\ipv4\ip_output.c*/</span></span><br><span class="line"><span class="comment">//ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff*)) slow_path:</span></span><br><span class="line">left = skb-&gt;len - hlen;	<span class="comment">//待分片长度</span></span><br><span class="line">offset = (ntohs(iph-&gt;frag_off) &amp; IP_OFFSET) &lt;&lt; <span class="number">3</span>;<span class="comment">//从待分片报文提取offset</span></span><br><span class="line"><span class="comment">//循环分片</span></span><br><span class="line"><span class="keyword">while</span>(left &gt; <span class="number">0</span>)	&#123;</span><br><span class="line">    len=left;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; mtu) len = mtu;</span><br><span class="line">    <span class="comment">//分配skb结构体,以及做一些填充工作</span></span><br><span class="line">    skb2 = alloc_skb(len+hlen+ll_rs, GFP_ATOMIC)</span><br><span class="line">    iph = skb2-&gt;nh.iph;</span><br><span class="line">    iph-&gt;frag_off = htons((offset &gt;&gt; <span class="number">3</span>));<span class="comment">//设置offset</span></span><br><span class="line">    offset += len;<span class="comment">//更新offset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ip_queue_xmit</strong></p>
<p>tcp层最中通过<code>tp-&gt;af_specific-&gt;queue_xmit(skb, 0);</code>将数据包传到了IP层，具体到TCP协议，就是调用<code>ip_queue_xmit</code></p>
<ul>
<li>调用<code>__sk_dst_check</code>对路由信息做检查</li>
<li>调用<code>ip_route_output_flow</code> ,这里是实际做路由计算的点，调用<code>__ip_route_output_key</code>来查找一条路径，使用<code>struct flowi</code>来记录路由查询信息，首先从缓存中查找，如果没找到就从FIB里面找(Forwarding Information Base)</li>
</ul>
<p>在做路由的过程中，可能会有下面几种可能</p>
<ul>
<li>包继续forwarded,  到ip_forward</li>
<li>包路由失败，不能解析，到ip_output </li>
<li>包路由解析成功，到dev_queue_xmit</li>
</ul>
<p>假设我们成功做了路由解析，找到了一条到目的端路径，那么就通过<code>dev_queue_xmit</code>到了数据链路层。</p>
<h5 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a><strong>Netfilter</strong></h5><p>在数据流中什么位置(过滤点)对数据包做什么操作(规则)。</p>
<ol>
<li>过滤点(chain)，输入，输出，转发，路由前，路由后</li>
<li>过滤规则: <ul>
<li>filter</li>
<li>nat</li>
<li>magle </li>
</ul>
</li>
</ol>
<p><img src="https://img2018.cnblogs.com/i-beta/729011/202002/729011-20200206184522753-754025474.png" alt=""></p>
<ol>
<li>当数据包从物理层和数据链路层传输过来，如果数据包是访问Linux主机本身。则经过PRE_ROUTING和LOCAL_IN钩子函数，到达传输层和应用层。</li>
<li>当数据包从物理层和数据链路层传输过来，如果数据包需要转发，则经过PRE_ROUTING、FORWARD和POST_ROUTING三个钩子函数。</li>
<li>当数据包从Linux主机本身向外发送数据包，要经过LOCAL_OUT和POST_ROUTING钩子函数。</li>
</ol>
<p>以发数据为例，本地产生的数据经过HOOK函数<code>NF_IP_LOCAL_OUT</code> 处理后，进行路由选择处理，然后经过<code>NF_IP_POST_ROUTING</code>处理后发送出去。</p>
<h5 id="hook原理"><a href="#hook原理" class="headerlink" title="hook原理"></a>hook原理</h5><p>所有的回调函数都注册在二维数组全局变量<code>struct list_head nf_hooks[NFPROTO_NUMPROTO][NF_MAX_HOOKS] __read_mostly;</code>中。。数组的第一个维度是注册回调函数的协议族，第二个维度是注册回调函数的hook点，也就是每一个协议族的每一个hook点都是一个双向链表连接的一组回调函数。</p>
<p>当代码执行到HOOK点根据协议类型， HOOK点编号，来遍历执行对应链表所有注册的回调函数，hook点回调函数处理完毕并允许下一步逻辑执行时,<code>okfn</code>被执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NF_HOOK(pf, hook, skb, indev, outdev, okfn)</span><br></pre></td></tr></table></figure>

<p><a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">深入理解 iptables 和 netfilter 架构</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-ntflt/index.html" target="_blank" rel="noopener">Linux Netfilter实现机制和扩展技术</a></p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层负责将ip层的数据加上包头，发送给网卡。</p>
<p><strong>dev_queue_xmit</strong></p>
<p>在这个函数中，一开始通过屏蔽所有的软中断(buttom-half)来获得设备的队列锁，接着调用<code>qdisc_run()</code>检查设备是否数据包需要传输，如果设备忙，那么该函数将再次在软中断中被调用。<code>qdisc_restart</code>获取设备的<code>xmit</code>锁，如果成功就调用<code>dev-&gt;hard_start_xmit</code>来完成最终的数据包传输，这个调用是和具体的设备有关系。一旦网卡完成报文发送，将产生中断通知 CPU，然后驱动层中的中断处理程序就可以删除保存的 skb 了。</p>
<h5 id="网卡中断收发包机制"><a href="#网卡中断收发包机制" class="headerlink" title="网卡中断收发包机制"></a>网卡中断收发包机制</h5><p>一般的当网卡有数据到来，通过产生一个硬件中断来通知CPU处理，在运行中断服务历程(ISR)时候，将屏蔽所有中断，也就意味着在执行硬件中断服务时候，不能被抢占，如果中断服务处理的任务比较轻，比如响应键盘等，这个是没有问题的。但是，网卡的中断需要处理的任务是很重的，比如说分配缓存结构体<code>sk_buff</code>,将接收数据拷贝到<code>sk_buff</code>等等，中断服务在处理这些任务时候占用了大量的CPU时间，导致不能及时相应其他的中断。</p>
<p>为了解决上述的问题，linux将中断的处理分为两个步骤top-half,buttom-half。其主要区别就在于上半部分执行的时候禁止一些或者全部中断，下半部分执行期间中断是打开的，可以响应所有中断。上半部分一定运行在中断上下文中，下半部分有很多种实现方式，根据不同的实现方式可能运行在中断上下文中，也可能运行在任务(process)上下文中。上半部分实际响应<code>request_irq()</code>，下半部分推迟实现，以软中断为例，在上半部分硬件中断返回后标记，然后触发软中断。(这一块具体可以参考《内核设计与实现》第八章)</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>下图总结了数据从用户态拷贝到内核，然后经过内核协议栈到最后网卡发送的整个流程。</p>
<p><img src="http://www.uml.org.cn/embeded/images/201604141011.png" alt="img"></p>
<h4 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h4><p><code>struct inet_sock</code>是INET域专用的一个socket表示，它是在struct sock的基础上进行的扩展，在基本socket的属性已具备的基础上，struct inet_sock提供了INET域专有的一些属性，比如TTL，组播列表，IP地址，端口等。</p>
<h5 id="网卡多队列"><a href="#网卡多队列" class="headerlink" title="网卡多队列"></a>网卡多队列</h5><p>概念：一张网卡具有多个接收队列</p>
<p>解决问题</p>
<p>每个cpu有一个软中断线程对应网卡收包，当网卡流量特别大情况下，就会导致cpu负载高，性能存在瓶颈；</p>
<p>工作原理</p>
<p>网卡多任务队列将收到的包根据四元组信息做哈希运算，然后放到多队列其中一个，之后该连接所有的包都将经过相同队列，每个队列对应不同cpu的软中断，这样就实现了网卡收包的负载均衡，避免了某些cpu负载特别高。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/aiwz/p/6333235.html" target="_blank" rel="noopener">tcp_sendmsg</a></p>
<p><a href="https://wiki.linuxfoundation.org/networking/kernel_flow#transmission_path" target="_blank" rel="noopener">transmission_path</a></p>
<p><a href="https://www.slideshare.net/hugolu/the-linux-networking-architecture" target="_blank" rel="noopener">linux网络架构</a></p>
<p>《understading linux kernel internals》</p>
<p><a href="http://www.uml.org.cn/embeded/2016041410.asp?artid=17878" target="_blank" rel="noopener"> <strong>Linux 网络栈</strong></a></p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用open(),read(),write()具体发了什么?</title>
    <url>/2020/06/01/xi-tong-diao-yong-open-read-write-ju-ti-fa-liao-shi-me/</url>
    <content><![CDATA[<p>本文主要想探究的是我们平时说的IO系统调用与<code>inode</code>，文件系统等之间的交互，或者说，在做文件IO时候，有那些底层的数据结构参与进来。</p>
<a id="more"></a>



<p>在讲具体的系统调用之前，先要简单了解几个概念</p>
<p><strong>文件系统</strong></p>
<p>文件系统可以简单的理解为数据结构+方法</p>
<p>数据结构：文件系统以一种怎样的结构来组织其存储的数据</p>
<p>方法:open(),read()等调用如何与数据结构打交道</p>
<p>一个简单的文件系统一般有这几部分</p>
<ul>
<li>inode table记录文件的metadata,主要有文件的权限，用户，创建时间，文件所对应blocks</li>
<li>data block 存储实际问文件内容</li>
<li>inode bitmap 记录inode table 分配情况位图用0/1来表示对应项是否分配</li>
<li>data bitmap 记录data blocks 分配情况</li>
<li>superblock 记录了整个文件系统的一些信息，比如inode个数，data blocks个数，inode table 起始地址。当文件系统<code>mount()</code> superblock被加载到内存。</li>
</ul>
<h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>以<code>/foo/bar</code> 为例，假设文件大小为4kb</p>
<p>首先<code>open(&quot;/foo/bar&quot;,O_RDONLY)</code> 需要找到文件bar对应的inode,具体的做法是按照文件路径遍历，通过目录中存储的文件名-&gt;inode-number来找到文件<code>bar</code>对应的inode。</p>
<p>将文件对应的inode加载到内存，做权限检查，比如文件读写属性。每个进程中都有一个open-file-table,系统为打开的文件分配文件描述符。</p>
<p>一旦文件打开之后，read()按照顺序从第一个block开始读取，具体来看需要读取inode来获取区块位置信息，更新inode中last-access-time。更新open-file-table中的file offset。</p>
<p>打开一个文件所涉及到的IO操作与文件路径长度成正比。每次通过父目录中的data-block来获取inode-number，用来在inode table查找对应的inode，通过inode来查找data-block位置。 因此每多添加一层目录就会有额外的两次IO.</p>
<p>下面的图直观的说明这一过程</p>
<p><img src="https://s1.ax1x.com/2020/06/01/tJimWt.png" alt="tJimWt.png"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>许知远-罗翔访谈记录</title>
    <url>/2020/12/29/xu-zhi-yuan-luo-xiang-fang-tan/</url>
    <content><![CDATA[<p>《十三邀》中许对罗翔的访谈，这其中看到了B站张三老师另外的一面</p>
<a id="more"></a>
<blockquote>
<p>在人类所有美德中，勇敢是最稀缺的</p>
</blockquote>
<p>罗上学时候结巴，后来为了养活自己讲课， 写逐字稿，慢慢就不结巴了。</p>
<p><img src="https://raw.githubusercontent.com/ddl-hust/imagebed/master/20201228153612.png" alt=""></p>
<p>巧了我的启蒙也是赵借我看的这一套书，现在还在启蒙，永不过时。</p>
<p>北京万圣书店</p>
<p><a href="https://zh.m.wikisource.org/zh-hans/%E4%BF%A0%E5%AE%A2%E8%A1%8C_(%E6%9D%8E%E7%99%BD)" target="_blank" rel="noopener">李白-侠客行</a>   武侠小说中对结果正义的最求，话说罗能够完整背诵侠客行还是挺让我意外的。</p>
<p><a href="https://book.douban.com/subject/2009914/" target="_blank" rel="noopener">为权力而斗争</a></p>
<blockquote>
<p>罗: 人最大的痛楚在于，无法跨越知道和做到的鸿沟</p>
</blockquote>
<p>罗对技术主义的转变，这里比较含糊，</p>
<p>罗说要警惕<a href="https://www.wikiwand.com/zh-hans/%E7%9B%B8%E5%B0%8D%E4%B8%BB%E7%BE%A9" target="_blank" rel="noopener">相对主义</a></p>
<p>罗推崇节制<a href="https://baike.baidu.com/item/%E5%BE%B7%E5%B0%94%E6%96%90%E7%A5%9E%E8%B0%95" target="_blank" rel="noopener">德尔菲神谕  </a>  ““认识你自己”、“凡事勿过度”、“承诺带来痛苦””</p>
<p>整个访谈<strong>最精彩的部分</strong>  </p>
<p>许: 法律学家在20世纪没有参与到整个社会的思想辩论中，如何看待？</p>
<p>罗:专业人士的自我封闭化，害怕专业变味，法学家的技术主义，上学时以技术主义为荣，觉得没白学</p>
<p>许: 什么时候这种观点发生了变化？</p>
<p>罗: 高傲的观点与老百姓内心常识相抵触时候，技术主义在逻辑论证没有问题，但其实是在抵触人内心的良知。人生的经历使得自己<strong>接受人生的有限性</strong></p>
<blockquote>
<p>承认自己是有限的，承认你的逻辑是有限的，承认你的理性是有有限的，承认自己的阅读是有限的，承认自己的偏见，一生就是在走出偏见</p>
</blockquote>
<p>许: 变化的契机?</p>
<p>罗：一些不可抗拒的力量，有些话也不好说，经历了亲人的生离死别。人最大的痛苦就是无法跨越知道和做到的鸿沟。笛卡尔说的“我思故我在”给人一种幻想-就是我思考到了，我就能做到，但其实不是这样。</p>
<p>2010年之前教课很受学生喜欢，有强烈的骄傲，但是内心有一种冲突，自己所教的，自己做不到，骗别人，在自我欺骗，陷入一种虚无</p>
<p>许: 如何应对那一次危机?</p>
<p>罗: 虚伪是肯定的，做到行动在言语之前多那么一步，摆脱虚伪的自我控诉。</p>
]]></content>
  </entry>
  <entry>
    <title>谁想看清尘世就应当同它保持必要的距离</title>
    <url>/2020/11/20/shui-xiang-kan-qing-chen-shi-jiu-ying-dang-tong-ta-bao-chi-bi-yao-de-ju-chi/</url>
    <content><![CDATA[<p>《树上的男爵》是一本小册子，200来页，很快就能读完。</p>
<p>书中探讨了关于自我和集体，自我和爱情，以及为了追求一个完整的自我，所作的取舍。要有不少句子都充满哲理，引人深思。</p>
<blockquote>
<p>他懂得这个道理：集体会使人更强大，能突出每个人的长处，使人得到替自己办事时极难以获得的那种快乐，会为看到那么多正直、勇敢而能干的人而喜悦，为了他们值得去争取美好的东西（而在为自己而生活时，经常出现的是相反的情形，看到的是人们的另一副面孔，使你必须永远用手握住剑柄）。 这个火灾的夏季因此而成为一个不错的季节：在大家的心中有一个需要解决的共同问题，每个人都把它放在其他个人利益之前，而且从其他许多优秀人物的赞同和敬佩中得到了满足与报偿。 后来，柯希莫不得不明白，当那个共同的问题不存在之后，集体就不再像从前那么好了，做一个孤独的人更好一些，而不要当首领。</p>
</blockquote>
<blockquote>
<p>真事使人回忆起许多属于过去的时光、细腻的感情、烦扰、幸福、疑惑、光荣和对自己的厌恶，而故事中砍掉了主要的东西，一切显得轻而易举。但变来变去，最后发觉自己在回头去讲自己经历过的真实生活中体验过或发生过的事情。</p>
</blockquote>
<blockquote>
<p>如果不感到自身充满力量，就不可能有爱情。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title>适合反复看的技术入门教程</title>
    <url>/2020/12/23/gua-he-fan-fu-kan-de-ji-zhu-ru-men-jiao-cheng/</url>
    <content><![CDATA[<a id="more"></a>

<ol>
<li><a href="https://zhuanlan.zhihu.com/p/339008746?utm_source=org.telegram.messenger&utm_medium=social&utm_oi=966460230863925248" target="_blank" rel="noopener">Kubernetes 入门&amp;进阶实战</a>  腾讯CSIG工程师写的，估计是内部k吧开源出来的</li>
</ol>
<blockquote>
<p>笔者今年（公元 2020 年）9 月从端侧开发转到后台开发，第一个系统开发任务就强依赖了 K8S，加之项目任务重、排期紧，必须马上对 K8S 有概念上的了解。然而，很多所谓“K8S 入门\概念”的文章看的一头雾水，对于大部分新手来说并不友好。经历了几天痛苦地学习之后，回顾来看，<strong>K8S 根本不复杂。</strong>于是，决心有了这一系列的文章：一方面希望对新手同学有帮助；另一方面，以文会友，希望能够有机会交流讨论技术。</p>
</blockquote>
<ol start="2">
<li><a href="https://kingsamchen.github.io/2020/02/08/how-to-learn-cmake-as-the-beginner/" target="_blank" rel="noopener">CMake 入门指南</a>  这位大哥是B站后端工程师，最早是在饭否看到他的技术分享觉得很棒，然后顺藤摸瓜找到了他的个人博客，可以看出来他对C++理解还是很深，虽然我之后可能不怎么会接触C++开发了，但是很多好的概念还是值得学习的。</li>
</ol>
<h4 id="0x00-起手式"><a href="#0x00-起手式" class="headerlink" title="0x00 起手式"></a>0x00 起手式</h4><p>这里假设题主以及其他想入门 CMake 的人像我一样，下面是我个人总结的比较适合的学习路径。</p>
<p>首先默念三遍并记住口诀：</p>
<ol>
<li>Declare a target</li>
<li>Declare target’s traits</li>
<li>It’s all about targets</li>
</ol>
<p>然后 clone <a href="https://github.com/ttroy50/cmake-examples" target="_blank" rel="noopener">https://github.com/ttroy50/cmake-examples</a> 这个项目到本地，把里面的</p>
<ul>
<li>01-basic（跳过E-installing，因为和依赖有关，后面会说）</li>
<li>02-sub-projects</li>
</ul>
<p>两个目录认真的学习一遍，最好自己能够动手跟着做一遍。</p>
<p>每学习完一个小节，把前面的三句口诀复习一下</p>
<p>每遇到一个不认识的命令，在 <a href="https://link.zhihu.com/?target=https%3A//gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">Effective Modern CMake</a> 这个页面里搜索一下，看看这个命令是否取代了某个老命令。</p>
]]></content>
  </entry>
  <entry>
    <title>负载均衡大量TW分析</title>
    <url>/2020/08/23/fu-zai-jun-heng-da-liang-tw-fen-xi/</url>
    <content><![CDATA[<a id="more"></a>

<p>背景</p>
<p>LB集群使用了LVS做负载均衡，使用的是NAT模式对tcp 80端口进行负载均衡。因为服务器访问量比较大，所以负载均衡后面的web服务器上出现了大量的 timewait 状态连接。</p>
<p>分析思路</p>
<ul>
<li>打开tcp_tw_recycle；load balancer作为中间代理应该需要开启tcp_tw_recyvle 同时需要开启tcp_timestamps</li>
<li>设置SO_LINGER ; 只有正常的四次挥手过程才会出现time-wait。 打开so-linger同时将延时设为0，服务器发起关闭时，发送RST直接断开连接</li>
<li>调整tcp_max_tw_buckets</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>《复杂》</title>
    <url>/2021/01/24/fu-za/</url>
    <content><![CDATA[<blockquote>
<p>复杂性科学的核心问题是：<strong>涌现和自组织行为是如何产生的</strong></p>
</blockquote>
<ul>
<li>简单规则以难以预测的方式产生出复杂行为，这种系统的宏观行为有时也称为<strong>涌现</strong></li>
<li>系统有组织的行为不存在内部和外部的控制者或领导者，则也称之为<strong>自组织（self-organizing）</strong></li>
</ul>
<a id="more"></a>

<h3 id="混沌的动力学方程"><a href="#混沌的动力学方程" class="headerlink" title="混沌的动力学方程"></a>混沌的动力学方程</h3><p>牛顿力学描绘了一幅“钟表宇宙”的图景：设定好初始状态，然后就遵循着三条定律一直运行下去。数学家拉普拉斯认识到其中蕴含了可以如钟表般精准预测的观念：他在1814年断言，根据牛顿定律，只要知道宇宙中所有粒子的当前位置和速度，原则上就有可能预测任何时刻的情况。[插图]在20世纪40年代计算机被发明出来之后，这种“原则上”的可能似乎有可能变成现实了。</p>
<p>早期牛顿在物理科学的进步，发展出来了”决定论”.</p>
<h4 id="决定论"><a href="#决定论" class="headerlink" title="决定论"></a>决定论</h4><p>决定论认为万事万物都由物理定律决定，每一件事情之间遵循严格的因果规律。</p>
<p>早期人们认为不存在真正的随机数，计算机里也不存在真正的随机数。计算机生成的所谓随机数，实际上是取一个现成的数字（比如系统时间），经过一系列固定公式计算出来的。</p>
<p>决定论带来的问题</p>
<ul>
<li>人类没有了自由意志；因为意识是由我们身体物质组成的，物质遵循物理定律。</li>
<li>没有自由，意味着不需要负责，带来人的虚无</li>
</ul>
<p>#example# 追乌龟的芝诺就是一个决定论者</p>
<blockquote>
<p>芝诺平时总念叨着一切都是注定的。结果有一次，他的奴隶犯了错误，他就鞭挞那奴隶作为惩罚。但是他的奴隶很聪明，辩解说：主人，按照你的决定论学说，我犯错是天生注定了的，不是我自己能控制的，所以你不应该惩罚我。然而芝诺更聪明，他回答说：你说的没错。但是按照同样的理论，我鞭挞你也是天注定了的。所以你就挨打吧。</p>
</blockquote>
<p>古希腊的<strong>斯多葛学派</strong>相信部分决定论。他们认为我们不能控制事物，但是可以控制我们自己对待生活的方式。所以这个学派提倡随遇而安的生活态度。</p>
<p>但是混沌系统以及量子力学的出现给这种绝对的因果论，带来了致命一击。</p>
<h4 id="混沌定义"><a href="#混沌定义" class="headerlink" title="混沌定义"></a>混沌定义</h4><blockquote>
<p>混沌指的是一些系统——混沌系统——对于其初始位置和动量的测量如果有极其微小的不精确，也会导致对其的长期预测产生巨大的误差。也就是常说的“对初始条件的敏感依赖性”</p>
</blockquote>
<h4 id="三体问题"><a href="#三体问题" class="headerlink" title="三体问题"></a>三体问题</h4><blockquote>
<p>庞加莱在试图解决一个比预测飓风简单得多的问题时发现了对初始条件的敏感依赖性。他试图解决的是所谓的三体问题（three-body problem）：用牛顿定律预测通过引力相互作用的三个物体的长期运动。牛顿已经解决了二体问题。但没想到三体问题要复杂得多。在向瑞典国王表示敬意的一次数学竞赛中，庞加莱将其解决了。竞赛主办方提供2500瑞典克朗奖励解决“多体”问题：用牛顿定律预测任意多个相互吸引的物体的未来运动。提出这个问题是为了确定太阳系是否稳定，行星是会维持还是会偏离目前的轨道？庞加莱想先试着解决三体问题。  #example# #math#</p>
</blockquote>
<p>混沌系统中初始的不确定性到底是如何被急剧放大的呢？关键因素是<strong>非线性</strong>。非线性系统中总体不等于部分之和。</p>
<p>#example# 举个例子，将一堆兔子分成两部分，放到两个岛上，如果岛上的资源受限制，用逻辑斯蒂模型（logistic model）描述这种情形下群体数量的增长。这个模型以一种简化方式描述群体数量的增长。你设定好出生率、死亡率（由于种群数量过多导致的死亡概率）以及最大种群承载能力（栖息地所能承载的种群数量上限)。 这样兔子一年之后的总数在分成两堆，和不分成两队的总数是不一样的。</p>
<h4 id="逻辑斯蒂映射"><a href="#逻辑斯蒂映射" class="headerlink" title="逻辑斯蒂映射"></a>逻辑斯蒂映射</h4><p>$$<br>x_{t+1}=R x_{t}\left(1-x_{t}\right)<br>$$</p>
<p>R取不同的值最终x收敛情况差别很大。</p>
<p>随着R增加，x从不动点，到二周期震荡，四周期震荡，直到发散，</p>
<p>逻辑斯蒂映射还被用来在计算机中生成伪随机数。因此，表面上的随机可以来自非常简单的确定性系统。</p>
<p>简单总结如下</p>
<ul>
<li>即逻辑斯蒂映射能产生类似于随机噪声的确定性轨道，这个事实有着让人困扰的实际含义。例如，这就意味着种群调查数据中那种明显的不稳定波动不一定表明环境的变化莫测或是采样有错误</li>
<li>在混沌中，不管初始条件有多接近，在足够长的时间之后，它们的轨道还是会相互分开。这意味着，即使我们的模型很简单，所有的参数也都完全确定，长期预测也仍然是不可能的。</li>
</ul>
<p><strong>混动的共性</strong></p>
<ol>
<li>单峰映射存在倍周期</li>
<li>周期倍增速度为常数:新的周期倍增比前面的周期倍增出现的速度快大约4.6692016倍</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>看似混沌的行为有可能来自确定性系统，无须外部的随机源。一些简单的确定性系统的长期变化，由于对初始条件的敏感依赖性，即使在原则上也无法预测。虽然混沌系统的具体变化无法预测，在大量混沌系统的普适共性中却有一些“混沌中的秩序”，例如通往混沌的倍周期之路，以及费根鲍姆常数。因此虽然在细节上“预测变得不可能”，在更高的层面上混沌系统却是可以预测的。</p>
<h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p>我们讨论自组织，实际上是一个从无序到有序过程，一个熵减少过程，复杂系统科学最关注的问题就是这种逆熵的自组织系统是如何可能的。</p>
<blockquote>
<p>第二定律：熵总是不断增加直至最大。系统总的熵会不断增加，直至可能的最大值；除非通过外部做功，否则它自身永远也不会减少。热力学第二定律是唯一区分过去和未来的基本物理定律。其他物理定律在时间上都是可逆的。</p>
</blockquote>
<p>熵的新定义</p>
<p>玻尔兹曼将<strong>宏观状态的熵定义为其对应的微观状态的数量</strong>。 这极大撇清了我的疑惑，以前认为熵只是关于能量，温度的关联， 新的定义将熵转化为了信息的度量。</p>
<h4 id="麦克斯韦的思想实验"><a href="#麦克斯韦的思想实验" class="headerlink" title="麦克斯韦的思想实验"></a>麦克斯韦的思想实验</h4><blockquote>
<p>麦克斯韦假设有一个箱子被一块板子隔成两部分，板子上有一个活门，如图所示。活门有一个“小妖”把守，小妖能测量气体分子的速度。对于右边来的分子，如果速度快，他就打开门让其通过，速度慢就关上门不让通过。对于左边来的分子，则速度慢的就让其通过，速度快的就不让通过。一段时间以后，箱子左边分子的速度就会很快，右边则会很慢，这样熵就减少了。麦克斯韦假设了小妖使用的门既无质量也无摩擦，因此开门关门要不了多少功，可以忽略不计（对这种门提出了可行的设计）</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ddl-hust/imagebed/master/20210124112118.png" alt="image-20210124112111805"></p>
<p>这个悖论如何解释呢？</p>
<p>小妖要通过测量获取“比特”信息，比如趋近的分子速度是慢是快，需要能量，因此必然会产生一定的熵，数量不少于分子变得有序而减少的熵。这样由箱子、分子和小妖组成的整个系统就仍然遵守热力学第二定律。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>希尔伯特提出了一系列的数学问题  #anki#</p>
<ol>
<li>数学是否是完备的，即所有的数学命题都可以由一组有限的公理证明与否</li>
<li>数学是不是一致的； 简单点理解就是如果我们证明了假命题（eg.1+1=3）那么数学就不是一致的</li>
<li>是不是所有命题数学都可以判定</li>
</ol>
<p>哥德尔给出了不完备性定理证明，认为上述问题1，2不可能同时成立，他给出这样一个命题 #example#  #math#</p>
<blockquote>
<p>这个命题是不可证的”</p>
</blockquote>
<p>这个命题谈论的是它自身，假设该命题为A。现在假设命题A可证，那它就为假（因为它说它不可证），这就意味着证明了假命题——从而算术是不一致的。好了，那我们就假设命题A不可证，这就意味着命题A为真（因为它断言的就是自己不可证），但这样就存在不可证的真命题——算术是不完备的。因此，算术要么不一致，要么不完备。</p>
<ul>
<li><strong>哥德尔的趣事</strong></li>
</ul>
<blockquote>
<p>哥德尔受到时断时续的精神问题困扰，他在维也纳一直待到1940年，最后为了不被征入德军服兵役，移民到美国。（据他的传记作者王浩说，[插图]在准备美国入籍面试时，他发现了美国宪法中的不一致性，结果他的朋友爱因斯坦在陪他去面试时只好不断同他聊天，以引开他的注意力。）</p>
</blockquote>
<p><strong>达尔文和孟德尔的思想如何统一</strong></p>
<blockquote>
<p>生物的大部分性状都是由许多基因一起决定的，每个基因都有数个不同的等位基因，这种争论才烟消云散。多个不同等位基因会有数量极大的组合可能，从而使得生物的变异像是连续的。生物在基因层面的离散变异会导致表型——基因决定的生理特征（例如高矮、肤色等）——看似连续的变异。人们最终认识到，达尔文与孟德尔的理论并不矛盾，而是互补的。</p>
</blockquote>
<p><strong>计算机的自我复制为什么可行</strong></p>
<blockquote>
<p>自我复制：计算机不能复制自身；要复制自身就必须包含对自身的描述；而这个描述又包含其本身的描述，这样反复无穷。</p>
</blockquote>
<p>自我复制程序，内存中的信息既可以作为指令同时也可以作为数据，用来避免无穷无尽的自我复制</p>
<hr>
<p>（待续…….）</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>理解比特币</title>
    <url>/2021/01/25/bi-te-bi-hou-mian-de-shu-xue-yuan-li/</url>
    <content><![CDATA[<p>关于比特币有太多的消息，关于人们赚了多少亏了多少，但是比特币到底是什么呢？想起木遥说</p>
<blockquote>
<p>在过去的一年里，我身边的几乎每个朋友都或多或少问过我关于比特币的问题，往往是非常初等的问题。这有点奇怪，因为比特币已经诞生了有将近十年之久，差不多跟智能手机同龄，但今天没有人还会好奇地问智能手机是什么。一个省事的解释是比特币没有像智能手机一样进入千家万户，可是反过来想，拥有一部智能手机并不会让人暴富，人们对比特币的求知欲应该成百上千倍更高才对。我觉得更本质的原因在于，比特币首先是一种知识，而知识在今天的信息网络里的传播速度正在变得越来越慢，越来越低效。</p>
</blockquote>
<p>20年暑期实习时候，住在一起的一个大哥就是做比特币的，我们开始每天晚上回去了聊天，聊了几天就觉得他满嘴跑火车，拿着一本社会学书在看，聊来聊去就是一些大而空的词，同样关于比特币我问道具体是啥，他也解释不不清楚。我对于比特币能不能赚钱现在兴趣不大，但是我很好奇比特币究竟是什么，他背后的基础是啥？</p>
<p>现在把我最近学的关于比特币知识梳理下。</p>
<a id="more"></a>

<hr>
<p>稍微查一下wiki的定义，比特币是一个去中心化，互不信任的交易验证体系。其中<strong>去中心化</strong>，<strong>trustless</strong>，这些词语其实我早就听说了，但是这对于比特币到底意味着什么呢？</p>
<p>在介绍比特币这一种加密货币之前，我们看一下基本概念账本（ledger）和数字签名（digital signature）是啥</p>
<h3 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h3><p>账本需要保证下面两点</p>
<ol>
<li>记录的唯一性</li>
<li>记录的有效性</li>
</ol>
<p>假设四个人之间有频繁的交易往来，每次用现金结算比较麻烦，于是他们约定将所有的交易记录在一个<strong>公有的账本</strong>上，每个人都可以添加和查看这个公有账本。这个账本其实可以理解为庄家，每过一定时间庄家就去查账本，欠了钱的需要把钱补齐给庄家。</p>
<p>当这里存在一个问题，假设B向账本添加一笔记录 “A欠B100元”(实际上应该由A来作这笔记录),此时A可能并不知情，这该怎么办呢？</p>
<p>这里就引入了数字签名，每一个人都有一对公钥(public key)和私钥(serect key) ，密钥可能是一串256位的01字符串。私钥是必须自己保管好的，用过github的应该都知道。</p>
<p>在现实生活中同一个人签名在不同文档上都是一样的，但是数字签名不是这样的，不同的文件内容+私钥通过加密函数能够产生不一样的签名，这样就能避免在不同文件上用同一个数字签名伪造。用符号表示就是</p>
<p>$$<br>F(文件,私钥)=数字签名<br>$$</p>
<p>有了数字签名之后，我们还需要验证签名的正确性</p>
<p>$$<br>F(文件,数字签名，公钥)=True/False<br>$$</p>
<p>有了数字签名之后账本上的一条记录可能如下</p>
<blockquote>
<p>A欠B100元 数字签名(01110000…..)</p>
</blockquote>
<p>解决了记录的有效性，还需要解决同一条交易记录唯一性问题，即给每条记录加上一个唯一的id,此时一条交易记录看起来</p>
<blockquote>
<p>1 A欠B100元 数字签名(01110000…..)</p>
</blockquote>
<p>简单总结下我们现在这个交易系统的特点</p>
<ol>
<li>每个人都可以向账本添加记录</li>
<li>间隔固定时间做账本结算</li>
<li>只有数字签名合法的交易记录才有效</li>
</ol>
<p>上述系统存在一个问题，如果有人到月底欠了钱，但是他又没有出现怎么办？。因此在原有系统更进一步，假设在系统初期我们每个人都向系统交一笔固定的钱，每次交易我们都去查历史记录，一旦发现这笔交易可能导致这个人收入小于支出，就认为这笔交易不合法。这样改进之后的另一个好处就是不需要做账本结算了。其次，数字货币和纸币脱离了关系(不在依赖纸币的结算)</p>
<p>有了上边的知识，到这里我们可以给比特币做一个简单的定义，比特币就是一个共有账本，等价于所有</p>
<p>的历史总和。</p>
<h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>上述提到的系统设计，实际上有一个“庄家”或者叫一个中心机构，但是如果每一个人都有一份这样的账本，那么我们岂不是就不再需要中间人了么？</p>
<p>但这带来了一个问题，按照设想<strong>每一个都有一个账本</strong>，这个账本应该是相同的，那么如何保证每笔交易以及交易顺序在每个人的账本中一样呢?</p>
<p>这个问题实际上是整个加密货币最难的一部分，比特币是通过选择相信<strong>消耗算力资源最多的那一份账本</strong>.</p>
<p>现在看起来比较不知所云，先放下引入一个新概念</p>
<p><strong>哈希函数</strong></p>
<p>以最常见的加密函数SHA256为例，输入任何文本，输出一串256位的0/1字符串，哈希函数的特点有</p>
<ul>
<li>对文本有任何轻微改动，计算得到哈希值都不一样</li>
<li>哈希函数不可逆</li>
</ul>
<p>有了哈希函数(这个和数字签名里面的函数有啥区别？) 我们如何来看一个账本消耗的算力多少呢？</p>
<p>在原有账本的基础上</p>
<blockquote>
<p>1 A欠B100元 数字签名(01110000…..)</p>
<p>2 B欠C 100元  110000……</p>
<p>….</p>
</blockquote>
<p>我们规定在这个账本的末位加上一个魔数， 使得整个账本经过哈希运算之后得到的哈希值，前30位(具体位数可以改变)都为0，我们就认为这个账本暂且是合法的。</p>
<p>从概率的角度找到这样一个魔数，是 $1/(2^{30})$  ，并且只能够通过穷举的方式来找。所以可以认为需要很大算力，平时我们说的挖矿其实就在做这个事情。</p>
<p><img src="https://raw.githubusercontent.com/ddl-hust/imagebed/master/20210125232949.png" alt="20210125222452-7na7m6o-image"></p>
<p><strong>区块链( block chain)</strong>就是我们的账本，他把账本拆分成了很多小块，每一块除了有交易记录，还有前一个块的工作量证明(挖矿穷举得到的魔数)，以及当前块工作量证明。</p>
<p><strong>区块建立者</strong></p>
<p>可以理解为有人在全网监听所有交易记录，然后根据这些交易记录去计算魔数，一旦找到满足要求的魔数，就认为一个新的区块被建立，然后将新区块广播到全网。为了奖励这些找到魔数的人，规定给他们一定数目的比特币回报。这也就是我们说的挖矿的收入。</p>
<p>每找到一个区块，意味整个区块链网络系统总的货币变多了。</p>
<p><strong>系统交易员</strong></p>
<p>对于我们不去挖矿的人，我们不需要监听交易记录，即不需要计算产生新的区块，我们需要做的就是收听被矿工挖到并且广播的新区块，并且更新我们自己拥有的一份区块链(账本）</p>
<p>这里又产生了一个问题，即一个矿工伪造一笔交易记录，计算产生一个新的区块，同时不在全网广播，只发给特定人。在这个系统里面做假账的代价有多大？</p>
<p>这里有个原则即</p>
<blockquote>
<p>人们相信他所指向的最长区块链</p>
</blockquote>
<p>每次矿工产生了一个新的区块，收到区块的人并不会立马将区块合并到自己的区块链中，而是观望一段时间，比如规定等五个新的区块才合并一个区块。这样即使Alice欺骗了Bob,产生了下图中上方分叉的一条链，网络中的其他矿工此时也在不停挖矿，产生新的区块，并且在向Bob广播，除非Alices的算力达到全网50%y以上，后者他产生的区块链分支就被认为是假的。</p>
<p><img src="https://raw.githubusercontent.com/ddl-hust/imagebed/master/20210125232904.png" alt="20210125224435-4nit26o-image"></p>
<h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><ol>
<li>前面提到计算魔数，使得散列值前30位为0，这个“30位”会根据当前挖矿难度变化，系统保证大约10分钟产生一个新的区块</li>
<li>比特币系统中的币都来自于生成新区块的奖励，币的总数目被设计为一定的，一开始挖矿生成一个区块能够得到50个比特币，过一段时间减少为25 -&gt;12.5-&gt;6.25…</li>
<li>矿工得到的奖励还可以有每笔交易支付的小费</li>
<li>比特币中每个区块包含的交易记录大约为2400条</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.google.com/presentation/d/1Ari-Y1T1in15-RsbYMQ2rohafGMkvPCSUBbq_luZs4c/present?slide=id.g2acf3bb0d7_0_0" target="_blank" rel="noopener">ppt</a></p>
<p><a href="https://www.blockchain.com/explorer" target="_blank" rel="noopener">比特币查询</a></p>
<p><a href="https://www.youtube.com/watch?v=bBC-nXj3Ng4" target="_blank" rel="noopener">3blue1blown</a></p>
<p><a href="https://www.youtube.com/watch?t=17s&v=-lNgWFbETeI&feature=youtu.be&ab_channel=ProductSchool" target="_blank" rel="noopener">google视频</a></p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>好奇</tag>
      </tags>
  </entry>
</search>
